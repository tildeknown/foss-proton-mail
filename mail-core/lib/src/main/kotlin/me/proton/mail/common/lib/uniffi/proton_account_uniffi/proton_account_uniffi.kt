// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.proton_account_uniffi

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import android.os.Build
import androidx.annotation.RequiresApi
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import uniffi.uniffi_common.FfiConverterTypeUserApiServiceError
import uniffi.uniffi_common.UserApiServiceError
import uniffi.uniffi_common.RustBuffer as RustBufferUserApiServiceError

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_proton_account_uniffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_proton_account_uniffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "proton_mail_uniffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfacePasswordValidatorServiceCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`results`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("onResults", "uniffiFree")
internal open class UniffiVTableCallbackInterfacePasswordValidatorServiceCallback(
    @JvmField internal var `onResults`: UniffiCallbackInterfacePasswordValidatorServiceCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onResults`: UniffiCallbackInterfacePasswordValidatorServiceCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfacePasswordValidatorServiceCallback(`onResults`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePasswordValidatorServiceCallback) {
        `onResults` = other.`onResults`
        `uniffiFree` = other.`uniffiFree`
    }

}






































































































































































// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_proton_account_uniffi_checksum_func_qr_login_scan_screen_total(
): Short
fun uniffi_proton_account_uniffi_checksum_func_qr_login_show_qr_screen_total(
): Short
fun uniffi_proton_account_uniffi_checksum_func_record_change_password_screen_view(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_check_host_device_confirmation(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_delinquent_state(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_generate_sign_in_qr_code(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_get_fido_details(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_2fa(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_host_device_confirmation(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_mailbox_password(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_new_password(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_is_logged_in(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_login(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_migrate(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_password_validator(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_session_id(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_submit_fido(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_submit_mailbox_password(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_submit_new_password(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_submit_totp(
): Short
fun uniffi_proton_account_uniffi_checksum_method_loginflow_user_id(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_change_mbox_pass(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_change_pass(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_fido_details(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_get_state(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_has_fido(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_has_mbp(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_has_totp(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_password_validator(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_step_back(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_submit_fido(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordflow_submit_totp(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservice_validate(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservicehandle_cancel(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_available_countries(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_available_domains(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_complete(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_create(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_get_state(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_password_validator(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_skip_recovery(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_step_back(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_submit_external_username(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_submit_internal_username(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_submit_password(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_submit_recovery_email(
): Short
fun uniffi_proton_account_uniffi_checksum_method_signupflow_submit_recovery_phone(
): Short
fun uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservicecallback_on_results(
): Short
fun ffi_proton_account_uniffi_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "proton_account_uniffi"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            uniffiCallbackInterfacePasswordValidatorServiceCallback.register(lib)
            uniffi.uniffi_common.uniffiEnsureInitialized()
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_proton_account_uniffi_fn_clone_loginflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_loginflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_method_loginflow_check_host_device_confirmation(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_delinquent_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_loginflow_generate_sign_in_qr_code(`ptr`: Pointer,`needEncryptionKey`: Byte,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_get_fido_details(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_2fa(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_host_device_confirmation(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_mailbox_password(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_new_password(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_account_uniffi_fn_method_loginflow_is_logged_in(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_account_uniffi_fn_method_loginflow_login(`ptr`: Pointer,`username`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_migrate(`ptr`: Pointer,`data`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_password_validator(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_session_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_loginflow_submit_fido(`ptr`: Pointer,`fidoData`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_submit_mailbox_password(`ptr`: Pointer,`mailboxPassword`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_submit_new_password(`ptr`: Pointer,`newPassword`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_submit_totp(`ptr`: Pointer,`code`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_loginflow_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_clone_passwordflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_passwordflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_method_passwordflow_change_mbox_pass(`ptr`: Pointer,`currentPassword`: RustBuffer.ByValue,`newMboxPass`: RustBuffer.ByValue,`confirmPassword`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_change_pass(`ptr`: Pointer,`currentPassword`: RustBuffer.ByValue,`newPass`: RustBuffer.ByValue,`confirmPassword`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_fido_details(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_get_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_passwordflow_has_fido(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_passwordflow_has_mbp(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_passwordflow_has_totp(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_passwordflow_password_validator(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_step_back(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_submit_fido(`ptr`: Pointer,`fidoData`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_passwordflow_submit_totp(`ptr`: Pointer,`code`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_passwordvalidatorservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_method_passwordvalidatorservice_validate(`ptr`: Pointer,`passwordType`: RustBuffer.ByValue,`plainPassword`: RustBuffer.ByValue,`callback`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservicehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_passwordvalidatorservicehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_method_passwordvalidatorservicehandle_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservicetoken(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_passwordvalidatorservicetoken(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_clone_signupflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_account_uniffi_fn_free_signupflow(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_method_signupflow_available_countries(`ptr`: Pointer,`defaultCountryCode`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_available_domains(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_complete(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_signupflow_create(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_get_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_account_uniffi_fn_method_signupflow_password_validator(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_skip_recovery(`ptr`: Pointer,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_step_back(`ptr`: Pointer,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_submit_external_username(`ptr`: Pointer,`email`: RustBuffer.ByValue,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_submit_internal_username(`ptr`: Pointer,`username`: RustBuffer.ByValue,`domain`: RustBuffer.ByValue,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_submit_password(`ptr`: Pointer,`password`: RustBuffer.ByValue,`confirmPassword`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_submit_recovery_email(`ptr`: Pointer,`email`: RustBuffer.ByValue,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_method_signupflow_submit_recovery_phone(`ptr`: Pointer,`phone`: RustBuffer.ByValue,`userBehavior`: RustBuffer.ByValue,
): Long
fun uniffi_proton_account_uniffi_fn_init_callback_vtable_passwordvalidatorservicecallback(`vtable`: UniffiVTableCallbackInterfacePasswordValidatorServiceCallback,
): Unit
fun uniffi_proton_account_uniffi_fn_func_qr_login_scan_screen_total(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_func_qr_login_show_qr_screen_total(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_account_uniffi_fn_func_record_change_password_screen_view(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_proton_account_uniffi_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_account_uniffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_account_uniffi_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_proton_account_uniffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_account_uniffi_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_proton_account_uniffi_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_proton_account_uniffi_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_proton_account_uniffi_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_proton_account_uniffi_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_proton_account_uniffi_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_proton_account_uniffi_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_proton_account_uniffi_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_proton_account_uniffi_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_proton_account_uniffi_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_proton_account_uniffi_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_pointer(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_pointer(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun ffi_proton_account_uniffi_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_account_uniffi_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_proton_account_uniffi_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_proton_account_uniffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_proton_account_uniffi_checksum_func_qr_login_scan_screen_total() != 36523.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_func_qr_login_show_qr_screen_total() != 5230.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_func_record_change_password_screen_view() != 3898.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_check_host_device_confirmation() != 32832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_delinquent_state() != 12896.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_generate_sign_in_qr_code() != 22448.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_get_fido_details() != 52013.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_2fa() != 28519.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_host_device_confirmation() != 18412.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_mailbox_password() != 15725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_is_awaiting_new_password() != 47602.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_is_logged_in() != 30422.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_login() != 859.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_migrate() != 31604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_password_validator() != 43133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_session_id() != 13440.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_submit_fido() != 38389.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_submit_mailbox_password() != 15902.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_submit_new_password() != 32185.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_submit_totp() != 25589.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_loginflow_user_id() != 55943.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_change_mbox_pass() != 29202.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_change_pass() != 30547.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_fido_details() != 56946.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_get_state() != 39954.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_has_fido() != 1946.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_has_mbp() != 2684.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_has_totp() != 64631.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_password_validator() != 26099.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_step_back() != 49489.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_submit_fido() != 27299.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordflow_submit_totp() != 49280.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservice_validate() != 29218.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservicehandle_cancel() != 20458.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_available_countries() != 56288.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_available_domains() != 11504.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_complete() != 38533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_create() != 39472.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_get_state() != 12816.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_password_validator() != 44919.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_skip_recovery() != 35779.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_step_back() != 13939.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_submit_external_username() != 18171.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_submit_internal_username() != 34883.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_submit_password() != 9416.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_submit_recovery_email() != 13372.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_signupflow_submit_recovery_phone() != 65341.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_account_uniffi_checksum_method_passwordvalidatorservicecallback_on_results() != 20596.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.


private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
        AndroidSystemCleaner()
    } else {
        UniffiJnaCleaner()
    }

// The SystemCleaner, available from API Level 33.
// Some API Level 33 OSes do not support using it, so we require API Level 34.
@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleaner : UniffiCleaner {
    val cleaner = android.system.SystemCleaner.cleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        AndroidSystemCleanable(cleaner.register(value, cleanUpTask))
}

@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleanable(
    private val cleanable: java.lang.ref.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Flow through the required steps to authenticate and login a user.
 *
 * The first stage of the login is the submission of the user credentials with [`LoginFlow::login`].
 * If this stage succeeds, you can check if the user needs to submit a 2FA token with
 * [`LoginFlow::is_awaiting_2fa`].
 *
 * If the flow is awaiting a 2FA token, call [`LoginFlow::submit_totp`] or
 * [`LoginFlow::submit_fido`] with respective code depending on the user choice and ability.
 *
 * Finally, when the user is logged in, [`LoginFlow::is_logged_in`] will return true and
 * the flow can be converted into a user session with [`LoginFlow::to_user_context`].
 *
 * # Human Verification
 * If at any stage during the login human verification is requested, the requests will fail with
 * the [`LoginFlowError::HumanVerificationRequired`] error. If this happens, the process should
 * be repeated.

 */
public interface LoginFlowInterface {
    
    /**
     * Verifies host device confirmation for QR code login and completes the authentication process.
     *
     * This method waits for host device confirmation of the QR code login, decodes the payload using
     * the provided encryption key, fetches user information, validates the passphrase, and stores user
     * data. On success, it constructs a completed authentication state with session details.
     */
    suspend fun `checkHostDeviceConfirmation`(): LoginFlowCheckHostDeviceConfirmationResult
    
    /**
     * Return delinquent state of the user
     */
    fun `delinquentState`(): LoginFlowDelinquentStateResult
    
    /**
     * Generates a QR code for user sign-in, optionally including an encryption key.
     *
     * This method initiates a code-based authentication flow and constructs a QR code string
     * in the format: `version:user_code:encryption_key_base64:client_id`.
     * If an encryption key is required, a secure 32-byte key is generated and encoded in Base64.
     * The resulting state includes the QR code, user code, and encryption key (if applicable) for further processing.
     *
     * # Arguments
     * * `need_encryption_key` - If `true`, generates a 32-byte encryption key; otherwise, uses an empty default.
     */
    suspend fun `generateSignInQrCode`(`needEncryptionKey`: kotlin.Boolean): LoginFlowGenerateSignInQrCodeResult
    
    /**
     * Get the FIDO2 details for authentication.
     */
    suspend fun `getFidoDetails`(): LoginFlowGetFidoDetailsResult
    
    /**
     * Check whether the login flow is awaiting 2FA input.
     */
    fun `isAwaiting2fa`(): kotlin.Boolean
    
    /**
     * Check whether the login flow is waiting for Host Device confirmationo
     */
    fun `isAwaitingHostDeviceConfirmation`(): kotlin.Boolean
    
    /**
     * Check whether the login flow is awaiting mailbox password input.
     */
    fun `isAwaitingMailboxPassword`(): kotlin.Boolean
    
    /**
     * Check whether the login flow is awaiting a new password.
     */
    fun `isAwaitingNewPassword`(): kotlin.Boolean
    
    /**
     * Check whether the login flow has completed.
     */
    fun `isLoggedIn`(): kotlin.Boolean
    
    /**
     * Login with user, password and optional fingerprints payload (for anti-abuse).
     * * `fingerprint_payload` - a JSON array of objects serialized to a `String`.
     */
    suspend fun `login`(`username`: kotlin.String, `password`: kotlin.String, `userBehavior`: UserBehavior?): LoginFlowLoginResult
    
    /**
     * # Warning
     *
     * Should be used **only** to migrate existing sessions from legacy (pre-ET) version
     * of the app. Used to prevent users from being logged-out after the update

     */
    suspend fun `migrate`(`data`: MigrationData): LoginFlowMigrateResult
    
    /**
     * Returns a password validator service.
     */
    suspend fun `passwordValidator`(): PasswordValidatorService?
    
    /**
     * Get the session ID that has been (or is in the process of) being created.
     *
     * This can be used to resume a login flow.
     */
    fun `sessionId`(): LoginFlowSessionIdResult
    
    /**
     * Submit 2FA fido2 code.
     */
    suspend fun `submitFido`(`fidoData`: Fido2RequestFfi): LoginFlowSubmitFidoResult
    
    /**
     * Submit mailbox password.
     */
    suspend fun `submitMailboxPassword`(`mailboxPassword`: kotlin.String): LoginFlowSubmitMailboxPasswordResult
    
    /**
     * Submit a new password for users with temporary passwords.
     */
    suspend fun `submitNewPassword`(`newPassword`: kotlin.String): LoginFlowSubmitNewPasswordResult
    
    /**
     * Submit 2FA totp code.
     */
    suspend fun `submitTotp`(`code`: kotlin.String): LoginFlowSubmitTotpResult
    
    /**
     * Get the user ID of the user that has (or is in the process of) logging in.
     *
     * This can be used to resume a login flow.
     */
    fun `userId`(): LoginFlowUserIdResult
    
    companion object
}

/**
 * Flow through the required steps to authenticate and login a user.
 *
 * The first stage of the login is the submission of the user credentials with [`LoginFlow::login`].
 * If this stage succeeds, you can check if the user needs to submit a 2FA token with
 * [`LoginFlow::is_awaiting_2fa`].
 *
 * If the flow is awaiting a 2FA token, call [`LoginFlow::submit_totp`] or
 * [`LoginFlow::submit_fido`] with respective code depending on the user choice and ability.
 *
 * Finally, when the user is logged in, [`LoginFlow::is_logged_in`] will return true and
 * the flow can be converted into a user session with [`LoginFlow::to_user_context`].
 *
 * # Human Verification
 * If at any stage during the login human verification is requested, the requests will fail with
 * the [`LoginFlowError::HumanVerificationRequired`] error. If this happens, the process should
 * be repeated.

 */
open class LoginFlow: Disposable, AutoCloseable, LoginFlowInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_loginflow(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_loginflow(pointer!!, status)
        }
    }

    
    /**
     * Verifies host device confirmation for QR code login and completes the authentication process.
     *
     * This method waits for host device confirmation of the QR code login, decodes the payload using
     * the provided encryption key, fetches user information, validates the passphrase, and stores user
     * data. On success, it constructs a completed authentication state with session details.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `checkHostDeviceConfirmation`() : LoginFlowCheckHostDeviceConfirmationResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_check_host_device_confirmation(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowCheckHostDeviceConfirmationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Return delinquent state of the user
     */override fun `delinquentState`(): LoginFlowDelinquentStateResult {
            return FfiConverterTypeLoginFlowDelinquentStateResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_delinquent_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Generates a QR code for user sign-in, optionally including an encryption key.
     *
     * This method initiates a code-based authentication flow and constructs a QR code string
     * in the format: `version:user_code:encryption_key_base64:client_id`.
     * If an encryption key is required, a secure 32-byte key is generated and encoded in Base64.
     * The resulting state includes the QR code, user code, and encryption key (if applicable) for further processing.
     *
     * # Arguments
     * * `need_encryption_key` - If `true`, generates a 32-byte encryption key; otherwise, uses an empty default.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `generateSignInQrCode`(`needEncryptionKey`: kotlin.Boolean) : LoginFlowGenerateSignInQrCodeResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_generate_sign_in_qr_code(
                thisPtr,
                FfiConverterBoolean.lower(`needEncryptionKey`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowGenerateSignInQrCodeResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the FIDO2 details for authentication.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getFidoDetails`() : LoginFlowGetFidoDetailsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_get_fido_details(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowGetFidoDetailsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Check whether the login flow is awaiting 2FA input.
     */override fun `isAwaiting2fa`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_2fa(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check whether the login flow is waiting for Host Device confirmationo
     */override fun `isAwaitingHostDeviceConfirmation`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_host_device_confirmation(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check whether the login flow is awaiting mailbox password input.
     */override fun `isAwaitingMailboxPassword`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_mailbox_password(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check whether the login flow is awaiting a new password.
     */override fun `isAwaitingNewPassword`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_is_awaiting_new_password(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check whether the login flow has completed.
     */override fun `isLoggedIn`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_is_logged_in(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Login with user, password and optional fingerprints payload (for anti-abuse).
     * * `fingerprint_payload` - a JSON array of objects serialized to a `String`.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `login`(`username`: kotlin.String, `password`: kotlin.String, `userBehavior`: UserBehavior?) : LoginFlowLoginResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_login(
                thisPtr,
                FfiConverterString.lower(`username`),FfiConverterString.lower(`password`),FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowLoginResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * # Warning
     *
     * Should be used **only** to migrate existing sessions from legacy (pre-ET) version
     * of the app. Used to prevent users from being logged-out after the update

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `migrate`(`data`: MigrationData) : LoginFlowMigrateResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_migrate(
                thisPtr,
                FfiConverterTypeMigrationData.lower(`data`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowMigrateResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns a password validator service.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `passwordValidator`() : PasswordValidatorService? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_password_validator(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePasswordValidatorService.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the session ID that has been (or is in the process of) being created.
     *
     * This can be used to resume a login flow.
     */override fun `sessionId`(): LoginFlowSessionIdResult {
            return FfiConverterTypeLoginFlowSessionIdResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_session_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Submit 2FA fido2 code.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitFido`(`fidoData`: Fido2RequestFfi) : LoginFlowSubmitFidoResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_submit_fido(
                thisPtr,
                FfiConverterTypeFido2RequestFfi.lower(`fidoData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowSubmitFidoResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit mailbox password.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitMailboxPassword`(`mailboxPassword`: kotlin.String) : LoginFlowSubmitMailboxPasswordResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_submit_mailbox_password(
                thisPtr,
                FfiConverterString.lower(`mailboxPassword`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowSubmitMailboxPasswordResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit a new password for users with temporary passwords.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitNewPassword`(`newPassword`: kotlin.String) : LoginFlowSubmitNewPasswordResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_submit_new_password(
                thisPtr,
                FfiConverterString.lower(`newPassword`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowSubmitNewPasswordResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit 2FA totp code.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitTotp`(`code`: kotlin.String) : LoginFlowSubmitTotpResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_submit_totp(
                thisPtr,
                FfiConverterString.lower(`code`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLoginFlowSubmitTotpResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the user ID of the user that has (or is in the process of) logging in.
     *
     * This can be used to resume a login flow.
     */override fun `userId`(): LoginFlowUserIdResult {
            return FfiConverterTypeLoginFlowUserIdResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_loginflow_user_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlow: FfiConverter<LoginFlow, Pointer> {

    override fun lower(value: LoginFlow): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): LoginFlow {
        return LoginFlow(value)
    }

    override fun read(buf: ByteBuffer): LoginFlow {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: LoginFlow) = 8UL

    override fun write(value: LoginFlow, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Manages the password change process for a user.
 */
public interface PasswordFlowInterface {
    
    /**
     * Change the mailbox password; leaves the account password unchanged.
     */
    suspend fun `changeMboxPass`(`currentPassword`: kotlin.String, `newMboxPass`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?): PasswordFlowChangeMboxPassResult
    
    /**
     * Change the account password; leaves the mailbox password (if any) unchanged.
     */
    suspend fun `changePass`(`currentPassword`: kotlin.String, `newPass`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?): PasswordFlowChangePassResult
    
    /**
     * Get the FIDO2 details for authentication.
     */
    suspend fun `fidoDetails`(): PasswordFlowFidoDetailsResult
    
    /**
     * Get the current state of the `PasswordFlow`
     */
    fun `getState`(): SimplePasswordState
    
    /**
     * Get whether the account has FIDO2 enabled.
     */
    fun `hasFido`(): PasswordFlowHasFidoResult
    
    /**
     * Get whether the account has a mailbox password.
     */
    fun `hasMbp`(): PasswordFlowHasMbpResult
    
    /**
     * Get whether the account has TOTP enabled.
     */
    fun `hasTotp`(): PasswordFlowHasTotpResult
    
    /**
     * Returns a password validator service.
     */
    suspend fun `passwordValidator`(): PasswordValidatorService?
    
    /**
     * Step the flow back to the previous state.
     */
    suspend fun `stepBack`(): PasswordFlowStepBackResult
    
    /**
     * Submit FIDO2 authentication data.
     */
    suspend fun `submitFido`(`fidoData`: Fido2RequestFfi): PasswordFlowSubmitFidoResult
    
    /**
     * Submit a two-factor authentication code.
     */
    suspend fun `submitTotp`(`code`: kotlin.String): PasswordFlowSubmitTotpResult
    
    companion object
}

/**
 * Manages the password change process for a user.
 */
open class PasswordFlow: Disposable, AutoCloseable, PasswordFlowInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_passwordflow(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_passwordflow(pointer!!, status)
        }
    }

    
    /**
     * Change the mailbox password; leaves the account password unchanged.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `changeMboxPass`(`currentPassword`: kotlin.String, `newMboxPass`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?) : PasswordFlowChangeMboxPassResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_change_mbox_pass(
                thisPtr,
                FfiConverterString.lower(`currentPassword`),FfiConverterString.lower(`newMboxPass`),FfiConverterString.lower(`confirmPassword`),FfiConverterOptionalTypePasswordValidatorServiceToken.lower(`token`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowChangeMboxPassResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Change the account password; leaves the mailbox password (if any) unchanged.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `changePass`(`currentPassword`: kotlin.String, `newPass`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?) : PasswordFlowChangePassResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_change_pass(
                thisPtr,
                FfiConverterString.lower(`currentPassword`),FfiConverterString.lower(`newPass`),FfiConverterString.lower(`confirmPassword`),FfiConverterOptionalTypePasswordValidatorServiceToken.lower(`token`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowChangePassResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the FIDO2 details for authentication.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fidoDetails`() : PasswordFlowFidoDetailsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_fido_details(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowFidoDetailsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the current state of the `PasswordFlow`
     */override fun `getState`(): SimplePasswordState {
            return FfiConverterTypeSimplePasswordState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_get_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get whether the account has FIDO2 enabled.
     */override fun `hasFido`(): PasswordFlowHasFidoResult {
            return FfiConverterTypePasswordFlowHasFidoResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_has_fido(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get whether the account has a mailbox password.
     */override fun `hasMbp`(): PasswordFlowHasMbpResult {
            return FfiConverterTypePasswordFlowHasMbpResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_has_mbp(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get whether the account has TOTP enabled.
     */override fun `hasTotp`(): PasswordFlowHasTotpResult {
            return FfiConverterTypePasswordFlowHasTotpResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_has_totp(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns a password validator service.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `passwordValidator`() : PasswordValidatorService? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_password_validator(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePasswordValidatorService.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Step the flow back to the previous state.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stepBack`() : PasswordFlowStepBackResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_step_back(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowStepBackResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit FIDO2 authentication data.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitFido`(`fidoData`: Fido2RequestFfi) : PasswordFlowSubmitFidoResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_submit_fido(
                thisPtr,
                FfiConverterTypeFido2RequestFfi.lower(`fidoData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowSubmitFidoResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit a two-factor authentication code.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitTotp`(`code`: kotlin.String) : PasswordFlowSubmitTotpResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordflow_submit_totp(
                thisPtr,
                FfiConverterString.lower(`code`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypePasswordFlowSubmitTotpResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlow: FfiConverter<PasswordFlow, Pointer> {

    override fun lower(value: PasswordFlow): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PasswordFlow {
        return PasswordFlow(value)
    }

    override fun read(buf: ByteBuffer): PasswordFlow {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PasswordFlow) = 8UL

    override fun write(value: PasswordFlow, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PasswordValidatorServiceInterface {
    
    fun `validate`(`passwordType`: PasswordType, `plainPassword`: kotlin.String, `callback`: PasswordValidatorServiceCallback): PasswordValidatorServiceHandle
    
    companion object
}

open class PasswordValidatorService: Disposable, AutoCloseable, PasswordValidatorServiceInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_passwordvalidatorservice(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservice(pointer!!, status)
        }
    }

    override fun `validate`(`passwordType`: PasswordType, `plainPassword`: kotlin.String, `callback`: PasswordValidatorServiceCallback): PasswordValidatorServiceHandle {
            return FfiConverterTypePasswordValidatorServiceHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordvalidatorservice_validate(
        it, FfiConverterTypePasswordType.lower(`passwordType`),FfiConverterString.lower(`plainPassword`),FfiConverterTypePasswordValidatorServiceCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordValidatorService: FfiConverter<PasswordValidatorService, Pointer> {

    override fun lower(value: PasswordValidatorService): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PasswordValidatorService {
        return PasswordValidatorService(value)
    }

    override fun read(buf: ByteBuffer): PasswordValidatorService {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PasswordValidatorService) = 8UL

    override fun write(value: PasswordValidatorService, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Handle to cancel ongoing password validation.
 */
public interface PasswordValidatorServiceHandleInterface {
    
    /**
     * Cancel the ongoing validation.
     */
    fun `cancel`()
    
    companion object
}

/**
 * Handle to cancel ongoing password validation.
 */
open class PasswordValidatorServiceHandle: Disposable, AutoCloseable, PasswordValidatorServiceHandleInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_passwordvalidatorservicehandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservicehandle(pointer!!, status)
        }
    }

    
    /**
     * Cancel the ongoing validation.
     */override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_passwordvalidatorservicehandle_cancel(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordValidatorServiceHandle: FfiConverter<PasswordValidatorServiceHandle, Pointer> {

    override fun lower(value: PasswordValidatorServiceHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PasswordValidatorServiceHandle {
        return PasswordValidatorServiceHandle(value)
    }

    override fun read(buf: ByteBuffer): PasswordValidatorServiceHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PasswordValidatorServiceHandle) = 8UL

    override fun write(value: PasswordValidatorServiceHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Represents a confirmation that a given password was validated.
 */
public interface PasswordValidatorServiceTokenInterface {
    
    companion object
}

/**
 * Represents a confirmation that a given password was validated.
 */
open class PasswordValidatorServiceToken: Disposable, AutoCloseable, PasswordValidatorServiceTokenInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_passwordvalidatorservicetoken(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_passwordvalidatorservicetoken(pointer!!, status)
        }
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordValidatorServiceToken: FfiConverter<PasswordValidatorServiceToken, Pointer> {

    override fun lower(value: PasswordValidatorServiceToken): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PasswordValidatorServiceToken {
        return PasswordValidatorServiceToken(value)
    }

    override fun read(buf: ByteBuffer): PasswordValidatorServiceToken {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PasswordValidatorServiceToken) = 8UL

    override fun write(value: PasswordValidatorServiceToken, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Manages the state and transitions for the user signup process.
 */
public interface SignupFlowInterface {
    
    /**
     * Get the list of available countries.
     */
    suspend fun `availableCountries`(`defaultCountryCode`: kotlin.String): SignupFlowAvailableCountriesResult
    
    /**
     * Get the list of available domains (e.g., "proton.me", "protonmail.com").
     */
    suspend fun `availableDomains`(): SignupFlowAvailableDomainsResult
    
    /**
     * Complete the signup flow, returning the user ID and address ID.
     */
    fun `complete`(): SignupFlowCompleteResult
    
    /**
     * Create the account.
     */
    suspend fun `create`(): SignupFlowCreateResult
    
    /**
     * Get the current state of the `SignupFlow`
     */
    fun `getState`(): SimpleSignupState
    
    /**
     * Returns a password validator service.
     */
    suspend fun `passwordValidator`(): PasswordValidatorService?
    
    /**
     * Skip providing recovery information.
     */
    suspend fun `skipRecovery`(`userBehavior`: UserBehavior?): SignupFlowSkipRecoveryResult
    
    /**
     * Step the flow back to the previous State.
     */
    suspend fun `stepBack`(): SignupFlowStepBackResult
    
    /**
     * Submit an external email address.
     */
    suspend fun `submitExternalUsername`(`email`: kotlin.String, `userBehavior`: UserBehavior?): SignupFlowSubmitExternalUsernameResult
    
    /**
     * Submit an internal Proton username.
     */
    suspend fun `submitInternalUsername`(`username`: kotlin.String, `domain`: kotlin.String, `userBehavior`: UserBehavior?): SignupFlowSubmitInternalUsernameResult
    
    /**
     * Submit validated password.
     */
    suspend fun `submitPassword`(`password`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?): SignupFlowSubmitPasswordResult
    
    /**
     * Submit a recovery email address.
     */
    suspend fun `submitRecoveryEmail`(`email`: kotlin.String, `userBehavior`: UserBehavior?): SignupFlowSubmitRecoveryEmailResult
    
    /**
     * Submit a recovery phone number.
     */
    suspend fun `submitRecoveryPhone`(`phone`: kotlin.String, `userBehavior`: UserBehavior?): SignupFlowSubmitRecoveryPhoneResult
    
    companion object
}

/**
 * Manages the state and transitions for the user signup process.
 */
open class SignupFlow: Disposable, AutoCloseable, SignupFlowInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_free_signupflow(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_clone_signupflow(pointer!!, status)
        }
    }

    
    /**
     * Get the list of available countries.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `availableCountries`(`defaultCountryCode`: kotlin.String) : SignupFlowAvailableCountriesResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_available_countries(
                thisPtr,
                FfiConverterString.lower(`defaultCountryCode`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowAvailableCountriesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the list of available domains (e.g., "proton.me", "protonmail.com").
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `availableDomains`() : SignupFlowAvailableDomainsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_available_domains(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowAvailableDomainsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Complete the signup flow, returning the user ID and address ID.
     */override fun `complete`(): SignupFlowCompleteResult {
            return FfiConverterTypeSignupFlowCompleteResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_complete(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create the account.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `create`() : SignupFlowCreateResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_create(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowCreateResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the current state of the `SignupFlow`
     */override fun `getState`(): SimpleSignupState {
            return FfiConverterTypeSimpleSignupState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_get_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns a password validator service.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `passwordValidator`() : PasswordValidatorService? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_password_validator(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePasswordValidatorService.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Skip providing recovery information.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `skipRecovery`(`userBehavior`: UserBehavior?) : SignupFlowSkipRecoveryResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_skip_recovery(
                thisPtr,
                FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSkipRecoveryResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Step the flow back to the previous State.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stepBack`() : SignupFlowStepBackResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_step_back(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowStepBackResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit an external email address.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitExternalUsername`(`email`: kotlin.String, `userBehavior`: UserBehavior?) : SignupFlowSubmitExternalUsernameResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_submit_external_username(
                thisPtr,
                FfiConverterString.lower(`email`),FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSubmitExternalUsernameResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit an internal Proton username.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitInternalUsername`(`username`: kotlin.String, `domain`: kotlin.String, `userBehavior`: UserBehavior?) : SignupFlowSubmitInternalUsernameResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_submit_internal_username(
                thisPtr,
                FfiConverterString.lower(`username`),FfiConverterString.lower(`domain`),FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSubmitInternalUsernameResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit validated password.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitPassword`(`password`: kotlin.String, `confirmPassword`: kotlin.String, `token`: PasswordValidatorServiceToken?) : SignupFlowSubmitPasswordResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_submit_password(
                thisPtr,
                FfiConverterString.lower(`password`),FfiConverterString.lower(`confirmPassword`),FfiConverterOptionalTypePasswordValidatorServiceToken.lower(`token`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSubmitPasswordResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit a recovery email address.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitRecoveryEmail`(`email`: kotlin.String, `userBehavior`: UserBehavior?) : SignupFlowSubmitRecoveryEmailResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_submit_recovery_email(
                thisPtr,
                FfiConverterString.lower(`email`),FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSubmitRecoveryEmailResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Submit a recovery phone number.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `submitRecoveryPhone`(`phone`: kotlin.String, `userBehavior`: UserBehavior?) : SignupFlowSubmitRecoveryPhoneResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_method_signupflow_submit_recovery_phone(
                thisPtr,
                FfiConverterString.lower(`phone`),FfiConverterOptionalTypeUserBehavior.lower(`userBehavior`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_account_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignupFlowSubmitRecoveryPhoneResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlow: FfiConverter<SignupFlow, Pointer> {

    override fun lower(value: SignupFlow): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SignupFlow {
        return SignupFlow(value)
    }

    override fun read(buf: ByteBuffer): SignupFlow {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SignupFlow) = 8UL

    override fun write(value: SignupFlow, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



data class Countries (
    var `countries`: List<Country>, 
    var `defaultCountry`: Country?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCountries: FfiConverterRustBuffer<Countries> {
    override fun read(buf: ByteBuffer): Countries {
        return Countries(
            FfiConverterSequenceTypeCountry.read(buf),
            FfiConverterOptionalTypeCountry.read(buf),
        )
    }

    override fun allocationSize(value: Countries) = (
            FfiConverterSequenceTypeCountry.allocationSize(value.`countries`) +
            FfiConverterOptionalTypeCountry.allocationSize(value.`defaultCountry`)
    )

    override fun write(value: Countries, buf: ByteBuffer) {
            FfiConverterSequenceTypeCountry.write(value.`countries`, buf)
            FfiConverterOptionalTypeCountry.write(value.`defaultCountry`, buf)
    }
}



data class Country (
    var `countryCode`: kotlin.String, 
    var `countryEn`: kotlin.String, 
    var `phoneCode`: kotlin.UInt
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCountry: FfiConverterRustBuffer<Country> {
    override fun read(buf: ByteBuffer): Country {
        return Country(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: Country) = (
            FfiConverterString.allocationSize(value.`countryCode`) +
            FfiConverterString.allocationSize(value.`countryEn`) +
            FfiConverterUInt.allocationSize(value.`phoneCode`)
    )

    override fun write(value: Country, buf: ByteBuffer) {
            FfiConverterString.write(value.`countryCode`, buf)
            FfiConverterString.write(value.`countryEn`, buf)
            FfiConverterUInt.write(value.`phoneCode`, buf)
    }
}



data class Fido2AuthenticationExtensionsClientInputsFfi (
    var `appId`: kotlin.String?, 
    var `thirdPartyPayment`: kotlin.Boolean?, 
    var `uvm`: kotlin.Boolean?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2AuthenticationExtensionsClientInputsFfi: FfiConverterRustBuffer<Fido2AuthenticationExtensionsClientInputsFfi> {
    override fun read(buf: ByteBuffer): Fido2AuthenticationExtensionsClientInputsFfi {
        return Fido2AuthenticationExtensionsClientInputsFfi(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Fido2AuthenticationExtensionsClientInputsFfi) = (
            FfiConverterOptionalString.allocationSize(value.`appId`) +
            FfiConverterOptionalBoolean.allocationSize(value.`thirdPartyPayment`) +
            FfiConverterOptionalBoolean.allocationSize(value.`uvm`)
    )

    override fun write(value: Fido2AuthenticationExtensionsClientInputsFfi, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`appId`, buf)
            FfiConverterOptionalBoolean.write(value.`thirdPartyPayment`, buf)
            FfiConverterOptionalBoolean.write(value.`uvm`, buf)
    }
}



data class Fido2AuthenticationOptionsFfi (
    var `publicKey`: Fido2PublicKeyCredentialRequestOptionsFfi
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2AuthenticationOptionsFfi: FfiConverterRustBuffer<Fido2AuthenticationOptionsFfi> {
    override fun read(buf: ByteBuffer): Fido2AuthenticationOptionsFfi {
        return Fido2AuthenticationOptionsFfi(
            FfiConverterTypeFido2PublicKeyCredentialRequestOptionsFfi.read(buf),
        )
    }

    override fun allocationSize(value: Fido2AuthenticationOptionsFfi) = (
            FfiConverterTypeFido2PublicKeyCredentialRequestOptionsFfi.allocationSize(value.`publicKey`)
    )

    override fun write(value: Fido2AuthenticationOptionsFfi, buf: ByteBuffer) {
            FfiConverterTypeFido2PublicKeyCredentialRequestOptionsFfi.write(value.`publicKey`, buf)
    }
}



data class Fido2PublicKeyCredentialDescriptorFfi (
    var `credentialType`: kotlin.String, 
    var `id`: kotlin.ByteArray, 
    var `transports`: List<kotlin.String>?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2PublicKeyCredentialDescriptorFfi: FfiConverterRustBuffer<Fido2PublicKeyCredentialDescriptorFfi> {
    override fun read(buf: ByteBuffer): Fido2PublicKeyCredentialDescriptorFfi {
        return Fido2PublicKeyCredentialDescriptorFfi(
            FfiConverterString.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: Fido2PublicKeyCredentialDescriptorFfi) = (
            FfiConverterString.allocationSize(value.`credentialType`) +
            FfiConverterByteArray.allocationSize(value.`id`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`transports`)
    )

    override fun write(value: Fido2PublicKeyCredentialDescriptorFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`credentialType`, buf)
            FfiConverterByteArray.write(value.`id`, buf)
            FfiConverterOptionalSequenceString.write(value.`transports`, buf)
    }
}



data class Fido2PublicKeyCredentialRequestOptionsFfi (
    var `challenge`: kotlin.ByteArray, 
    var `timeout`: kotlin.ULong?, 
    var `rpId`: kotlin.String?, 
    var `allowCredentials`: List<Fido2PublicKeyCredentialDescriptorFfi>?, 
    var `userVerification`: kotlin.String?, 
    var `extensions`: Fido2AuthenticationExtensionsClientInputsFfi?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2PublicKeyCredentialRequestOptionsFfi: FfiConverterRustBuffer<Fido2PublicKeyCredentialRequestOptionsFfi> {
    override fun read(buf: ByteBuffer): Fido2PublicKeyCredentialRequestOptionsFfi {
        return Fido2PublicKeyCredentialRequestOptionsFfi(
            FfiConverterByteArray.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalSequenceTypeFido2PublicKeyCredentialDescriptorFfi.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFido2AuthenticationExtensionsClientInputsFfi.read(buf),
        )
    }

    override fun allocationSize(value: Fido2PublicKeyCredentialRequestOptionsFfi) = (
            FfiConverterByteArray.allocationSize(value.`challenge`) +
            FfiConverterOptionalULong.allocationSize(value.`timeout`) +
            FfiConverterOptionalString.allocationSize(value.`rpId`) +
            FfiConverterOptionalSequenceTypeFido2PublicKeyCredentialDescriptorFfi.allocationSize(value.`allowCredentials`) +
            FfiConverterOptionalString.allocationSize(value.`userVerification`) +
            FfiConverterOptionalTypeFido2AuthenticationExtensionsClientInputsFfi.allocationSize(value.`extensions`)
    )

    override fun write(value: Fido2PublicKeyCredentialRequestOptionsFfi, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`challenge`, buf)
            FfiConverterOptionalULong.write(value.`timeout`, buf)
            FfiConverterOptionalString.write(value.`rpId`, buf)
            FfiConverterOptionalSequenceTypeFido2PublicKeyCredentialDescriptorFfi.write(value.`allowCredentials`, buf)
            FfiConverterOptionalString.write(value.`userVerification`, buf)
            FfiConverterOptionalTypeFido2AuthenticationExtensionsClientInputsFfi.write(value.`extensions`, buf)
    }
}



data class Fido2RequestFfi (
    var `authenticationOptions`: Fido2AuthenticationOptionsFfi, 
    var `clientData`: kotlin.ByteArray, 
    var `authenticatorData`: kotlin.ByteArray, 
    var `signature`: kotlin.ByteArray, 
    var `credentialId`: kotlin.ByteArray
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2RequestFfi: FfiConverterRustBuffer<Fido2RequestFfi> {
    override fun read(buf: ByteBuffer): Fido2RequestFfi {
        return Fido2RequestFfi(
            FfiConverterTypeFido2AuthenticationOptionsFfi.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: Fido2RequestFfi) = (
            FfiConverterTypeFido2AuthenticationOptionsFfi.allocationSize(value.`authenticationOptions`) +
            FfiConverterByteArray.allocationSize(value.`clientData`) +
            FfiConverterByteArray.allocationSize(value.`authenticatorData`) +
            FfiConverterByteArray.allocationSize(value.`signature`) +
            FfiConverterByteArray.allocationSize(value.`credentialId`)
    )

    override fun write(value: Fido2RequestFfi, buf: ByteBuffer) {
            FfiConverterTypeFido2AuthenticationOptionsFfi.write(value.`authenticationOptions`, buf)
            FfiConverterByteArray.write(value.`clientData`, buf)
            FfiConverterByteArray.write(value.`authenticatorData`, buf)
            FfiConverterByteArray.write(value.`signature`, buf)
            FfiConverterByteArray.write(value.`credentialId`, buf)
    }
}



data class Fido2ResponseFfi (
    var `authenticationOptions`: Fido2AuthenticationOptionsFfi?, 
    var `registeredKeys`: List<RegisteredKeyFfi>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFido2ResponseFfi: FfiConverterRustBuffer<Fido2ResponseFfi> {
    override fun read(buf: ByteBuffer): Fido2ResponseFfi {
        return Fido2ResponseFfi(
            FfiConverterOptionalTypeFido2AuthenticationOptionsFfi.read(buf),
            FfiConverterSequenceTypeRegisteredKeyFfi.read(buf),
        )
    }

    override fun allocationSize(value: Fido2ResponseFfi) = (
            FfiConverterOptionalTypeFido2AuthenticationOptionsFfi.allocationSize(value.`authenticationOptions`) +
            FfiConverterSequenceTypeRegisteredKeyFfi.allocationSize(value.`registeredKeys`)
    )

    override fun write(value: Fido2ResponseFfi, buf: ByteBuffer) {
            FfiConverterOptionalTypeFido2AuthenticationOptionsFfi.write(value.`authenticationOptions`, buf)
            FfiConverterSequenceTypeRegisteredKeyFfi.write(value.`registeredKeys`, buf)
    }
}



/**
 * All necessary **unencrypted** data for the migration from legacy version
 * of the app
 */
data class MigrationData (
    var `username`: kotlin.String, 
    var `displayName`: kotlin.String, 
    var `primaryAddr`: kotlin.String, 
    var `addressSignatureEnabled`: kotlin.Boolean?, 
    var `mobileSignature`: kotlin.String?, 
    var `mobileSignatureEnabled`: kotlin.Boolean?, 
    var `keySecret`: kotlin.String, 
    var `userId`: kotlin.String, 
    var `sessionId`: kotlin.String, 
    var `passwordMode`: PasswordMode, 
    /**
     * The refresh token. This token must be refreshed before use;
     * once refreshed, it becomes an access token.
     */
    var `refreshToken`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMigrationData: FfiConverterRustBuffer<MigrationData> {
    override fun read(buf: ByteBuffer): MigrationData {
        return MigrationData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypePasswordMode.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MigrationData) = (
            FfiConverterString.allocationSize(value.`username`) +
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterString.allocationSize(value.`primaryAddr`) +
            FfiConverterOptionalBoolean.allocationSize(value.`addressSignatureEnabled`) +
            FfiConverterOptionalString.allocationSize(value.`mobileSignature`) +
            FfiConverterOptionalBoolean.allocationSize(value.`mobileSignatureEnabled`) +
            FfiConverterString.allocationSize(value.`keySecret`) +
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterString.allocationSize(value.`sessionId`) +
            FfiConverterTypePasswordMode.allocationSize(value.`passwordMode`) +
            FfiConverterString.allocationSize(value.`refreshToken`)
    )

    override fun write(value: MigrationData, buf: ByteBuffer) {
            FfiConverterString.write(value.`username`, buf)
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterString.write(value.`primaryAddr`, buf)
            FfiConverterOptionalBoolean.write(value.`addressSignatureEnabled`, buf)
            FfiConverterOptionalString.write(value.`mobileSignature`, buf)
            FfiConverterOptionalBoolean.write(value.`mobileSignatureEnabled`, buf)
            FfiConverterString.write(value.`keySecret`, buf)
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterString.write(value.`sessionId`, buf)
            FfiConverterTypePasswordMode.write(value.`passwordMode`, buf)
            FfiConverterString.write(value.`refreshToken`, buf)
    }
}



data class PasswordValidatorServiceResult (
    /**
     * The message displayed to the user if this validation fails.
     */
    var `errorMessage`: kotlin.String, 
    /**
     * If true, the requirement message should be hidden from the user.
     */
    var `hideIfValid`: kotlin.Boolean, 
    /**
     * If true, passing this validation is not required to proceed.
     */
    var `isOptional`: kotlin.Boolean, 
    /**
     * If true, then this validation has passed.
     */
    var `isValid`: kotlin.Boolean, 
    /**
     * The message displayed to the user, explaining what is needed to pass the validation.
     */
    var `requirementMessage`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordValidatorServiceResult: FfiConverterRustBuffer<PasswordValidatorServiceResult> {
    override fun read(buf: ByteBuffer): PasswordValidatorServiceResult {
        return PasswordValidatorServiceResult(
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PasswordValidatorServiceResult) = (
            FfiConverterString.allocationSize(value.`errorMessage`) +
            FfiConverterBoolean.allocationSize(value.`hideIfValid`) +
            FfiConverterBoolean.allocationSize(value.`isOptional`) +
            FfiConverterBoolean.allocationSize(value.`isValid`) +
            FfiConverterString.allocationSize(value.`requirementMessage`)
    )

    override fun write(value: PasswordValidatorServiceResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`errorMessage`, buf)
            FfiConverterBoolean.write(value.`hideIfValid`, buf)
            FfiConverterBoolean.write(value.`isOptional`, buf)
            FfiConverterBoolean.write(value.`isValid`, buf)
            FfiConverterString.write(value.`requirementMessage`, buf)
    }
}



data class RegisteredKeyFfi (
    var `attestationFormat`: kotlin.String, 
    var `credentialId`: kotlin.ByteArray, 
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRegisteredKeyFfi: FfiConverterRustBuffer<RegisteredKeyFfi> {
    override fun read(buf: ByteBuffer): RegisteredKeyFfi {
        return RegisteredKeyFfi(
            FfiConverterString.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RegisteredKeyFfi) = (
            FfiConverterString.allocationSize(value.`attestationFormat`) +
            FfiConverterByteArray.allocationSize(value.`credentialId`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: RegisteredKeyFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`attestationFormat`, buf)
            FfiConverterByteArray.write(value.`credentialId`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



data class UserAddrId (
    var `userId`: kotlin.String, 
    var `addrId`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserAddrId: FfiConverterRustBuffer<UserAddrId> {
    override fun read(buf: ByteBuffer): UserAddrId {
        return UserAddrId(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: UserAddrId) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterString.allocationSize(value.`addrId`)
    )

    override fun write(value: UserAddrId, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterString.write(value.`addrId`, buf)
    }
}



/**
 * User activity during text input.
 */
data class UserBehavior (
    /**
     * Time from form load to user providing input (in seconds).
     */
    var `timeOnField`: List<kotlin.UInt>, 
    /**
     * Number of clicks / taps during user input.
     */
    var `clickOnField`: kotlin.UInt, 
    /**
     * Text chunks copied during user input.
     */
    var `copyField`: List<kotlin.String>, 
    /**
     * Text chunks pasted during user input.
     */
    var `pasteField`: List<kotlin.String>, 
    /**
     * Characters entered during user input.
     */
    var `keyDownField`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserBehavior: FfiConverterRustBuffer<UserBehavior> {
    override fun read(buf: ByteBuffer): UserBehavior {
        return UserBehavior(
            FfiConverterSequenceUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: UserBehavior) = (
            FfiConverterSequenceUInt.allocationSize(value.`timeOnField`) +
            FfiConverterUInt.allocationSize(value.`clickOnField`) +
            FfiConverterSequenceString.allocationSize(value.`copyField`) +
            FfiConverterSequenceString.allocationSize(value.`pasteField`) +
            FfiConverterSequenceString.allocationSize(value.`keyDownField`)
    )

    override fun write(value: UserBehavior, buf: ByteBuffer) {
            FfiConverterSequenceUInt.write(value.`timeOnField`, buf)
            FfiConverterUInt.write(value.`clickOnField`, buf)
            FfiConverterSequenceString.write(value.`copyField`, buf)
            FfiConverterSequenceString.write(value.`pasteField`, buf)
            FfiConverterSequenceString.write(value.`keyDownField`, buf)
    }
}




enum class ChangePasswordScreenId {
    
    CHANGE_PASSWORD,
    CHANGE_MAILBOX_PASSWORD,
    CHANGE_PASSWORD2FA;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeChangePasswordScreenId: FfiConverterRustBuffer<ChangePasswordScreenId> {
    override fun read(buf: ByteBuffer) = try {
        ChangePasswordScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ChangePasswordScreenId) = 4UL

    override fun write(value: ChangePasswordScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Represents the delinquent state of the user.
 *
 * This enum indicates the payment status of the user's account.
 */

enum class DelinquentState {
    
    /**
     * The user's account is fully paid.
     */
    PAID,
    /**
     * The user's account is available but not yet paid.
     */
    AVAILABLE,
    /**
     * The user's account has an overdue payment.
     */
    OVERDUE,
    /**
     * The user's account is delinquent due to unpaid dues.
     */
    DELINQUENT,
    /**
     * The user's payment has not been received.
     */
    NOT_RECEIVED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDelinquentState: FfiConverterRustBuffer<DelinquentState> {
    override fun read(buf: ByteBuffer) = try {
        DelinquentState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DelinquentState) = 4UL

    override fun write(value: DelinquentState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class LoginError {
    
    /**
     * TODO: Document this variant.
     */
    object InvalidState : LoginError()
    
    
    /**
     * Returned if the credentials are invalid.
     */
    object InvalidCredentials : LoginError()
    
    
    /**
     * Returned if Incorrect 2FA code was provided by the user
     */
    object Incorrect2FaCode : LoginError()
    
    
    /**
     * Returned if the user key cannot be unlocked.
     */
    object CantUnlockUserKey : LoginError()
    
    
    /**
     * Returned if the user is forbidden from logging in.
     */
    object NoLogin : LoginError()
    
    
    /**
     * Returned if the user has no proton address.
     */
    object NoAddress : LoginError()
    
    
    /**
     * Returned if the initial auth request fails.
     */
    data class FlowLogin(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if the TOTP code submission fails.
     */
    data class FlowTotp(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if the FIDO2 challenge response fails.
     */
    data class FlowFido(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if the auth is missing from the store after login.
     */
    object MissingSession : LoginError()
    
    
    /**
     * Returned if a duplicate session is found in the store after login.
     */
    data class DuplicateSession(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we fail to fetch the user info after login.
     */
    data class UserFetch(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we fail to fetch the user settings after login.
     */
    data class SettingsFetch(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we fail to setup the user key.
     */
    data class UserKeySetup(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we decide not to setup the user key.
     */
    object UserKeySetupAborted : LoginError()
    
    
    /**
     * Returned if we fail to fetch the user's addresses after login.
     */
    data class AddressFetch(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we fail to set up a new address.
     */
    data class AddressSetup(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we fail to set up a new address key.
     */
    data class AddressKeySetup(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Returned if we decide not to setup the address keys.
     */
    object AddressKeySetupAborted : LoginError()
    
    
    /**
     * TODO: Document this variant.
     */
    data class KeySecretSaltFetch(
        val v1: UserApiServiceError) : LoginError() {
        companion object
    }
    
    /**
     * Authentication Store operation failed.
     */
    data class AuthStore(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Error during network call
     */
    data class ApiError(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    /**
     * Failed to poll the fork for completion
     */
    data class WithCodePollFlowFailed(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    
    object QrLoginEncoding : LoginError()
    
    
    data class PostLoginValidationFailed(
        val v1: PostLoginValidationError) : LoginError() {
        companion object
    }
    
    data class Other(
        val v1: kotlin.String) : LoginError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginError : FfiConverterRustBuffer<LoginError>{
    override fun read(buf: ByteBuffer): LoginError {
        return when(buf.getInt()) {
            1 -> LoginError.InvalidState
            2 -> LoginError.InvalidCredentials
            3 -> LoginError.Incorrect2FaCode
            4 -> LoginError.CantUnlockUserKey
            5 -> LoginError.NoLogin
            6 -> LoginError.NoAddress
            7 -> LoginError.FlowLogin(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            8 -> LoginError.FlowTotp(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            9 -> LoginError.FlowFido(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            10 -> LoginError.MissingSession
            11 -> LoginError.DuplicateSession(
                FfiConverterString.read(buf),
                )
            12 -> LoginError.UserFetch(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            13 -> LoginError.SettingsFetch(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            14 -> LoginError.UserKeySetup(
                FfiConverterString.read(buf),
                )
            15 -> LoginError.UserKeySetupAborted
            16 -> LoginError.AddressFetch(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            17 -> LoginError.AddressSetup(
                FfiConverterString.read(buf),
                )
            18 -> LoginError.AddressKeySetup(
                FfiConverterString.read(buf),
                )
            19 -> LoginError.AddressKeySetupAborted
            20 -> LoginError.KeySecretSaltFetch(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            21 -> LoginError.AuthStore(
                FfiConverterString.read(buf),
                )
            22 -> LoginError.ApiError(
                FfiConverterString.read(buf),
                )
            23 -> LoginError.WithCodePollFlowFailed(
                FfiConverterString.read(buf),
                )
            24 -> LoginError.QrLoginEncoding
            25 -> LoginError.PostLoginValidationFailed(
                FfiConverterTypePostLoginValidationError.read(buf),
                )
            26 -> LoginError.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginError) = when(value) {
        is LoginError.InvalidState -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.InvalidCredentials -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.Incorrect2FaCode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.CantUnlockUserKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.NoLogin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.NoAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.FlowLogin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.FlowTotp -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.FlowFido -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.MissingSession -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.DuplicateSession -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.UserFetch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.SettingsFetch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.UserKeySetup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.UserKeySetupAborted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.AddressFetch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.AddressSetup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.AddressKeySetup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.AddressKeySetupAborted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.KeySecretSaltFetch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is LoginError.AuthStore -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.ApiError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.WithCodePollFlowFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginError.QrLoginEncoding -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginError.PostLoginValidationFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePostLoginValidationError.allocationSize(value.v1)
            )
        }
        is LoginError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginError, buf: ByteBuffer) {
        when(value) {
            is LoginError.InvalidState -> {
                buf.putInt(1)
                Unit
            }
            is LoginError.InvalidCredentials -> {
                buf.putInt(2)
                Unit
            }
            is LoginError.Incorrect2FaCode -> {
                buf.putInt(3)
                Unit
            }
            is LoginError.CantUnlockUserKey -> {
                buf.putInt(4)
                Unit
            }
            is LoginError.NoLogin -> {
                buf.putInt(5)
                Unit
            }
            is LoginError.NoAddress -> {
                buf.putInt(6)
                Unit
            }
            is LoginError.FlowLogin -> {
                buf.putInt(7)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.FlowTotp -> {
                buf.putInt(8)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.FlowFido -> {
                buf.putInt(9)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.MissingSession -> {
                buf.putInt(10)
                Unit
            }
            is LoginError.DuplicateSession -> {
                buf.putInt(11)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.UserFetch -> {
                buf.putInt(12)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.SettingsFetch -> {
                buf.putInt(13)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.UserKeySetup -> {
                buf.putInt(14)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.UserKeySetupAborted -> {
                buf.putInt(15)
                Unit
            }
            is LoginError.AddressFetch -> {
                buf.putInt(16)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.AddressSetup -> {
                buf.putInt(17)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.AddressKeySetup -> {
                buf.putInt(18)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.AddressKeySetupAborted -> {
                buf.putInt(19)
                Unit
            }
            is LoginError.KeySecretSaltFetch -> {
                buf.putInt(20)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is LoginError.AuthStore -> {
                buf.putInt(21)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.ApiError -> {
                buf.putInt(22)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.WithCodePollFlowFailed -> {
                buf.putInt(23)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginError.QrLoginEncoding -> {
                buf.putInt(24)
                Unit
            }
            is LoginError.PostLoginValidationFailed -> {
                buf.putInt(25)
                FfiConverterTypePostLoginValidationError.write(value.v1, buf)
                Unit
            }
            is LoginError.Other -> {
                buf.putInt(26)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowCheckHostDeviceConfirmationResult {
    
    data class Ok(
        val v1: QrPollingResult) : LoginFlowCheckHostDeviceConfirmationResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowCheckHostDeviceConfirmationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowCheckHostDeviceConfirmationResult : FfiConverterRustBuffer<LoginFlowCheckHostDeviceConfirmationResult>{
    override fun read(buf: ByteBuffer): LoginFlowCheckHostDeviceConfirmationResult {
        return when(buf.getInt()) {
            1 -> LoginFlowCheckHostDeviceConfirmationResult.Ok(
                FfiConverterTypeQrPollingResult.read(buf),
                )
            2 -> LoginFlowCheckHostDeviceConfirmationResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowCheckHostDeviceConfirmationResult) = when(value) {
        is LoginFlowCheckHostDeviceConfirmationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeQrPollingResult.allocationSize(value.v1)
            )
        }
        is LoginFlowCheckHostDeviceConfirmationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowCheckHostDeviceConfirmationResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowCheckHostDeviceConfirmationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeQrPollingResult.write(value.v1, buf)
                Unit
            }
            is LoginFlowCheckHostDeviceConfirmationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowDelinquentStateResult {
    
    data class Ok(
        val v1: DelinquentState) : LoginFlowDelinquentStateResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowDelinquentStateResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowDelinquentStateResult : FfiConverterRustBuffer<LoginFlowDelinquentStateResult>{
    override fun read(buf: ByteBuffer): LoginFlowDelinquentStateResult {
        return when(buf.getInt()) {
            1 -> LoginFlowDelinquentStateResult.Ok(
                FfiConverterTypeDelinquentState.read(buf),
                )
            2 -> LoginFlowDelinquentStateResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowDelinquentStateResult) = when(value) {
        is LoginFlowDelinquentStateResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDelinquentState.allocationSize(value.v1)
            )
        }
        is LoginFlowDelinquentStateResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowDelinquentStateResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowDelinquentStateResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDelinquentState.write(value.v1, buf)
                Unit
            }
            is LoginFlowDelinquentStateResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowGenerateSignInQrCodeResult {
    
    data class Ok(
        val v1: kotlin.String) : LoginFlowGenerateSignInQrCodeResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowGenerateSignInQrCodeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowGenerateSignInQrCodeResult : FfiConverterRustBuffer<LoginFlowGenerateSignInQrCodeResult>{
    override fun read(buf: ByteBuffer): LoginFlowGenerateSignInQrCodeResult {
        return when(buf.getInt()) {
            1 -> LoginFlowGenerateSignInQrCodeResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> LoginFlowGenerateSignInQrCodeResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowGenerateSignInQrCodeResult) = when(value) {
        is LoginFlowGenerateSignInQrCodeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginFlowGenerateSignInQrCodeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowGenerateSignInQrCodeResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowGenerateSignInQrCodeResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginFlowGenerateSignInQrCodeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowGetFidoDetailsResult {
    
    data class Ok(
        val v1: Fido2ResponseFfi?) : LoginFlowGetFidoDetailsResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowGetFidoDetailsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowGetFidoDetailsResult : FfiConverterRustBuffer<LoginFlowGetFidoDetailsResult>{
    override fun read(buf: ByteBuffer): LoginFlowGetFidoDetailsResult {
        return when(buf.getInt()) {
            1 -> LoginFlowGetFidoDetailsResult.Ok(
                FfiConverterOptionalTypeFido2ResponseFfi.read(buf),
                )
            2 -> LoginFlowGetFidoDetailsResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowGetFidoDetailsResult) = when(value) {
        is LoginFlowGetFidoDetailsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeFido2ResponseFfi.allocationSize(value.v1)
            )
        }
        is LoginFlowGetFidoDetailsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowGetFidoDetailsResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowGetFidoDetailsResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeFido2ResponseFfi.write(value.v1, buf)
                Unit
            }
            is LoginFlowGetFidoDetailsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowLoginResult {
    
    object Ok : LoginFlowLoginResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowLoginResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowLoginResult : FfiConverterRustBuffer<LoginFlowLoginResult>{
    override fun read(buf: ByteBuffer): LoginFlowLoginResult {
        return when(buf.getInt()) {
            1 -> LoginFlowLoginResult.Ok
            2 -> LoginFlowLoginResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowLoginResult) = when(value) {
        is LoginFlowLoginResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowLoginResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowLoginResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowLoginResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowLoginResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowMigrateResult {
    
    object Ok : LoginFlowMigrateResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowMigrateResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowMigrateResult : FfiConverterRustBuffer<LoginFlowMigrateResult>{
    override fun read(buf: ByteBuffer): LoginFlowMigrateResult {
        return when(buf.getInt()) {
            1 -> LoginFlowMigrateResult.Ok
            2 -> LoginFlowMigrateResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowMigrateResult) = when(value) {
        is LoginFlowMigrateResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowMigrateResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowMigrateResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowMigrateResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowMigrateResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowSessionIdResult {
    
    data class Ok(
        val v1: kotlin.String) : LoginFlowSessionIdResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowSessionIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowSessionIdResult : FfiConverterRustBuffer<LoginFlowSessionIdResult>{
    override fun read(buf: ByteBuffer): LoginFlowSessionIdResult {
        return when(buf.getInt()) {
            1 -> LoginFlowSessionIdResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> LoginFlowSessionIdResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowSessionIdResult) = when(value) {
        is LoginFlowSessionIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginFlowSessionIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowSessionIdResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowSessionIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginFlowSessionIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowSubmitFidoResult {
    
    object Ok : LoginFlowSubmitFidoResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowSubmitFidoResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowSubmitFidoResult : FfiConverterRustBuffer<LoginFlowSubmitFidoResult>{
    override fun read(buf: ByteBuffer): LoginFlowSubmitFidoResult {
        return when(buf.getInt()) {
            1 -> LoginFlowSubmitFidoResult.Ok
            2 -> LoginFlowSubmitFidoResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowSubmitFidoResult) = when(value) {
        is LoginFlowSubmitFidoResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowSubmitFidoResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowSubmitFidoResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowSubmitFidoResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowSubmitFidoResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowSubmitMailboxPasswordResult {
    
    object Ok : LoginFlowSubmitMailboxPasswordResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowSubmitMailboxPasswordResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowSubmitMailboxPasswordResult : FfiConverterRustBuffer<LoginFlowSubmitMailboxPasswordResult>{
    override fun read(buf: ByteBuffer): LoginFlowSubmitMailboxPasswordResult {
        return when(buf.getInt()) {
            1 -> LoginFlowSubmitMailboxPasswordResult.Ok
            2 -> LoginFlowSubmitMailboxPasswordResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowSubmitMailboxPasswordResult) = when(value) {
        is LoginFlowSubmitMailboxPasswordResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowSubmitMailboxPasswordResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowSubmitMailboxPasswordResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowSubmitMailboxPasswordResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowSubmitMailboxPasswordResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowSubmitNewPasswordResult {
    
    object Ok : LoginFlowSubmitNewPasswordResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowSubmitNewPasswordResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowSubmitNewPasswordResult : FfiConverterRustBuffer<LoginFlowSubmitNewPasswordResult>{
    override fun read(buf: ByteBuffer): LoginFlowSubmitNewPasswordResult {
        return when(buf.getInt()) {
            1 -> LoginFlowSubmitNewPasswordResult.Ok
            2 -> LoginFlowSubmitNewPasswordResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowSubmitNewPasswordResult) = when(value) {
        is LoginFlowSubmitNewPasswordResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowSubmitNewPasswordResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowSubmitNewPasswordResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowSubmitNewPasswordResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowSubmitNewPasswordResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowSubmitTotpResult {
    
    object Ok : LoginFlowSubmitTotpResult()
    
    
    data class Error(
        val v1: LoginError) : LoginFlowSubmitTotpResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowSubmitTotpResult : FfiConverterRustBuffer<LoginFlowSubmitTotpResult>{
    override fun read(buf: ByteBuffer): LoginFlowSubmitTotpResult {
        return when(buf.getInt()) {
            1 -> LoginFlowSubmitTotpResult.Ok
            2 -> LoginFlowSubmitTotpResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowSubmitTotpResult) = when(value) {
        is LoginFlowSubmitTotpResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LoginFlowSubmitTotpResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowSubmitTotpResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowSubmitTotpResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LoginFlowSubmitTotpResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LoginFlowUserIdResult {
    
    data class Ok(
        val v1: kotlin.String) : LoginFlowUserIdResult() {
        companion object
    }
    
    data class Error(
        val v1: LoginError) : LoginFlowUserIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLoginFlowUserIdResult : FfiConverterRustBuffer<LoginFlowUserIdResult>{
    override fun read(buf: ByteBuffer): LoginFlowUserIdResult {
        return when(buf.getInt()) {
            1 -> LoginFlowUserIdResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> LoginFlowUserIdResult.Error(
                FfiConverterTypeLoginError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LoginFlowUserIdResult) = when(value) {
        is LoginFlowUserIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is LoginFlowUserIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LoginFlowUserIdResult, buf: ByteBuffer) {
        when(value) {
            is LoginFlowUserIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LoginFlowUserIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeLoginError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * Errors that can occur during the password change flow, exposed via `UniFFI`.
 */
sealed class PasswordException: kotlin.Exception() {
    
    class Api(
        
        val v1: kotlin.String
        ) : PasswordException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Crypto(
        
        val v1: kotlin.String
        ) : PasswordException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidCredentials(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class Invalid2FaCode(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class Reused2FaCode(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class InvalidRecoveryCode(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class KeyUnlock(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class InvalidState(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class Internal(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class PasswordEmpty(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class PasswordsNotMatching(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class PasswordNotValidated(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    
    class PasswordValidationMismatch(
        ) : PasswordException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PasswordException> {
        override fun lift(error_buf: RustBuffer.ByValue): PasswordException = FfiConverterTypePasswordError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordError : FfiConverterRustBuffer<PasswordException> {
    override fun read(buf: ByteBuffer): PasswordException {
        

        return when(buf.getInt()) {
            1 -> PasswordException.Api(
                FfiConverterString.read(buf),
                )
            2 -> PasswordException.Crypto(
                FfiConverterString.read(buf),
                )
            3 -> PasswordException.InvalidCredentials()
            4 -> PasswordException.Invalid2FaCode()
            5 -> PasswordException.Reused2FaCode()
            6 -> PasswordException.InvalidRecoveryCode()
            7 -> PasswordException.KeyUnlock()
            8 -> PasswordException.InvalidState()
            9 -> PasswordException.Internal()
            10 -> PasswordException.PasswordEmpty()
            11 -> PasswordException.PasswordsNotMatching()
            12 -> PasswordException.PasswordNotValidated()
            13 -> PasswordException.PasswordValidationMismatch()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordException): ULong {
        return when(value) {
            is PasswordException.Api -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is PasswordException.Crypto -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is PasswordException.InvalidCredentials -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.Invalid2FaCode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.Reused2FaCode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.InvalidRecoveryCode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.KeyUnlock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.InvalidState -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.PasswordEmpty -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.PasswordsNotMatching -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.PasswordNotValidated -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PasswordException.PasswordValidationMismatch -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: PasswordException, buf: ByteBuffer) {
        when(value) {
            is PasswordException.Api -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is PasswordException.Crypto -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is PasswordException.InvalidCredentials -> {
                buf.putInt(3)
                Unit
            }
            is PasswordException.Invalid2FaCode -> {
                buf.putInt(4)
                Unit
            }
            is PasswordException.Reused2FaCode -> {
                buf.putInt(5)
                Unit
            }
            is PasswordException.InvalidRecoveryCode -> {
                buf.putInt(6)
                Unit
            }
            is PasswordException.KeyUnlock -> {
                buf.putInt(7)
                Unit
            }
            is PasswordException.InvalidState -> {
                buf.putInt(8)
                Unit
            }
            is PasswordException.Internal -> {
                buf.putInt(9)
                Unit
            }
            is PasswordException.PasswordEmpty -> {
                buf.putInt(10)
                Unit
            }
            is PasswordException.PasswordsNotMatching -> {
                buf.putInt(11)
                Unit
            }
            is PasswordException.PasswordNotValidated -> {
                buf.putInt(12)
                Unit
            }
            is PasswordException.PasswordValidationMismatch -> {
                buf.putInt(13)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class PasswordFlowChangeMboxPassResult {
    
    data class Ok(
        val v1: SimplePasswordState) : PasswordFlowChangeMboxPassResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowChangeMboxPassResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowChangeMboxPassResult : FfiConverterRustBuffer<PasswordFlowChangeMboxPassResult>{
    override fun read(buf: ByteBuffer): PasswordFlowChangeMboxPassResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowChangeMboxPassResult.Ok(
                FfiConverterTypeSimplePasswordState.read(buf),
                )
            2 -> PasswordFlowChangeMboxPassResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowChangeMboxPassResult) = when(value) {
        is PasswordFlowChangeMboxPassResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimplePasswordState.allocationSize(value.v1)
            )
        }
        is PasswordFlowChangeMboxPassResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowChangeMboxPassResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowChangeMboxPassResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimplePasswordState.write(value.v1, buf)
                Unit
            }
            is PasswordFlowChangeMboxPassResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowChangePassResult {
    
    data class Ok(
        val v1: SimplePasswordState) : PasswordFlowChangePassResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowChangePassResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowChangePassResult : FfiConverterRustBuffer<PasswordFlowChangePassResult>{
    override fun read(buf: ByteBuffer): PasswordFlowChangePassResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowChangePassResult.Ok(
                FfiConverterTypeSimplePasswordState.read(buf),
                )
            2 -> PasswordFlowChangePassResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowChangePassResult) = when(value) {
        is PasswordFlowChangePassResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimplePasswordState.allocationSize(value.v1)
            )
        }
        is PasswordFlowChangePassResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowChangePassResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowChangePassResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimplePasswordState.write(value.v1, buf)
                Unit
            }
            is PasswordFlowChangePassResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowFidoDetailsResult {
    
    data class Ok(
        val v1: Fido2ResponseFfi?) : PasswordFlowFidoDetailsResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowFidoDetailsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowFidoDetailsResult : FfiConverterRustBuffer<PasswordFlowFidoDetailsResult>{
    override fun read(buf: ByteBuffer): PasswordFlowFidoDetailsResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowFidoDetailsResult.Ok(
                FfiConverterOptionalTypeFido2ResponseFfi.read(buf),
                )
            2 -> PasswordFlowFidoDetailsResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowFidoDetailsResult) = when(value) {
        is PasswordFlowFidoDetailsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeFido2ResponseFfi.allocationSize(value.v1)
            )
        }
        is PasswordFlowFidoDetailsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowFidoDetailsResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowFidoDetailsResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeFido2ResponseFfi.write(value.v1, buf)
                Unit
            }
            is PasswordFlowFidoDetailsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowHasFidoResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : PasswordFlowHasFidoResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowHasFidoResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowHasFidoResult : FfiConverterRustBuffer<PasswordFlowHasFidoResult>{
    override fun read(buf: ByteBuffer): PasswordFlowHasFidoResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowHasFidoResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> PasswordFlowHasFidoResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowHasFidoResult) = when(value) {
        is PasswordFlowHasFidoResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is PasswordFlowHasFidoResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowHasFidoResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowHasFidoResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is PasswordFlowHasFidoResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowHasMbpResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : PasswordFlowHasMbpResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowHasMbpResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowHasMbpResult : FfiConverterRustBuffer<PasswordFlowHasMbpResult>{
    override fun read(buf: ByteBuffer): PasswordFlowHasMbpResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowHasMbpResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> PasswordFlowHasMbpResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowHasMbpResult) = when(value) {
        is PasswordFlowHasMbpResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is PasswordFlowHasMbpResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowHasMbpResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowHasMbpResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is PasswordFlowHasMbpResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowHasTotpResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : PasswordFlowHasTotpResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowHasTotpResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowHasTotpResult : FfiConverterRustBuffer<PasswordFlowHasTotpResult>{
    override fun read(buf: ByteBuffer): PasswordFlowHasTotpResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowHasTotpResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> PasswordFlowHasTotpResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowHasTotpResult) = when(value) {
        is PasswordFlowHasTotpResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is PasswordFlowHasTotpResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowHasTotpResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowHasTotpResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is PasswordFlowHasTotpResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowStepBackResult {
    
    data class Ok(
        val v1: SimplePasswordState) : PasswordFlowStepBackResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowStepBackResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowStepBackResult : FfiConverterRustBuffer<PasswordFlowStepBackResult>{
    override fun read(buf: ByteBuffer): PasswordFlowStepBackResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowStepBackResult.Ok(
                FfiConverterTypeSimplePasswordState.read(buf),
                )
            2 -> PasswordFlowStepBackResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowStepBackResult) = when(value) {
        is PasswordFlowStepBackResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimplePasswordState.allocationSize(value.v1)
            )
        }
        is PasswordFlowStepBackResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowStepBackResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowStepBackResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimplePasswordState.write(value.v1, buf)
                Unit
            }
            is PasswordFlowStepBackResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowSubmitFidoResult {
    
    data class Ok(
        val v1: SimplePasswordState) : PasswordFlowSubmitFidoResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowSubmitFidoResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowSubmitFidoResult : FfiConverterRustBuffer<PasswordFlowSubmitFidoResult>{
    override fun read(buf: ByteBuffer): PasswordFlowSubmitFidoResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowSubmitFidoResult.Ok(
                FfiConverterTypeSimplePasswordState.read(buf),
                )
            2 -> PasswordFlowSubmitFidoResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowSubmitFidoResult) = when(value) {
        is PasswordFlowSubmitFidoResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimplePasswordState.allocationSize(value.v1)
            )
        }
        is PasswordFlowSubmitFidoResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowSubmitFidoResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowSubmitFidoResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimplePasswordState.write(value.v1, buf)
                Unit
            }
            is PasswordFlowSubmitFidoResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PasswordFlowSubmitTotpResult {
    
    data class Ok(
        val v1: SimplePasswordState) : PasswordFlowSubmitTotpResult() {
        companion object
    }
    
    data class Error(
        val v1: PasswordException) : PasswordFlowSubmitTotpResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordFlowSubmitTotpResult : FfiConverterRustBuffer<PasswordFlowSubmitTotpResult>{
    override fun read(buf: ByteBuffer): PasswordFlowSubmitTotpResult {
        return when(buf.getInt()) {
            1 -> PasswordFlowSubmitTotpResult.Ok(
                FfiConverterTypeSimplePasswordState.read(buf),
                )
            2 -> PasswordFlowSubmitTotpResult.Error(
                FfiConverterTypePasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordFlowSubmitTotpResult) = when(value) {
        is PasswordFlowSubmitTotpResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimplePasswordState.allocationSize(value.v1)
            )
        }
        is PasswordFlowSubmitTotpResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordFlowSubmitTotpResult, buf: ByteBuffer) {
        when(value) {
            is PasswordFlowSubmitTotpResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimplePasswordState.write(value.v1, buf)
                Unit
            }
            is PasswordFlowSubmitTotpResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Represents the password mode of an account.
 *
 * Note: this is not strictly related to the auth system;
 * it is used to determine whether an account's keys are locked
 * with the primary account password or with a separate password.
 */

enum class PasswordMode {
    
    /**
     * The account has one password.
     */
    ONE,
    /**
     * The account has two passwords.
     */
    TWO;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePasswordMode: FfiConverterRustBuffer<PasswordMode> {
    override fun read(buf: ByteBuffer) = try {
        PasswordMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PasswordMode) = 4UL

    override fun write(value: PasswordMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PasswordType {
    
    /**
     * Main login password.
     */
    MAIN,
    /**
     * Secondary (mailbox) password.
     */
    SECONDARY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePasswordType: FfiConverterRustBuffer<PasswordType> {
    override fun read(buf: ByteBuffer) = try {
        PasswordType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PasswordType) = 4UL

    override fun write(value: PasswordType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class PasswordValidationException: kotlin.Exception() {
    
    class JoinException(
        
        val v1: kotlin.String
        ) : PasswordValidationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PasswordValidationException> {
        override fun lift(error_buf: RustBuffer.ByValue): PasswordValidationException = FfiConverterTypePasswordValidationError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePasswordValidationError : FfiConverterRustBuffer<PasswordValidationException> {
    override fun read(buf: ByteBuffer): PasswordValidationException {
        

        return when(buf.getInt()) {
            1 -> PasswordValidationException.JoinException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PasswordValidationException): ULong {
        return when(value) {
            is PasswordValidationException.JoinException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PasswordValidationException, buf: ByteBuffer) {
        when(value) {
            is PasswordValidationException.JoinException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class PostLoginValidationError {
    
    /**
     * Returned when login is aborted due to a delinquent user
     */
    object DelinquentUser : PostLoginValidationError()
    
    
    /**
     * Returned when login is aborted when the limit of free accounts is exceeded. Contains the max number of free accounts allowed.
     */
    data class FreeAccountLimitExceeded(
        val v1: kotlin.ULong) : PostLoginValidationError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePostLoginValidationError : FfiConverterRustBuffer<PostLoginValidationError>{
    override fun read(buf: ByteBuffer): PostLoginValidationError {
        return when(buf.getInt()) {
            1 -> PostLoginValidationError.DelinquentUser
            2 -> PostLoginValidationError.FreeAccountLimitExceeded(
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PostLoginValidationError) = when(value) {
        is PostLoginValidationError.DelinquentUser -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is PostLoginValidationError.FreeAccountLimitExceeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PostLoginValidationError, buf: ByteBuffer) {
        when(value) {
            is PostLoginValidationError.DelinquentUser -> {
                buf.putInt(1)
                Unit
            }
            is PostLoginValidationError.FreeAccountLimitExceeded -> {
                buf.putInt(2)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ProcessTargetDeviceQrError {
    
    data class ParseError(
        val v1: kotlin.String) : ProcessTargetDeviceQrError() {
        companion object
    }
    
    data class EncryptionFailed(
        val v1: kotlin.String) : ProcessTargetDeviceQrError() {
        companion object
    }
    
    data class Api(
        val v1: kotlin.String) : ProcessTargetDeviceQrError() {
        companion object
    }
    
    data class PassphraseAcquire(
        val v1: kotlin.String) : ProcessTargetDeviceQrError() {
        companion object
    }
    
    data class Other(
        val v1: kotlin.String) : ProcessTargetDeviceQrError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeProcessTargetDeviceQrError : FfiConverterRustBuffer<ProcessTargetDeviceQrError>{
    override fun read(buf: ByteBuffer): ProcessTargetDeviceQrError {
        return when(buf.getInt()) {
            1 -> ProcessTargetDeviceQrError.ParseError(
                FfiConverterString.read(buf),
                )
            2 -> ProcessTargetDeviceQrError.EncryptionFailed(
                FfiConverterString.read(buf),
                )
            3 -> ProcessTargetDeviceQrError.Api(
                FfiConverterString.read(buf),
                )
            4 -> ProcessTargetDeviceQrError.PassphraseAcquire(
                FfiConverterString.read(buf),
                )
            5 -> ProcessTargetDeviceQrError.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ProcessTargetDeviceQrError) = when(value) {
        is ProcessTargetDeviceQrError.ParseError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ProcessTargetDeviceQrError.EncryptionFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ProcessTargetDeviceQrError.Api -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ProcessTargetDeviceQrError.PassphraseAcquire -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ProcessTargetDeviceQrError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ProcessTargetDeviceQrError, buf: ByteBuffer) {
        when(value) {
            is ProcessTargetDeviceQrError.ParseError -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ProcessTargetDeviceQrError.EncryptionFailed -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ProcessTargetDeviceQrError.Api -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ProcessTargetDeviceQrError.PassphraseAcquire -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ProcessTargetDeviceQrError.Other -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class QrLoginScanScreenViewTotalScreenId {
    
    INSTRUCTIONS,
    CAMERA,
    VERIFYING,
    SUCCESS,
    FAILURE,
    CAMERA_ACCESS_NOT_ALLOWED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeQrLoginScanScreenViewTotalScreenId: FfiConverterRustBuffer<QrLoginScanScreenViewTotalScreenId> {
    override fun read(buf: ByteBuffer) = try {
        QrLoginScanScreenViewTotalScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: QrLoginScanScreenViewTotalScreenId) = 4UL

    override fun write(value: QrLoginScanScreenViewTotalScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class QrLoginShowQrCodeScreenViewTotalScreenId {
    
    INSTRUCTIONS,
    FAILURE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeQrLoginShowQrCodeScreenViewTotalScreenId: FfiConverterRustBuffer<QrLoginShowQrCodeScreenViewTotalScreenId> {
    override fun read(buf: ByteBuffer) = try {
        QrLoginShowQrCodeScreenViewTotalScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: QrLoginShowQrCodeScreenViewTotalScreenId) = 4UL

    override fun write(value: QrLoginShowQrCodeScreenViewTotalScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class QrPollingResult {
    
    STILL_POLLING,
    CONFIRMED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeQrPollingResult: FfiConverterRustBuffer<QrPollingResult> {
    override fun read(buf: ByteBuffer) = try {
        QrPollingResult.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: QrPollingResult) = 4UL

    override fun write(value: QrPollingResult, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Errors that can occur during the signup flow, exposed via `UniFFI`.
 */
sealed class SignupException: kotlin.Exception() {
    
    /**
     * An underlying API call failed. Contains the specific API error message.
     */
    class Api(
        
        val v1: kotlin.String
        ) : SignupException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    /**
     * A crypto error occurred.
     */
    class Crypto(
        
        val v1: kotlin.String
        ) : SignupException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    /**
     * Signup is blocked (e.g., anti-abuse).
     */
    class SignupBlockedByServer(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * Username is unavailable.
     */
    class UsernameUnavailable(
        
        val v1: kotlin.String?
        ) : SignupException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UsernameEmpty(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    class PasswordEmpty(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    class PasswordsNotMatching(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    class PasswordValidationMismatch(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    class PasswordNotValidated(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * Account creation step failed.
     */
    class AccountCreationFailed(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * Address setup step failed.
     */
    class AddressSetupFailed(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * Key setup step failed.
     */
    class KeySetupFailed(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * An unexpected internal error occurred.
     */
    class Internal(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * The recovery email format is invalid
     */
    class RecoveryEmailInvalid(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * The recovery phone number format is invalid
     */
    class RecoveryPhoneNumberInvalid(
        ) : SignupException() {
        override val message
            get() = ""
    }
    
    /**
     * The recovery phone number format is invalid
     */
    class PostLoginValidationException(
        
        val v1: PostLoginValidationError
        ) : SignupException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SignupException> {
        override fun lift(error_buf: RustBuffer.ByValue): SignupException = FfiConverterTypeSignupError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupError : FfiConverterRustBuffer<SignupException> {
    override fun read(buf: ByteBuffer): SignupException {
        

        return when(buf.getInt()) {
            1 -> SignupException.Api(
                FfiConverterString.read(buf),
                )
            2 -> SignupException.Crypto(
                FfiConverterString.read(buf),
                )
            3 -> SignupException.SignupBlockedByServer()
            4 -> SignupException.UsernameUnavailable(
                FfiConverterOptionalString.read(buf),
                )
            5 -> SignupException.UsernameEmpty()
            6 -> SignupException.PasswordEmpty()
            7 -> SignupException.PasswordsNotMatching()
            8 -> SignupException.PasswordValidationMismatch()
            9 -> SignupException.PasswordNotValidated()
            10 -> SignupException.AccountCreationFailed()
            11 -> SignupException.AddressSetupFailed()
            12 -> SignupException.KeySetupFailed()
            13 -> SignupException.Internal()
            14 -> SignupException.RecoveryEmailInvalid()
            15 -> SignupException.RecoveryPhoneNumberInvalid()
            16 -> SignupException.PostLoginValidationException(
                FfiConverterTypePostLoginValidationError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupException): ULong {
        return when(value) {
            is SignupException.Api -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SignupException.Crypto -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SignupException.SignupBlockedByServer -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.UsernameUnavailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterOptionalString.allocationSize(value.v1)
            )
            is SignupException.UsernameEmpty -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.PasswordEmpty -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.PasswordsNotMatching -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.PasswordValidationMismatch -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.PasswordNotValidated -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.AccountCreationFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.AddressSetupFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.KeySetupFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.RecoveryEmailInvalid -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.RecoveryPhoneNumberInvalid -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SignupException.PostLoginValidationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypePostLoginValidationError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupException, buf: ByteBuffer) {
        when(value) {
            is SignupException.Api -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SignupException.Crypto -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SignupException.SignupBlockedByServer -> {
                buf.putInt(3)
                Unit
            }
            is SignupException.UsernameUnavailable -> {
                buf.putInt(4)
                FfiConverterOptionalString.write(value.v1, buf)
                Unit
            }
            is SignupException.UsernameEmpty -> {
                buf.putInt(5)
                Unit
            }
            is SignupException.PasswordEmpty -> {
                buf.putInt(6)
                Unit
            }
            is SignupException.PasswordsNotMatching -> {
                buf.putInt(7)
                Unit
            }
            is SignupException.PasswordValidationMismatch -> {
                buf.putInt(8)
                Unit
            }
            is SignupException.PasswordNotValidated -> {
                buf.putInt(9)
                Unit
            }
            is SignupException.AccountCreationFailed -> {
                buf.putInt(10)
                Unit
            }
            is SignupException.AddressSetupFailed -> {
                buf.putInt(11)
                Unit
            }
            is SignupException.KeySetupFailed -> {
                buf.putInt(12)
                Unit
            }
            is SignupException.Internal -> {
                buf.putInt(13)
                Unit
            }
            is SignupException.RecoveryEmailInvalid -> {
                buf.putInt(14)
                Unit
            }
            is SignupException.RecoveryPhoneNumberInvalid -> {
                buf.putInt(15)
                Unit
            }
            is SignupException.PostLoginValidationException -> {
                buf.putInt(16)
                FfiConverterTypePostLoginValidationError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SignupFlowAvailableCountriesResult {
    
    data class Ok(
        val v1: Countries) : SignupFlowAvailableCountriesResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowAvailableCountriesResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowAvailableCountriesResult : FfiConverterRustBuffer<SignupFlowAvailableCountriesResult>{
    override fun read(buf: ByteBuffer): SignupFlowAvailableCountriesResult {
        return when(buf.getInt()) {
            1 -> SignupFlowAvailableCountriesResult.Ok(
                FfiConverterTypeCountries.read(buf),
                )
            2 -> SignupFlowAvailableCountriesResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowAvailableCountriesResult) = when(value) {
        is SignupFlowAvailableCountriesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCountries.allocationSize(value.v1)
            )
        }
        is SignupFlowAvailableCountriesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowAvailableCountriesResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowAvailableCountriesResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeCountries.write(value.v1, buf)
                Unit
            }
            is SignupFlowAvailableCountriesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowAvailableDomainsResult {
    
    data class Ok(
        val v1: List<kotlin.String>) : SignupFlowAvailableDomainsResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowAvailableDomainsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowAvailableDomainsResult : FfiConverterRustBuffer<SignupFlowAvailableDomainsResult>{
    override fun read(buf: ByteBuffer): SignupFlowAvailableDomainsResult {
        return when(buf.getInt()) {
            1 -> SignupFlowAvailableDomainsResult.Ok(
                FfiConverterSequenceString.read(buf),
                )
            2 -> SignupFlowAvailableDomainsResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowAvailableDomainsResult) = when(value) {
        is SignupFlowAvailableDomainsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is SignupFlowAvailableDomainsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowAvailableDomainsResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowAvailableDomainsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is SignupFlowAvailableDomainsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowCompleteResult {
    
    data class Ok(
        val v1: UserAddrId) : SignupFlowCompleteResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowCompleteResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowCompleteResult : FfiConverterRustBuffer<SignupFlowCompleteResult>{
    override fun read(buf: ByteBuffer): SignupFlowCompleteResult {
        return when(buf.getInt()) {
            1 -> SignupFlowCompleteResult.Ok(
                FfiConverterTypeUserAddrId.read(buf),
                )
            2 -> SignupFlowCompleteResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowCompleteResult) = when(value) {
        is SignupFlowCompleteResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserAddrId.allocationSize(value.v1)
            )
        }
        is SignupFlowCompleteResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowCompleteResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowCompleteResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeUserAddrId.write(value.v1, buf)
                Unit
            }
            is SignupFlowCompleteResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowCreateResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowCreateResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowCreateResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowCreateResult : FfiConverterRustBuffer<SignupFlowCreateResult>{
    override fun read(buf: ByteBuffer): SignupFlowCreateResult {
        return when(buf.getInt()) {
            1 -> SignupFlowCreateResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowCreateResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowCreateResult) = when(value) {
        is SignupFlowCreateResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowCreateResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowCreateResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowCreateResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowCreateResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSkipRecoveryResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSkipRecoveryResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSkipRecoveryResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSkipRecoveryResult : FfiConverterRustBuffer<SignupFlowSkipRecoveryResult>{
    override fun read(buf: ByteBuffer): SignupFlowSkipRecoveryResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSkipRecoveryResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSkipRecoveryResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSkipRecoveryResult) = when(value) {
        is SignupFlowSkipRecoveryResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSkipRecoveryResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSkipRecoveryResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSkipRecoveryResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSkipRecoveryResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowStepBackResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowStepBackResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowStepBackResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowStepBackResult : FfiConverterRustBuffer<SignupFlowStepBackResult>{
    override fun read(buf: ByteBuffer): SignupFlowStepBackResult {
        return when(buf.getInt()) {
            1 -> SignupFlowStepBackResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowStepBackResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowStepBackResult) = when(value) {
        is SignupFlowStepBackResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowStepBackResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowStepBackResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowStepBackResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowStepBackResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSubmitExternalUsernameResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSubmitExternalUsernameResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSubmitExternalUsernameResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSubmitExternalUsernameResult : FfiConverterRustBuffer<SignupFlowSubmitExternalUsernameResult>{
    override fun read(buf: ByteBuffer): SignupFlowSubmitExternalUsernameResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSubmitExternalUsernameResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSubmitExternalUsernameResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSubmitExternalUsernameResult) = when(value) {
        is SignupFlowSubmitExternalUsernameResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSubmitExternalUsernameResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSubmitExternalUsernameResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSubmitExternalUsernameResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSubmitExternalUsernameResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSubmitInternalUsernameResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSubmitInternalUsernameResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSubmitInternalUsernameResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSubmitInternalUsernameResult : FfiConverterRustBuffer<SignupFlowSubmitInternalUsernameResult>{
    override fun read(buf: ByteBuffer): SignupFlowSubmitInternalUsernameResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSubmitInternalUsernameResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSubmitInternalUsernameResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSubmitInternalUsernameResult) = when(value) {
        is SignupFlowSubmitInternalUsernameResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSubmitInternalUsernameResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSubmitInternalUsernameResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSubmitInternalUsernameResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSubmitInternalUsernameResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSubmitPasswordResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSubmitPasswordResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSubmitPasswordResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSubmitPasswordResult : FfiConverterRustBuffer<SignupFlowSubmitPasswordResult>{
    override fun read(buf: ByteBuffer): SignupFlowSubmitPasswordResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSubmitPasswordResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSubmitPasswordResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSubmitPasswordResult) = when(value) {
        is SignupFlowSubmitPasswordResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSubmitPasswordResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSubmitPasswordResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSubmitPasswordResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSubmitPasswordResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSubmitRecoveryEmailResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSubmitRecoveryEmailResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSubmitRecoveryEmailResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSubmitRecoveryEmailResult : FfiConverterRustBuffer<SignupFlowSubmitRecoveryEmailResult>{
    override fun read(buf: ByteBuffer): SignupFlowSubmitRecoveryEmailResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSubmitRecoveryEmailResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSubmitRecoveryEmailResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSubmitRecoveryEmailResult) = when(value) {
        is SignupFlowSubmitRecoveryEmailResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSubmitRecoveryEmailResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSubmitRecoveryEmailResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSubmitRecoveryEmailResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSubmitRecoveryEmailResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignupFlowSubmitRecoveryPhoneResult {
    
    data class Ok(
        val v1: SimpleSignupState) : SignupFlowSubmitRecoveryPhoneResult() {
        companion object
    }
    
    data class Error(
        val v1: SignupException) : SignupFlowSubmitRecoveryPhoneResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignupFlowSubmitRecoveryPhoneResult : FfiConverterRustBuffer<SignupFlowSubmitRecoveryPhoneResult>{
    override fun read(buf: ByteBuffer): SignupFlowSubmitRecoveryPhoneResult {
        return when(buf.getInt()) {
            1 -> SignupFlowSubmitRecoveryPhoneResult.Ok(
                FfiConverterTypeSimpleSignupState.read(buf),
                )
            2 -> SignupFlowSubmitRecoveryPhoneResult.Error(
                FfiConverterTypeSignupError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignupFlowSubmitRecoveryPhoneResult) = when(value) {
        is SignupFlowSubmitRecoveryPhoneResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSimpleSignupState.allocationSize(value.v1)
            )
        }
        is SignupFlowSubmitRecoveryPhoneResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignupFlowSubmitRecoveryPhoneResult, buf: ByteBuffer) {
        when(value) {
            is SignupFlowSubmitRecoveryPhoneResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSimpleSignupState.write(value.v1, buf)
                Unit
            }
            is SignupFlowSubmitRecoveryPhoneResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSignupError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Simplified password flow state for FFI bindings.
 *
 * This enum represents the different states of the password change flow
 * in a simplified form suitable for foreign function interface bindings.
 */

enum class SimplePasswordState {
    
    /**
     * Waiting for the user's current password.
     */
    WANT_PASS,
    /**
     * Waiting for two-factor authentication code.
     */
    WANT_TFA,
    /**
     * Waiting for the new password to be set.
     */
    WANT_CHANGE,
    /**
     * Password change flow completed successfully.
     */
    COMPLETE,
    /**
     * Invalid or error state.
     */
    INVALID;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSimplePasswordState: FfiConverterRustBuffer<SimplePasswordState> {
    override fun read(buf: ByteBuffer) = try {
        SimplePasswordState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SimplePasswordState) = 4UL

    override fun write(value: SimplePasswordState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SimpleSignupState {
    
    WANT_USERNAME,
    WANT_PASSWORD,
    WANT_RECOVERY,
    WANT_CREATE,
    COMPLETE,
    INVALID;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSimpleSignupState: FfiConverterRustBuffer<SimpleSignupState> {
    override fun read(buf: ByteBuffer) = try {
        SimpleSignupState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SimpleSignupState) = 4UL

    override fun write(value: SimpleSignupState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







public interface PasswordValidatorServiceCallback {
    
    /**
     * Called when the validation has been performed.
     * May be called multiple times.
     * * `results` - A list of validation results.
     * * `token` - If present, the validation was successful.
     */
    fun `onResults`(`results`: List<PasswordValidatorServiceResult>, `token`: PasswordValidatorServiceToken?)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePasswordValidatorServiceCallback {
    internal object `onResults`: UniffiCallbackInterfacePasswordValidatorServiceCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`results`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePasswordValidatorServiceCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onResults`(
                    FfiConverterSequenceTypePasswordValidatorServiceResult.lift(`results`),
                    FfiConverterOptionalTypePasswordValidatorServiceToken.lift(`token`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePasswordValidatorServiceCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePasswordValidatorServiceCallback.UniffiByValue(
        `onResults`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_account_uniffi_fn_init_callback_vtable_passwordvalidatorservicecallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypePasswordValidatorServiceCallback: FfiConverterCallbackInterface<PasswordValidatorServiceCallback>()




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalBoolean: FfiConverterRustBuffer<kotlin.Boolean?> {
    override fun read(buf: ByteBuffer): kotlin.Boolean? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterBoolean.read(buf)
    }

    override fun allocationSize(value: kotlin.Boolean?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterBoolean.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Boolean?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterBoolean.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePasswordValidatorService: FfiConverterRustBuffer<PasswordValidatorService?> {
    override fun read(buf: ByteBuffer): PasswordValidatorService? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePasswordValidatorService.read(buf)
    }

    override fun allocationSize(value: PasswordValidatorService?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePasswordValidatorService.allocationSize(value)
        }
    }

    override fun write(value: PasswordValidatorService?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePasswordValidatorService.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePasswordValidatorServiceToken: FfiConverterRustBuffer<PasswordValidatorServiceToken?> {
    override fun read(buf: ByteBuffer): PasswordValidatorServiceToken? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePasswordValidatorServiceToken.read(buf)
    }

    override fun allocationSize(value: PasswordValidatorServiceToken?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePasswordValidatorServiceToken.allocationSize(value)
        }
    }

    override fun write(value: PasswordValidatorServiceToken?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePasswordValidatorServiceToken.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeCountry: FfiConverterRustBuffer<Country?> {
    override fun read(buf: ByteBuffer): Country? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCountry.read(buf)
    }

    override fun allocationSize(value: Country?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeCountry.allocationSize(value)
        }
    }

    override fun write(value: Country?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCountry.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFido2AuthenticationExtensionsClientInputsFfi: FfiConverterRustBuffer<Fido2AuthenticationExtensionsClientInputsFfi?> {
    override fun read(buf: ByteBuffer): Fido2AuthenticationExtensionsClientInputsFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFido2AuthenticationExtensionsClientInputsFfi.read(buf)
    }

    override fun allocationSize(value: Fido2AuthenticationExtensionsClientInputsFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFido2AuthenticationExtensionsClientInputsFfi.allocationSize(value)
        }
    }

    override fun write(value: Fido2AuthenticationExtensionsClientInputsFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFido2AuthenticationExtensionsClientInputsFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFido2AuthenticationOptionsFfi: FfiConverterRustBuffer<Fido2AuthenticationOptionsFfi?> {
    override fun read(buf: ByteBuffer): Fido2AuthenticationOptionsFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFido2AuthenticationOptionsFfi.read(buf)
    }

    override fun allocationSize(value: Fido2AuthenticationOptionsFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFido2AuthenticationOptionsFfi.allocationSize(value)
        }
    }

    override fun write(value: Fido2AuthenticationOptionsFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFido2AuthenticationOptionsFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFido2ResponseFfi: FfiConverterRustBuffer<Fido2ResponseFfi?> {
    override fun read(buf: ByteBuffer): Fido2ResponseFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFido2ResponseFfi.read(buf)
    }

    override fun allocationSize(value: Fido2ResponseFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFido2ResponseFfi.allocationSize(value)
        }
    }

    override fun write(value: Fido2ResponseFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFido2ResponseFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUserBehavior: FfiConverterRustBuffer<UserBehavior?> {
    override fun read(buf: ByteBuffer): UserBehavior? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUserBehavior.read(buf)
    }

    override fun allocationSize(value: UserBehavior?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUserBehavior.allocationSize(value)
        }
    }

    override fun write(value: UserBehavior?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUserBehavior.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<kotlin.String>?> {
    override fun read(buf: ByteBuffer): List<kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeFido2PublicKeyCredentialDescriptorFfi: FfiConverterRustBuffer<List<Fido2PublicKeyCredentialDescriptorFfi>?> {
    override fun read(buf: ByteBuffer): List<Fido2PublicKeyCredentialDescriptorFfi>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeFido2PublicKeyCredentialDescriptorFfi.read(buf)
    }

    override fun allocationSize(value: List<Fido2PublicKeyCredentialDescriptorFfi>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeFido2PublicKeyCredentialDescriptorFfi.allocationSize(value)
        }
    }

    override fun write(value: List<Fido2PublicKeyCredentialDescriptorFfi>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeFido2PublicKeyCredentialDescriptorFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceUInt: FfiConverterRustBuffer<List<kotlin.UInt>> {
    override fun read(buf: ByteBuffer): List<kotlin.UInt> {
        val len = buf.getInt()
        return List<kotlin.UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UInt>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCountry: FfiConverterRustBuffer<List<Country>> {
    override fun read(buf: ByteBuffer): List<Country> {
        val len = buf.getInt()
        return List<Country>(len) {
            FfiConverterTypeCountry.read(buf)
        }
    }

    override fun allocationSize(value: List<Country>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCountry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Country>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCountry.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFido2PublicKeyCredentialDescriptorFfi: FfiConverterRustBuffer<List<Fido2PublicKeyCredentialDescriptorFfi>> {
    override fun read(buf: ByteBuffer): List<Fido2PublicKeyCredentialDescriptorFfi> {
        val len = buf.getInt()
        return List<Fido2PublicKeyCredentialDescriptorFfi>(len) {
            FfiConverterTypeFido2PublicKeyCredentialDescriptorFfi.read(buf)
        }
    }

    override fun allocationSize(value: List<Fido2PublicKeyCredentialDescriptorFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFido2PublicKeyCredentialDescriptorFfi.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Fido2PublicKeyCredentialDescriptorFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFido2PublicKeyCredentialDescriptorFfi.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePasswordValidatorServiceResult: FfiConverterRustBuffer<List<PasswordValidatorServiceResult>> {
    override fun read(buf: ByteBuffer): List<PasswordValidatorServiceResult> {
        val len = buf.getInt()
        return List<PasswordValidatorServiceResult>(len) {
            FfiConverterTypePasswordValidatorServiceResult.read(buf)
        }
    }

    override fun allocationSize(value: List<PasswordValidatorServiceResult>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePasswordValidatorServiceResult.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PasswordValidatorServiceResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePasswordValidatorServiceResult.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRegisteredKeyFfi: FfiConverterRustBuffer<List<RegisteredKeyFfi>> {
    override fun read(buf: ByteBuffer): List<RegisteredKeyFfi> {
        val len = buf.getInt()
        return List<RegisteredKeyFfi>(len) {
            FfiConverterTypeRegisteredKeyFfi.read(buf)
        }
    }

    override fun allocationSize(value: List<RegisteredKeyFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRegisteredKeyFfi.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RegisteredKeyFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRegisteredKeyFfi.write(it, buf)
        }
    }
}









 fun `qrLoginScanScreenTotal`(`screenId`: QrLoginScanScreenViewTotalScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_func_qr_login_scan_screen_total(
        FfiConverterTypeQrLoginScanScreenViewTotalScreenId.lower(`screenId`),_status)
}
    
    
 fun `qrLoginShowQrScreenTotal`(`screenId`: QrLoginShowQrCodeScreenViewTotalScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_func_qr_login_show_qr_screen_total(
        FfiConverterTypeQrLoginShowQrCodeScreenViewTotalScreenId.lower(`screenId`),_status)
}
    
    
 fun `recordChangePasswordScreenView`(`screenId`: ChangePasswordScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_account_uniffi_fn_func_record_change_password_screen_view(
        FfiConverterTypeChangePasswordScreenId.lower(`screenId`),_status)
}
    
    


