// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.proton_mail_uniffi

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import android.os.Build
import androidx.annotation.RequiresApi
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import uniffi.proton_account_uniffi.FfiConverterTypeLoginFlow
import uniffi.proton_account_uniffi.FfiConverterTypePasswordFlow
import uniffi.proton_account_uniffi.FfiConverterTypePasswordValidatorService
import uniffi.proton_account_uniffi.FfiConverterTypeProcessTargetDeviceQrError
import uniffi.proton_account_uniffi.FfiConverterTypeSignupFlow
import uniffi.proton_account_uniffi.LoginFlow
import uniffi.proton_account_uniffi.PasswordFlow
import uniffi.proton_account_uniffi.PasswordValidatorService
import uniffi.proton_account_uniffi.ProcessTargetDeviceQrError
import uniffi.proton_account_uniffi.SignupFlow
import uniffi.proton_issue_reporter_service_uniffi.FfiConverterTypeIssueReporter
import uniffi.proton_issue_reporter_service_uniffi.IssueReporter
import uniffi.uniffi_common.FfiConverterTypeUserApiServiceError
import uniffi.uniffi_common.UserApiServiceError
import uniffi.proton_account_uniffi.RustBuffer as RustBufferLoginFlow
import uniffi.proton_account_uniffi.RustBuffer as RustBufferPasswordFlow
import uniffi.proton_account_uniffi.RustBuffer as RustBufferPasswordValidatorService
import uniffi.proton_account_uniffi.RustBuffer as RustBufferProcessTargetDeviceQrError
import uniffi.proton_account_uniffi.RustBuffer as RustBufferSignupFlow
import uniffi.proton_issue_reporter_service_uniffi.RustBuffer as RustBufferIssueReporter
import uniffi.uniffi_common.RustBuffer as RustBufferUserApiServiceError

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "proton_mail_uniffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceContactsLiveQueryCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`contacts`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceConversationScrollerLiveQueryCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLiveQueryCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceMailboxBackgroundResultMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`error`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceMessageScrollerLiveQueryCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceOsKeyChainMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceOsKeyChainMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceOsKeyChainMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceAsyncLiveQueryCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceBackgroundExecutionCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`result`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceChallengeNotifierMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`server`: Pointer,`payload`: Pointer,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceComposerRecipientValidationCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceDeviceInfoProviderMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceDraftSendResultCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`details`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceEventLoopErrorObserverMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`error`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceExecuteWhenOnlineCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceExecuteWhenOnlineCallbackAsyncMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
internal interface UniffiCallbackInterfaceResolverMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`host`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,)
}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceContactsLiveQueryCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceContactsLiveQueryCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceContactsLiveQueryCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceContactsLiveQueryCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceContactsLiveQueryCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceConversationScrollerLiveQueryCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceConversationScrollerLiveQueryCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceConversationScrollerLiveQueryCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceConversationScrollerLiveQueryCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceConversationScrollerLiveQueryCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceLiveQueryCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceLiveQueryCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceLiveQueryCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceLiveQueryCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceLiveQueryCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onBackgroundResult", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceMailboxBackgroundResult(
    @JvmField internal var `onBackgroundResult`: UniffiCallbackInterfaceMailboxBackgroundResultMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onBackgroundResult`: UniffiCallbackInterfaceMailboxBackgroundResultMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceMailboxBackgroundResult(`onBackgroundResult`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceMailboxBackgroundResult) {
        `onBackgroundResult` = other.`onBackgroundResult`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceMessageScrollerLiveQueryCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceMessageScrollerLiveQueryCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceMessageScrollerLiveQueryCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceMessageScrollerLiveQueryCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceMessageScrollerLiveQueryCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("store", "delete", "load", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceOsKeyChain(
    @JvmField internal var `store`: UniffiCallbackInterfaceOsKeyChainMethod0? = null,
    @JvmField internal var `delete`: UniffiCallbackInterfaceOsKeyChainMethod1? = null,
    @JvmField internal var `load`: UniffiCallbackInterfaceOsKeyChainMethod2? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `store`: UniffiCallbackInterfaceOsKeyChainMethod0? = null,
        `delete`: UniffiCallbackInterfaceOsKeyChainMethod1? = null,
        `load`: UniffiCallbackInterfaceOsKeyChainMethod2? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceOsKeyChain(`store`,`delete`,`load`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceOsKeyChain) {
        `store` = other.`store`
        `delete` = other.`delete`
        `load` = other.`load`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceAsyncLiveQueryCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceAsyncLiveQueryCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceAsyncLiveQueryCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceAsyncLiveQueryCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceAsyncLiveQueryCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onExecutionCompleted", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceBackgroundExecutionCallback(
    @JvmField internal var `onExecutionCompleted`: UniffiCallbackInterfaceBackgroundExecutionCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onExecutionCompleted`: UniffiCallbackInterfaceBackgroundExecutionCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceBackgroundExecutionCallback(`onExecutionCompleted`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceBackgroundExecutionCallback) {
        `onExecutionCompleted` = other.`onExecutionCompleted`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onChallenge", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceChallengeNotifier(
    @JvmField internal var `onChallenge`: UniffiCallbackInterfaceChallengeNotifierMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onChallenge`: UniffiCallbackInterfaceChallengeNotifierMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceChallengeNotifier(`onChallenge`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceChallengeNotifier) {
        `onChallenge` = other.`onChallenge`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceComposerRecipientValidationCallback(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceComposerRecipientValidationCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceComposerRecipientValidationCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceComposerRecipientValidationCallback(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceComposerRecipientValidationCallback) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("getDeviceInfo", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceDeviceInfoProvider(
    @JvmField internal var `getDeviceInfo`: UniffiCallbackInterfaceDeviceInfoProviderMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `getDeviceInfo`: UniffiCallbackInterfaceDeviceInfoProviderMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceDeviceInfoProvider(`getDeviceInfo`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceDeviceInfoProvider) {
        `getDeviceInfo` = other.`getDeviceInfo`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onNewSendResult", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceDraftSendResultCallback(
    @JvmField internal var `onNewSendResult`: UniffiCallbackInterfaceDraftSendResultCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onNewSendResult`: UniffiCallbackInterfaceDraftSendResultCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceDraftSendResultCallback(`onNewSendResult`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceDraftSendResultCallback) {
        `onNewSendResult` = other.`onNewSendResult`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onEventLoopError", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceEventLoopErrorObserver(
    @JvmField internal var `onEventLoopError`: UniffiCallbackInterfaceEventLoopErrorObserverMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onEventLoopError`: UniffiCallbackInterfaceEventLoopErrorObserverMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceEventLoopErrorObserver(`onEventLoopError`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceEventLoopErrorObserver) {
        `onEventLoopError` = other.`onEventLoopError`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onOnline", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceExecuteWhenOnlineCallback(
    @JvmField internal var `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceExecuteWhenOnlineCallback(`onOnline`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceExecuteWhenOnlineCallback) {
        `onOnline` = other.`onOnline`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onOnline", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceExecuteWhenOnlineCallbackAsync(
    @JvmField internal var `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackAsyncMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackAsyncMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceExecuteWhenOnlineCallbackAsync(`onOnline`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceExecuteWhenOnlineCallbackAsync) {
        `onOnline` = other.`onOnline`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("resolve", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceResolver(
    @JvmField internal var `resolve`: UniffiCallbackInterfaceResolverMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `resolve`: UniffiCallbackInterfaceResolverMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceResolver(`resolve`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceResolver) {
        `resolve` = other.`resolve`
        `uniffiFree` = other.`uniffiFree`
    }

}
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_proton_mail_uniffi_checksum_func_all_available_conversation_actions_for_action_sheet(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_all_available_conversation_actions_for_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_all_available_list_actions_for_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_all_available_list_actions_for_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_all_available_message_actions_for_action_sheet(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_all_available_message_actions_for_message(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_assigned_swipe_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_available_label_as_actions_for_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_available_label_as_actions_for_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_available_move_to_actions_for_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_available_move_to_actions_for_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_available_snooze_actions_for_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_recipient(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_recipients(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_sender(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_senders(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_block_address(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_bulk_message_unread_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_contact_group_by_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_contact_list(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_contact_suggestions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_create_mail_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_custom_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_decrypt_push_notification(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_delete_all_messages_in_label(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_delete_contact(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_delete_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_delete_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_cancel_schedule_send(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_discard(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_send_result_delete(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_send_result_mark_seen(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_send_result_unseen(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_draft_undo_send(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_generate_csp_nonce(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_conversation_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_list_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_message_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_auto_delete_banner(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_contact_details(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_message_body(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_mobile_conversation_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_mobile_list_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_mobile_message_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_get_privacy_info_for_message(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_ios_share_ext_init_draft(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_ios_share_ext_save_draft(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_is_message_sender_blocked(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_is_valid_email_address(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_label_conversations_as(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_label_messages_as(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mail_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mail_settings_sync(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_make_me_crash(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mark_conversations_as_read(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mark_conversations_as_unread(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mark_messages_ham(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mark_messages_read(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_mark_messages_unread(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_message(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_move_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_move_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_all_mail_mailbox(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_challenge_loader(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_draft(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_draft_send_watcher(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_inbox_mailbox(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_mailbox(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_new_recipient(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_open_draft(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_account_recovery_screen_view(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_drive_spotlight_cta_button_tapped(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_drive_spotlight_mailbox_button_tapped(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_fido_launch_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_fido_sign_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_human_verification_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_human_verification_screen_view(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_human_verification_view_loading_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_login_screen_view(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_signup_screen_view(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_upgrade_attempt(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_upgrade_cancelled_by_user(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_upgrade_error(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_upgrade_success(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_record_upsell_button_tapped(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_report_an_issue(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_report_phishing(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_resolve_message_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_resolve_system_label_by_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_resolve_system_label_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_log_debug(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_log_error(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_log_info(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_log_trace(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_log_warn(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_major(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_minor(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_patch(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_sanitize_pasted_content(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_scroll_conversations_for_label(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_scroll_messages_for_label(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_scroller_search(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_send_payment_observability_metric(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_snooze_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_star_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_star_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_unblock_address(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_unsnooze_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_unstar_conversations(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_unstar_messages(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_update_mobile_conversation_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_update_mobile_list_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_update_mobile_message_toolbar_actions(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_update_next_message_on_move(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_watch_contact_list(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_watch_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_watch_mail_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_watch_message(
): Short
fun uniffi_proton_mail_uniffi_checksum_func_watch_privacy_info_stream(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_asynclivequerycallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_add(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_add_inline(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_attachment_upload_directory(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_attachments(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_remove(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_remove_with_cid(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_retry(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_swap_attachment_disposition(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_watcher(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_attachmentlist_watcher_stream(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_backgroundexecutioncallback_on_execution_completed(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_backgroundexecutionhandle_abort(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeloader_get(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeloader_post(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeloader_put(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengenotifier_on_challenge(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_base(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_description(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_expires_at(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_methods(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_path(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_query(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengepayload_token(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_doh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_original_host(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_path(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_port(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_resolved_host(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_challengeserver_scheme(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_add_group_recipient(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_add_single_recipient(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_recipients(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_group(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_recipient_from_group(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_single_recipient(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_set_callback(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_composerrecipientvalidationcallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_contactsuggestions_all(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_contactsuggestions_filtered(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_change_filter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_change_include(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_cursor(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_fetch_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_fetch_new(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_force_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_get_items(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_handle(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_has_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_supports_include_filter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_terminate(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscroller_total(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_customsettings_mobile_signature(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_customsettings_set_mobile_signature(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_customsettings_set_mobile_signature_enabled(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_customsettings_set_swipe_to_adjacent_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_customsettings_swipe_to_adjacent_conversation(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_attachments(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_body(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_failed_to_decrypt(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_get_pgp_subject(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_identify_rsvp(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_load_image(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_mime_type(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_parsed_header_value(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_privacy_lock(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_raw_body(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_raw_headers(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_unsubscribe_from_newsletter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_deviceinfoprovider_get_device_info(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_address_validation_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_attachment_list(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_bcc_recipients(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_body(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_cc_recipients(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_change_sender_address(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_clear_address_validation_error(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_composer_content(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_discard(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_expiration_time(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_get_password(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_is_password_protected(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_list_sender_addresses(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_load_image(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_load_image_sync(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_message_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_mime_type(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_remove_password(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_save(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_schedule(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_schedule_send_options(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_send(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_send_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_sender(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_set_body(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_set_expiration_time(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_set_password(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_set_subject(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_subject(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_to_recipients(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draft_validate_recipients_expiration_feature(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draftattachmentlistupdatestream_cancel(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draftattachmentlistupdatestream_next_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draftattachmentwatcher_disconnect(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draftsendresultcallback_on_new_send_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_draftsendresultwatcher_disconnect(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_eventlooperrorobserver_on_event_loop_error(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_eventlooperrorobserverhandle_disconnect(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_executewhenonlinecallback_on_online(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_executewhenonlinecallbackasync_on_online(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_fetch_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_goto_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_goto_prev(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_peek_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_peek_prev(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_fetch_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_goto_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_goto_prev(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_peek_next(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_peek_prev(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_app_protection(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_biometrics_check_passed(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_change_app_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_delete_account(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_delete_pin_code(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_execute_notification_quick_action(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_export_logs(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_sessions(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_state(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_state_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_accounts(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_accounts_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_app_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_primary_account(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_primary_account_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_state(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_state_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_sessions(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_get_sessions_blocking(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_initialized_user_session_from_stored_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_is_feature_enabled(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_logout_account(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_new_login_flow(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_new_signup_flow(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_on_enter_foreground(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_on_exit_foreground(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_register_device_task(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_remaining_pin_attempts(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_resume_login_flow(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_set_biometrics_app_protection(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_set_pin_code(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_set_primary_account(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_should_auto_lock(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_sign_out_all(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_start_auto_lock_countdown(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_start_background_execution(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_start_background_execution_with_duration(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_to_primary_user_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_to_user_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_unset_biometrics_app_protection(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_update_os_network_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_user_session_from_stored_session(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_verify_pin_code(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_account_sessions(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_accounts(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_accounts_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_feature_flags(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_feature_flags_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_sessions(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_sessions_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_account_details(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_applicable_labels(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_connection_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_execute_when_online(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_execute_when_online_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_force_event_loop_poll(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_force_event_loop_poll_and_wait(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_fork(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_attachment(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payment_method(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_plans(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_resources_icons(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_subscription(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_has_valid_sender_address(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_image_for_sender(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_is_feature_enabled(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_logout(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_movable_folders(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_new_password_change_flow(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_observe_event_loop_errors(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_override_user_feature_flag(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_password_validator(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_post_payments_subscription(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_post_payments_tokens(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_process_target_device_qr_code(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_session_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_session_uuid(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_upsell_eligibility(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_user(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_user_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_user_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_addresses(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_feature_flags_stream(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_upsell_eligibility(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user_settings(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user_stream(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_get_attachment(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_label_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_recipient_display_mode(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_unread_count(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_view_mode(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailbox_watch_unread_count(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_change_filter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_change_include(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_cursor(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_fetch_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_fetch_new(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_force_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_get_items(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_handle(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_has_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_supports_include_filter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_terminate(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescroller_total(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_registerdevicetaskhandle_update_device(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_resolver_resolve(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_rsvpeventservice_answer(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_rsvpeventservice_get(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_rsvpeventserviceprovider_event_service(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_change_include(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_change_keywords(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_cursor(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_fetch_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_force_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_get_items(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_handle(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_has_more(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_refresh(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_supports_include_filter(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_terminate(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_searchscroller_total(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_all_custom_folders(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_collapse_folder(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_custom_folders(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_custom_labels(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_expand_folder(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_system_labels(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_sidebar_watch_labels(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_error_info(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_signature_creation_time(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_signature_key_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_verification_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_details(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_primary_seq(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_second_factor_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_second_password_status(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_state(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedaccount_user_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedsession_session_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedsession_state(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_storedsession_user_id(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_undo_undo(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchhandle_disconnect(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_cancel(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_initial_info(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_next_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchuserfeatureflagsstream_cancel(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchuserfeatureflagsstream_next_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchuserstream_cancel(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_watchuserstream_next_async(
): Short
fun uniffi_proton_mail_uniffi_checksum_constructor_sidebar_new(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_contactslivequerycallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_conversationscrollerlivequerycallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_livequerycallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_mailboxbackgroundresult_on_background_result(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_messagescrollerlivequerycallback_on_update(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_oskeychain_store(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_oskeychain_delete(
): Short
fun uniffi_proton_mail_uniffi_checksum_method_oskeychain_load(
): Short
fun ffi_proton_mail_uniffi_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "proton_mail_uniffi"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            uniffiCallbackInterfaceAsyncLiveQueryCallback.register(lib)
            uniffiCallbackInterfaceBackgroundExecutionCallback.register(lib)
            uniffiCallbackInterfaceChallengeNotifier.register(lib)
            uniffiCallbackInterfaceComposerRecipientValidationCallback.register(lib)
            uniffiCallbackInterfaceDeviceInfoProvider.register(lib)
            uniffiCallbackInterfaceDraftSendResultCallback.register(lib)
            uniffiCallbackInterfaceEventLoopErrorObserver.register(lib)
            uniffiCallbackInterfaceExecuteWhenOnlineCallback.register(lib)
            uniffiCallbackInterfaceExecuteWhenOnlineCallbackAsync.register(lib)
            uniffiCallbackInterfaceResolver.register(lib)
            uniffiCallbackInterfaceContactsLiveQueryCallback.register(lib)
            uniffiCallbackInterfaceConversationScrollerLiveQueryCallback.register(lib)
            uniffiCallbackInterfaceLiveQueryCallback.register(lib)
            uniffiCallbackInterfaceMailboxBackgroundResult.register(lib)
            uniffiCallbackInterfaceMessageScrollerLiveQueryCallback.register(lib)
            uniffiCallbackInterfaceOSKeyChain.register(lib)
            uniffi.proton_account_uniffi.uniffiEnsureInitialized()
            uniffi.proton_issue_reporter_service_uniffi.uniffiEnsureInitialized()
            uniffi.uniffi_common.uniffiEnsureInitialized()
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_proton_mail_uniffi_fn_clone_asynclivequerycallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_asynclivequerycallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_asynclivequerycallback(`vtable`: UniffiVTableCallbackInterfaceAsyncLiveQueryCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_asynclivequerycallback_on_update(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_attachmentlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_attachmentlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_add(`ptr`: Pointer,`path`: RustBuffer.ByValue,`filenameOverride`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_add_inline(`ptr`: Pointer,`path`: RustBuffer.ByValue,`filenameOverride`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_attachment_upload_directory(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_attachments(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_remove(`ptr`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_remove_with_cid(`ptr`: Pointer,`contentId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_retry(`ptr`: Pointer,`attachmentId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_swap_attachment_disposition(`ptr`: Pointer,`contentId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_watcher(`ptr`: Pointer,`callback`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_attachmentlist_watcher_stream(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_backgroundexecutioncallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_backgroundexecutioncallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_backgroundexecutioncallback(`vtable`: UniffiVTableCallbackInterfaceBackgroundExecutionCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_backgroundexecutioncallback_on_execution_completed(`ptr`: Pointer,`result`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_backgroundexecutionhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_backgroundexecutionhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_backgroundexecutionhandle_abort(`ptr`: Pointer,`inForeground`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_challengeloader(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_challengeloader(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_challengeloader_get(`ptr`: Pointer,`base`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,`query`: RustBuffer.ByValue,`header`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_challengeloader_post(`ptr`: Pointer,`base`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,`query`: RustBuffer.ByValue,`header`: RustBuffer.ByValue,`body`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_challengeloader_put(`ptr`: Pointer,`base`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,`query`: RustBuffer.ByValue,`header`: RustBuffer.ByValue,`body`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_challengenotifier(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_challengenotifier(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_challengenotifier(`vtable`: UniffiVTableCallbackInterfaceChallengeNotifier,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_challengenotifier_on_challenge(`ptr`: Pointer,`server`: Pointer,`payload`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_challengepayload(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_challengepayload(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_base(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_description(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_expires_at(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_methods(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_path(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_query(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengepayload_token(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_challengeserver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_challengeserver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_doh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_original_host(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_path(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_port(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_resolved_host(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_challengeserver_scheme(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_composerrecipientlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_composerrecipientlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_add_group_recipient(`ptr`: Pointer,`groupName`: RustBuffer.ByValue,`recipients`: RustBuffer.ByValue,`totalContactsInGroup`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_add_single_recipient(`ptr`: Pointer,`recipient`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_recipients(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_group(`ptr`: Pointer,`groupName`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_recipient_from_group(`ptr`: Pointer,`groupName`: RustBuffer.ByValue,`email`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_single_recipient(`ptr`: Pointer,`email`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_set_callback(`ptr`: Pointer,`cb`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_composerrecipientvalidationcallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_composerrecipientvalidationcallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_composerrecipientvalidationcallback(`vtable`: UniffiVTableCallbackInterfaceComposerRecipientValidationCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_composerrecipientvalidationcallback_on_update(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_contactsuggestions(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_contactsuggestions(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_contactsuggestions_all(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_contactsuggestions_filtered(`ptr`: Pointer,`query`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_conversationscroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_conversationscroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_change_filter(`ptr`: Pointer,`unread`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_change_include(`ptr`: Pointer,`include`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_cursor(`ptr`: Pointer,`lookingAt`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_fetch_more(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_fetch_new(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_force_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_get_items(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_handle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_has_more(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_supports_include_filter(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_terminate(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_conversationscroller_total(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_customsettings(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_customsettings(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_customsettings_mobile_signature(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_customsettings_set_mobile_signature(`ptr`: Pointer,`signature`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_customsettings_set_mobile_signature_enabled(`ptr`: Pointer,`enabled`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_method_customsettings_set_swipe_to_adjacent_conversation(`ptr`: Pointer,`enabled`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_method_customsettings_swipe_to_adjacent_conversation(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_decryptedmessage(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_decryptedmessage(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_attachments(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_body(`ptr`: Pointer,`opts`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_failed_to_decrypt(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_get_pgp_subject(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_identify_rsvp(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_load_image(`ptr`: Pointer,`url`: RustBuffer.ByValue,`policy`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_mime_type(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_parsed_header_value(`ptr`: Pointer,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_privacy_lock(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_raw_body(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_raw_headers(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_decryptedmessage_unsubscribe_from_newsletter(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_deviceinfoprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_deviceinfoprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_deviceinfoprovider(`vtable`: UniffiVTableCallbackInterfaceDeviceInfoProvider,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_deviceinfoprovider_get_device_info(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_draft(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_draft(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draft_address_validation_result(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_attachment_list(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_draft_bcc_recipients(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_draft_body(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_cc_recipients(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_draft_change_sender_address(`ptr`: Pointer,`email`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_clear_address_validation_error(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draft_composer_content(`ptr`: Pointer,`themeOpts`: RustBuffer.ByValue,`editorId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_discard(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_expiration_time(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_get_password(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_is_password_protected(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_list_sender_addresses(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_load_image(`ptr`: Pointer,`url`: RustBuffer.ByValue,`policy`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_load_image_sync(`ptr`: Pointer,`cid`: RustBuffer.ByValue,`policy`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_message_id(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_mime_type(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_remove_password(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_save(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_schedule(`ptr`: Pointer,`timestamp`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_schedule_send_options(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_send(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_send_result(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_sender(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_set_body(`ptr`: Pointer,`body`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_set_expiration_time(`ptr`: Pointer,`expirationTime`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_set_password(`ptr`: Pointer,`password`: RustBuffer.ByValue,`hint`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_draft_set_subject(`ptr`: Pointer,`subject`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_subject(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_draft_to_recipients(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_draft_validate_recipients_expiration_feature(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_draftattachmentlistupdatestream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_draftattachmentlistupdatestream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draftattachmentlistupdatestream_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draftattachmentlistupdatestream_next_async(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_draftattachmentwatcher(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_draftattachmentwatcher(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draftattachmentwatcher_disconnect(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_draftsendresultcallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_draftsendresultcallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_draftsendresultcallback(`vtable`: UniffiVTableCallbackInterfaceDraftSendResultCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draftsendresultcallback_on_new_send_result(`ptr`: Pointer,`details`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_draftsendresultwatcher(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_draftsendresultwatcher(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_draftsendresultwatcher_disconnect(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_eventlooperrorobserver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_eventlooperrorobserver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_eventlooperrorobserver(`vtable`: UniffiVTableCallbackInterfaceEventLoopErrorObserver,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_eventlooperrorobserver_on_event_loop_error(`ptr`: Pointer,`error`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_eventlooperrorobserverhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_eventlooperrorobserverhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_eventlooperrorobserverhandle_disconnect(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_executewhenonlinecallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_executewhenonlinecallback(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_executewhenonlinecallback(`vtable`: UniffiVTableCallbackInterfaceExecuteWhenOnlineCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_executewhenonlinecallback_on_online(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_executewhenonlinecallbackasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_executewhenonlinecallbackasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_executewhenonlinecallbackasync(`vtable`: UniffiVTableCallbackInterfaceExecuteWhenOnlineCallbackAsync,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_executewhenonlinecallbackasync_on_online(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_mailconversationcursor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_mailconversationcursor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_fetch_next(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_goto_next(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_goto_prev(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_peek_next(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_peek_prev(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_mailmessagecursor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_mailmessagecursor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_fetch_next(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_goto_next(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_goto_prev(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_peek_next(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_peek_prev(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_mailsession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_mailsession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_app_protection(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_biometrics_check_passed(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_change_app_settings(`ptr`: Pointer,`settings`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_delete_account(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_delete_pin_code(`ptr`: Pointer,`pin`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_execute_notification_quick_action(`ptr`: Pointer,`session`: Pointer,`action`: RustBuffer.ByValue,`timeLeftMs`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_export_logs(`ptr`: Pointer,`filePath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_account(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_blocking(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_sessions(`ptr`: Pointer,`account`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_state(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_state_blocking(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_accounts(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_accounts_blocking(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_app_settings(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_primary_account(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_primary_account_blocking(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_session(`ptr`: Pointer,`sessionId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_blocking(`ptr`: Pointer,`sessionId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_state(`ptr`: Pointer,`sessionId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_state_blocking(`ptr`: Pointer,`sessionId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_sessions(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_get_sessions_blocking(`ptr`: Pointer,`account`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_initialized_user_session_from_stored_session(`ptr`: Pointer,`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_is_feature_enabled(`ptr`: Pointer,`featureId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_logout_account(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_new_login_flow(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_new_signup_flow(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_on_enter_foreground(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_on_exit_foreground(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_register_device_task(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_remaining_pin_attempts(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_resume_login_flow(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`sessionId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_set_biometrics_app_protection(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_set_pin_code(`ptr`: Pointer,`pin`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_set_primary_account(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_should_auto_lock(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_sign_out_all(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_start_auto_lock_countdown(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_start_background_execution(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_start_background_execution_with_duration(`ptr`: Pointer,`durationSeconds`: Long,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailsession_to_primary_user_session(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_to_user_session(`ptr`: Pointer,`ffiFlow`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_unset_biometrics_app_protection(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_update_os_network_status(`ptr`: Pointer,`osNetworkStatus`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailsession_user_session_from_stored_session(`ptr`: Pointer,`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_verify_pin_code(`ptr`: Pointer,`pin`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_account_sessions(`ptr`: Pointer,`account`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_accounts(`ptr`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_accounts_async(`ptr`: Pointer,`callback`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_feature_flags(`ptr`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_feature_flags_async(`ptr`: Pointer,`callback`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_sessions(`ptr`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailsession_watch_sessions_async(`ptr`: Pointer,`callback`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_mailusersession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_mailusersession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_account_details(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_applicable_labels(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_connection_status(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_execute_when_online(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_execute_when_online_async(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_force_event_loop_poll(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_force_event_loop_poll_and_wait(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_fork(`ptr`: Pointer,`platform`: RustBuffer.ByValue,`product`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_attachment(`ptr`: Pointer,`localAttachmentId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payment_method(`ptr`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_plans(`ptr`: Pointer,`options`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_resources_icons(`ptr`: Pointer,`name`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_status(`ptr`: Pointer,`vendor`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_subscription(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_has_valid_sender_address(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_image_for_sender(`ptr`: Pointer,`address`: RustBuffer.ByValue,`bimiSelector`: RustBuffer.ByValue,`displaySenderImage`: Byte,`size`: RustBuffer.ByValue,`mode`: RustBuffer.ByValue,`format`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_is_feature_enabled(`ptr`: Pointer,`featureId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_logout(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_movable_folders(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_new_password_change_flow(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_observe_event_loop_errors(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_override_user_feature_flag(`ptr`: Pointer,`flagName`: RustBuffer.ByValue,`newValue`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_password_validator(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_post_payments_subscription(`ptr`: Pointer,`subscription`: RustBuffer.ByValue,`newValues`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_post_payments_tokens(`ptr`: Pointer,`amount`: Long,`currency`: RustBuffer.ByValue,`payment`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_process_target_device_qr_code(`ptr`: Pointer,`qrCode`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_session_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_session_uuid(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_upsell_eligibility(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_user(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_user_settings(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_addresses(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_feature_flags_stream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_upsell_eligibility(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user_settings(`ptr`: Pointer,`callback`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user_stream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_mailbox(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_mailbox(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_mailbox_get_attachment(`ptr`: Pointer,`localAttachmentId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailbox_label_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailbox_recipient_display_mode(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailbox_unread_count(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_mailbox_view_mode(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_mailbox_watch_unread_count(`ptr`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_messagescroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_messagescroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_change_filter(`ptr`: Pointer,`unread`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_change_include(`ptr`: Pointer,`include`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_cursor(`ptr`: Pointer,`lookingAt`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_fetch_more(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_fetch_new(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_force_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_get_items(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_handle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_has_more(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_supports_include_filter(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_terminate(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_messagescroller_total(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_registerdevicetaskhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_registerdevicetaskhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_registerdevicetaskhandle_update_device(`ptr`: Pointer,`device`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_resolver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_resolver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_resolver(`vtable`: UniffiVTableCallbackInterfaceResolver,
): Unit
fun uniffi_proton_mail_uniffi_fn_method_resolver_resolve(`ptr`: Pointer,`host`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_rsvpeventservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_rsvpeventservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_rsvpeventservice_answer(`ptr`: Pointer,`answer`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_rsvpeventservice_get(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_rsvpeventserviceprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_rsvpeventserviceprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_rsvpeventserviceprovider_event_service(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_searchscroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_searchscroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_change_include(`ptr`: Pointer,`include`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_change_keywords(`ptr`: Pointer,`keywords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_cursor(`ptr`: Pointer,`lookingAt`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_fetch_more(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_force_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_get_items(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_handle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_has_more(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_supports_include_filter(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_terminate(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_searchscroller_total(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_sidebar(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_sidebar(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_constructor_sidebar_new(`session`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_method_sidebar_all_custom_folders(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_collapse_folder(`ptr`: Pointer,`localId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_custom_folders(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_custom_labels(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_expand_folder(`ptr`: Pointer,`localId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_system_labels(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_method_sidebar_watch_labels(`ptr`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_signatureverificationresult(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_signatureverificationresult(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_error_info(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_signature_creation_time(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_signature_key_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_verification_result(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_storedaccount(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_storedaccount(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_details(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_primary_seq(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_second_factor_status(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_second_password_status(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedaccount_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_storedsession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_storedsession(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_storedsession_session_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedsession_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_storedsession_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_clone_undo(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_undo(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_undo_undo(`ptr`: Pointer,`ctx`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_watchhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_watchhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchhandle_disconnect(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_clone_watchprivacyinfostream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_watchprivacyinfostream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_initial_info(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_next_async(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_watchuserfeatureflagsstream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_watchuserfeatureflagsstream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchuserfeatureflagsstream_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchuserfeatureflagsstream_next_async(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_clone_watchuserstream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_free_watchuserstream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchuserstream_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_method_watchuserstream_next_async(`ptr`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_contactslivequerycallback(`vtable`: UniffiVTableCallbackInterfaceContactsLiveQueryCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_conversationscrollerlivequerycallback(`vtable`: UniffiVTableCallbackInterfaceConversationScrollerLiveQueryCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_livequerycallback(`vtable`: UniffiVTableCallbackInterfaceLiveQueryCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_mailboxbackgroundresult(`vtable`: UniffiVTableCallbackInterfaceMailboxBackgroundResult,
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_messagescrollerlivequerycallback(`vtable`: UniffiVTableCallbackInterfaceMessageScrollerLiveQueryCallback,
): Unit
fun uniffi_proton_mail_uniffi_fn_init_callback_vtable_oskeychain(`vtable`: UniffiVTableCallbackInterfaceOsKeyChain,
): Unit
fun uniffi_proton_mail_uniffi_fn_func_all_available_conversation_actions_for_action_sheet(`mailbox`: Pointer,`conversationId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_all_available_conversation_actions_for_conversation(`mailbox`: Pointer,`conversationId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_all_available_list_actions_for_conversations(`mailbox`: Pointer,`conversationIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_all_available_list_actions_for_messages(`mailbox`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_all_available_message_actions_for_action_sheet(`mailbox`: Pointer,`theme`: RustBuffer.ByValue,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_all_available_message_actions_for_message(`mailbox`: Pointer,`theme`: RustBuffer.ByValue,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_assigned_swipe_actions(`currentFolder`: RustBuffer.ByValue,`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_available_label_as_actions_for_conversations(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_available_label_as_actions_for_messages(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_available_move_to_actions_for_conversations(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_available_move_to_actions_for_messages(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_available_snooze_actions_for_conversation(`session`: Pointer,`weekStart`: RustBuffer.ByValue,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_recipient(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_recipients(`addressList`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_sender(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_senders(`addressList`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_block_address(`session`: Pointer,`email`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_bulk_message_unread_status(`session`: Pointer,`remoteIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_contact_group_by_id(`session`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_contact_list(`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_contact_suggestions(`deviceContacts`: RustBuffer.ByValue,`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_conversation(`mailbox`: Pointer,`id`: RustBuffer.ByValue,`showAll`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_func_create_mail_session(`params`: RustBuffer.ByValue,`keyChain`: Long,`hvNotifier`: RustBuffer.ByValue,`deviceInfoProvider`: RustBuffer.ByValue,`issueReporter`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_custom_settings(`ctx`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_proton_mail_uniffi_fn_func_decrypt_push_notification(`keyChain`: Long,`encrypted`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_delete_all_messages_in_label(`session`: Pointer,`labelId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_delete_contact(`contactId`: RustBuffer.ByValue,`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_delete_conversations(`mailbox`: Pointer,`conversationIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_delete_messages(`mailbox`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_cancel_schedule_send(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_discard(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_send_result_delete(`session`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_send_result_mark_seen(`session`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_send_result_unseen(`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_draft_undo_send(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_generate_csp_nonce(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_get_all_mobile_conversation_actions(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_get_all_mobile_list_actions(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_get_all_mobile_message_actions(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_get_auto_delete_banner(`session`: Pointer,`labelId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_contact_details(`session`: Pointer,`contactId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_message_body(`mbox`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_mobile_conversation_toolbar_actions(`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_mobile_list_toolbar_actions(`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_mobile_message_toolbar_actions(`session`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_get_privacy_info_for_message(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_ios_share_ext_init_draft(`mailCacheDir`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_ios_share_ext_save_draft(`mailCacheDir`: RustBuffer.ByValue,`draft`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_is_message_sender_blocked(`mbox`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_is_valid_email_address(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_proton_mail_uniffi_fn_func_label_conversations_as(`mailbox`: Pointer,`conversationIds`: RustBuffer.ByValue,`selectedLabelIds`: RustBuffer.ByValue,`partiallySelectedLabelIds`: RustBuffer.ByValue,`mustArchive`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_func_label_messages_as(`mailbox`: Pointer,`messageIds`: RustBuffer.ByValue,`selectedLabelIds`: RustBuffer.ByValue,`partiallySelectedLabelIds`: RustBuffer.ByValue,`mustArchive`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mail_settings(`ctx`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mail_settings_sync(`ctx`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_make_me_crash(uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_mark_conversations_as_read(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mark_conversations_as_unread(`mailbox`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mark_messages_ham(`mailbox`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mark_messages_read(`mailbox`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_mark_messages_unread(`mailbox`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_message(`session`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_move_conversations(`mailbox`: Pointer,`labelId`: RustBuffer.ByValue,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_move_messages(`mailbox`: Pointer,`destinationId`: RustBuffer.ByValue,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_new_all_mail_mailbox(`ctx`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_new_challenge_loader(`cfg`: RustBuffer.ByValue,`app`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_new_draft(`session`: Pointer,`createMode`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_new_draft_send_watcher(`session`: Pointer,`callback`: Pointer,
): Long
fun uniffi_proton_mail_uniffi_fn_func_new_inbox_mailbox(`ctx`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_new_mailbox(`ctx`: Pointer,`labelId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_new_recipient(`email`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_open_draft(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_account_recovery_screen_view(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_drive_spotlight_cta_button_tapped(`userSession`: Pointer,`planBeforeUpgrade`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_drive_spotlight_mailbox_button_tapped(`userSession`: Pointer,`planBeforeUpgrade`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_fido_launch_result(`result`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_fido_sign_result(`result`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_human_verification_result(`status`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_human_verification_screen_view(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_human_verification_view_loading_result(`status`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_login_screen_view(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_signup_screen_view(`screenId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_record_upgrade_attempt(`userSession`: Pointer,`general`: RustBuffer.ByValue,`planSpecific`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_upgrade_cancelled_by_user(`userSession`: Pointer,`general`: RustBuffer.ByValue,`planSpecific`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_upgrade_error(`userSession`: Pointer,`general`: RustBuffer.ByValue,`planSpecific`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_upgrade_success(`userSession`: Pointer,`general`: RustBuffer.ByValue,`planSpecific`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_record_upsell_button_tapped(`userSession`: Pointer,`general`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_report_an_issue(`session`: Pointer,`issueReport`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_report_phishing(`mailbox`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_resolve_message_id(`session`: Pointer,`remoteId`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_resolve_system_label_by_id(`ctx`: Pointer,`id`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_resolve_system_label_id(`ctx`: Pointer,`label`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_rust_log_debug(`line`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_rust_log_error(`line`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_rust_log_info(`line`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_rust_log_trace(`line`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_rust_log_warn(`line`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_rust_sdk_version(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_major(uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_minor(uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_patch(uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_proton_mail_uniffi_fn_func_sanitize_pasted_content(`content`: RustBuffer.ByValue,`mimeType`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_proton_mail_uniffi_fn_func_scroll_conversations_for_label(`mailbox`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_scroll_messages_for_label(`mailbox`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_scroller_search(`mailbox`: Pointer,`options`: RustBuffer.ByValue,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_send_payment_observability_metric(`metric`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_proton_mail_uniffi_fn_func_snooze_conversations(`session`: Pointer,`labelId`: RustBuffer.ByValue,`ids`: RustBuffer.ByValue,`snoozeTime`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_star_conversations(`session`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_star_messages(`session`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_unblock_address(`mailbox`: Pointer,`email`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_unsnooze_conversations(`session`: Pointer,`labelId`: RustBuffer.ByValue,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_unstar_conversations(`session`: Pointer,`ids`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_unstar_messages(`session`: Pointer,`messageIds`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_update_mobile_conversation_toolbar_actions(`session`: Pointer,`actions`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_update_mobile_list_toolbar_actions(`session`: Pointer,`actions`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_update_mobile_message_toolbar_actions(`session`: Pointer,`actions`: RustBuffer.ByValue,
): Long
fun uniffi_proton_mail_uniffi_fn_func_update_next_message_on_move(`ctx`: Pointer,`enabled`: Byte,
): Long
fun uniffi_proton_mail_uniffi_fn_func_watch_contact_list(`session`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_watch_conversation(`mailbox`: Pointer,`id`: RustBuffer.ByValue,`origin`: RustBuffer.ByValue,`showAll`: Byte,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_watch_mail_settings(`ctx`: Pointer,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_watch_message(`session`: Pointer,`messageId`: RustBuffer.ByValue,`callback`: Long,
): Long
fun uniffi_proton_mail_uniffi_fn_func_watch_privacy_info_stream(`session`: Pointer,`messageId`: RustBuffer.ByValue,
): Long
fun ffi_proton_mail_uniffi_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_mail_uniffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_mail_uniffi_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_proton_mail_uniffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_mail_uniffi_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_proton_mail_uniffi_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_proton_mail_uniffi_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_proton_mail_uniffi_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_proton_mail_uniffi_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_proton_mail_uniffi_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_proton_mail_uniffi_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_proton_mail_uniffi_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_proton_mail_uniffi_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_proton_mail_uniffi_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_proton_mail_uniffi_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_pointer(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_pointer(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_proton_mail_uniffi_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_proton_mail_uniffi_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_proton_mail_uniffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_conversation_actions_for_action_sheet() != 18263.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_conversation_actions_for_conversation() != 17226.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_list_actions_for_conversations() != 46752.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_list_actions_for_messages() != 19956.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_message_actions_for_action_sheet() != 59463.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_all_available_message_actions_for_message() != 13553.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_assigned_swipe_actions() != 65388.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_available_label_as_actions_for_conversations() != 63729.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_available_label_as_actions_for_messages() != 30007.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_available_move_to_actions_for_conversations() != 25584.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_available_move_to_actions_for_messages() != 42325.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_available_snooze_actions_for_conversation() != 9761.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_recipient() != 39299.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_recipients() != 46454.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_sender() != 61210.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_avatar_information_from_message_senders() != 518.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_block_address() != 17956.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_bulk_message_unread_status() != 56109.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_contact_group_by_id() != 53059.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_contact_list() != 27590.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_contact_suggestions() != 65014.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_conversation() != 23185.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_create_mail_session() != 1835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_custom_settings() != 3972.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_decrypt_push_notification() != 37551.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_delete_all_messages_in_label() != 44759.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_delete_contact() != 42045.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_delete_conversations() != 26874.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_delete_messages() != 12922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_cancel_schedule_send() != 34221.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_discard() != 32049.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_send_result_delete() != 27239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_send_result_mark_seen() != 29.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_send_result_unseen() != 46550.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_draft_undo_send() != 1577.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_generate_csp_nonce() != 18299.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_conversation_actions() != 33275.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_list_actions() != 42122.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_all_mobile_message_actions() != 50982.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_auto_delete_banner() != 60283.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_contact_details() != 53768.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_message_body() != 47304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_mobile_conversation_toolbar_actions() != 47860.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_mobile_list_toolbar_actions() != 30577.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_mobile_message_toolbar_actions() != 36094.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_get_privacy_info_for_message() != 30061.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_ios_share_ext_init_draft() != 26156.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_ios_share_ext_save_draft() != 23489.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_is_message_sender_blocked() != 36248.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_is_valid_email_address() != 39246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_label_conversations_as() != 53810.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_label_messages_as() != 39745.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mail_settings() != 8092.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mail_settings_sync() != 23092.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_make_me_crash() != 41315.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mark_conversations_as_read() != 487.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mark_conversations_as_unread() != 22670.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mark_messages_ham() != 22851.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mark_messages_read() != 15186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_mark_messages_unread() != 57207.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_message() != 46090.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_move_conversations() != 34546.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_move_messages() != 65471.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_all_mail_mailbox() != 19677.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_challenge_loader() != 16872.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_draft() != 37712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_draft_send_watcher() != 37923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_inbox_mailbox() != 55124.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_mailbox() != 65030.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_new_recipient() != 62403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_open_draft() != 55917.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_account_recovery_screen_view() != 27182.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_drive_spotlight_cta_button_tapped() != 31778.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_drive_spotlight_mailbox_button_tapped() != 50950.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_fido_launch_result() != 13171.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_fido_sign_result() != 20437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_human_verification_result() != 44801.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_human_verification_screen_view() != 35972.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_human_verification_view_loading_result() != 46555.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_login_screen_view() != 2915.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_signup_screen_view() != 15026.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_upgrade_attempt() != 49773.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_upgrade_cancelled_by_user() != 11993.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_upgrade_error() != 22043.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_upgrade_success() != 8137.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_record_upsell_button_tapped() != 42497.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_report_an_issue() != 50242.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_report_phishing() != 46229.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_resolve_message_id() != 304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_resolve_system_label_by_id() != 56927.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_resolve_system_label_id() != 51673.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_log_debug() != 14152.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_log_error() != 21185.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_log_info() != 50419.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_log_trace() != 63621.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_log_warn() != 24140.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version() != 47971.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_major() != 40183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_minor() != 26092.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_rust_sdk_version_patch() != 45642.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_sanitize_pasted_content() != 31055.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_scroll_conversations_for_label() != 4600.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_scroll_messages_for_label() != 32707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_scroller_search() != 3204.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_send_payment_observability_metric() != 25156.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_snooze_conversations() != 46708.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_star_conversations() != 62143.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_star_messages() != 4336.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_unblock_address() != 21552.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_unsnooze_conversations() != 65377.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_unstar_conversations() != 38785.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_unstar_messages() != 59940.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_update_mobile_conversation_toolbar_actions() != 20139.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_update_mobile_list_toolbar_actions() != 6014.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_update_mobile_message_toolbar_actions() != 11405.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_update_next_message_on_move() != 1663.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_watch_contact_list() != 38678.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_watch_conversation() != 45045.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_watch_mail_settings() != 6613.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_watch_message() != 27815.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_func_watch_privacy_info_stream() != 63480.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_asynclivequerycallback_on_update() != 57095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_add() != 15176.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_add_inline() != 9703.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_attachment_upload_directory() != 1689.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_attachments() != 47007.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_remove() != 50938.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_remove_with_cid() != 20510.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_retry() != 55301.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_swap_attachment_disposition() != 22777.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_watcher() != 14994.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_attachmentlist_watcher_stream() != 54500.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_backgroundexecutioncallback_on_execution_completed() != 45883.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_backgroundexecutionhandle_abort() != 57173.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeloader_get() != 62180.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeloader_post() != 45121.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeloader_put() != 5644.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengenotifier_on_challenge() != 62429.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_base() != 6009.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_description() != 50339.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_expires_at() != 32163.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_methods() != 50738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_path() != 30375.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_query() != 23864.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengepayload_token() != 30616.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_doh() != 43095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_original_host() != 65413.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_path() != 51973.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_port() != 24768.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_resolved_host() != 59433.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_challengeserver_scheme() != 56588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_add_group_recipient() != 25457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_add_single_recipient() != 39679.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_recipients() != 56940.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_group() != 1931.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_recipient_from_group() != 53689.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_remove_single_recipient() != 34561.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientlist_set_callback() != 6028.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_composerrecipientvalidationcallback_on_update() != 14682.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_contactsuggestions_all() != 25939.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_contactsuggestions_filtered() != 31266.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_change_filter() != 34033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_change_include() != 42634.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_cursor() != 64141.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_fetch_more() != 24479.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_fetch_new() != 53776.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_force_refresh() != 55977.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_get_items() != 2442.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_handle() != 42029.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_has_more() != 20770.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_id() != 61829.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_refresh() != 7592.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_supports_include_filter() != 17903.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_terminate() != 30738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscroller_total() != 27476.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_customsettings_mobile_signature() != 52783.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_customsettings_set_mobile_signature() != 13396.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_customsettings_set_mobile_signature_enabled() != 11471.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_customsettings_set_swipe_to_adjacent_conversation() != 27927.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_customsettings_swipe_to_adjacent_conversation() != 5040.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_attachments() != 34465.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_body() != 48775.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_failed_to_decrypt() != 51118.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_get_pgp_subject() != 59242.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_identify_rsvp() != 63186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_load_image() != 56292.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_mime_type() != 41670.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_parsed_header_value() != 62311.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_privacy_lock() != 35835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_raw_body() != 43107.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_raw_headers() != 44121.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_decryptedmessage_unsubscribe_from_newsletter() != 14186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_deviceinfoprovider_get_device_info() != 59197.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_address_validation_result() != 26493.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_attachment_list() != 50013.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_bcc_recipients() != 25396.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_body() != 57000.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_cc_recipients() != 40014.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_change_sender_address() != 61324.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_clear_address_validation_error() != 61397.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_composer_content() != 11333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_discard() != 58588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_expiration_time() != 50276.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_get_password() != 2414.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_is_password_protected() != 1547.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_list_sender_addresses() != 2084.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_load_image() != 10069.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_load_image_sync() != 20391.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_message_id() != 50463.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_mime_type() != 56109.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_remove_password() != 4547.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_save() != 45971.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_schedule() != 30967.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_schedule_send_options() != 55294.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_send() != 31808.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_send_result() != 14167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_sender() != 44437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_set_body() != 57017.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_set_expiration_time() != 58060.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_set_password() != 36294.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_set_subject() != 11501.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_subject() != 39957.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_to_recipients() != 444.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draft_validate_recipients_expiration_feature() != 21260.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draftattachmentlistupdatestream_cancel() != 25074.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draftattachmentlistupdatestream_next_async() != 60376.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draftattachmentwatcher_disconnect() != 51192.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draftsendresultcallback_on_new_send_result() != 44621.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_draftsendresultwatcher_disconnect() != 11713.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_eventlooperrorobserver_on_event_loop_error() != 15174.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_eventlooperrorobserverhandle_disconnect() != 15687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_executewhenonlinecallback_on_online() != 50664.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_executewhenonlinecallbackasync_on_online() != 49255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_fetch_next() != 4761.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_goto_next() != 36557.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_goto_prev() != 26412.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_peek_next() != 4539.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailconversationcursor_peek_prev() != 32895.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_fetch_next() != 60033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_goto_next() != 52740.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_goto_prev() != 712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_peek_next() != 25171.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailmessagecursor_peek_prev() != 39098.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_app_protection() != 57003.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_biometrics_check_passed() != 27610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_change_app_settings() != 41422.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_delete_account() != 51553.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_delete_pin_code() != 56608.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_execute_notification_quick_action() != 13733.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_export_logs() != 19711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account() != 31252.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_blocking() != 62602.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_sessions() != 18883.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_state() != 52169.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_account_state_blocking() != 64654.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_accounts() != 59574.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_accounts_blocking() != 50009.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_app_settings() != 25284.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_primary_account() != 54070.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_primary_account_blocking() != 56786.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session() != 8508.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_blocking() != 20750.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_state() != 46331.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_session_state_blocking() != 51561.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_sessions() != 17818.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_get_sessions_blocking() != 14502.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_initialized_user_session_from_stored_session() != 55019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_is_feature_enabled() != 54054.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_logout_account() != 59838.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_new_login_flow() != 30455.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_new_signup_flow() != 2980.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_on_enter_foreground() != 50758.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_on_exit_foreground() != 13554.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_register_device_task() != 6154.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_remaining_pin_attempts() != 17154.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_resume_login_flow() != 53632.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_set_biometrics_app_protection() != 58308.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_set_pin_code() != 35950.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_set_primary_account() != 10635.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_should_auto_lock() != 1571.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_sign_out_all() != 51244.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_start_auto_lock_countdown() != 47200.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_start_background_execution() != 7562.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_start_background_execution_with_duration() != 20511.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_to_primary_user_session() != 971.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_to_user_session() != 55644.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_unset_biometrics_app_protection() != 11626.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_update_os_network_status() != 65390.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_user_session_from_stored_session() != 39456.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_verify_pin_code() != 12810.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_account_sessions() != 26824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_accounts() != 22484.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_accounts_async() != 54131.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_feature_flags() != 29857.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_feature_flags_async() != 54763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_sessions() != 39816.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailsession_watch_sessions_async() != 35567.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_account_details() != 20716.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_applicable_labels() != 53425.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_connection_status() != 21663.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_execute_when_online() != 12868.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_execute_when_online_async() != 36291.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_force_event_loop_poll() != 31556.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_force_event_loop_poll_and_wait() != 36220.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_fork() != 58610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_attachment() != 10468.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payment_method() != 33514.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_plans() != 51030.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_resources_icons() != 5788.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_status() != 24076.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_get_payments_subscription() != 54495.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_has_valid_sender_address() != 24131.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_image_for_sender() != 5590.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_is_feature_enabled() != 26845.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_logout() != 11437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_movable_folders() != 23890.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_new_password_change_flow() != 21593.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_observe_event_loop_errors() != 44633.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_override_user_feature_flag() != 19937.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_password_validator() != 50083.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_post_payments_subscription() != 29391.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_post_payments_tokens() != 16877.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_process_target_device_qr_code() != 25842.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_session_id() != 22737.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_session_uuid() != 4596.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_upsell_eligibility() != 1471.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_user() != 24711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_user_id() != 59019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_user_settings() != 64015.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_addresses() != 14627.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_feature_flags_stream() != 34136.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_upsell_eligibility() != 24188.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user() != 59584.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user_settings() != 4008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailusersession_watch_user_stream() != 64916.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_get_attachment() != 35229.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_label_id() != 25837.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_recipient_display_mode() != 12263.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_unread_count() != 47837.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_view_mode() != 19947.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailbox_watch_unread_count() != 29035.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_change_filter() != 40066.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_change_include() != 33770.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_cursor() != 65342.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_fetch_more() != 23907.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_fetch_new() != 56576.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_force_refresh() != 37922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_get_items() != 39055.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_handle() != 10125.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_has_more() != 3283.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_id() != 28891.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_refresh() != 20365.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_supports_include_filter() != 34911.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_terminate() != 45498.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescroller_total() != 41136.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_registerdevicetaskhandle_update_device() != 37176.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_resolver_resolve() != 56351.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_rsvpeventservice_answer() != 56992.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_rsvpeventservice_get() != 33068.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_rsvpeventserviceprovider_event_service() != 5855.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_change_include() != 19447.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_change_keywords() != 47027.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_cursor() != 40416.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_fetch_more() != 40763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_force_refresh() != 52284.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_get_items() != 3198.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_handle() != 18259.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_has_more() != 5510.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_id() != 21657.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_refresh() != 6501.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_supports_include_filter() != 19588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_terminate() != 41881.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_searchscroller_total() != 6115.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_all_custom_folders() != 34101.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_collapse_folder() != 20444.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_custom_folders() != 5891.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_custom_labels() != 35765.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_expand_folder() != 28907.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_system_labels() != 58232.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_sidebar_watch_labels() != 18293.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_error_info() != 6062.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_signature_creation_time() != 48544.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_signature_key_id() != 2265.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_signatureverificationresult_verification_result() != 52976.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_details() != 47690.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_primary_seq() != 51668.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_second_factor_status() != 45552.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_second_password_status() != 62579.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_state() != 3004.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedaccount_user_id() != 508.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedsession_session_id() != 50087.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedsession_state() != 61650.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_storedsession_user_id() != 64671.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_undo_undo() != 54687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchhandle_disconnect() != 38715.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_cancel() != 17646.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_initial_info() != 12955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchprivacyinfostream_next_async() != 50111.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchuserfeatureflagsstream_cancel() != 399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchuserfeatureflagsstream_next_async() != 54291.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchuserstream_cancel() != 45672.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_watchuserstream_next_async() != 15796.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_constructor_sidebar_new() != 3069.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_contactslivequerycallback_on_update() != 4860.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_conversationscrollerlivequerycallback_on_update() != 56386.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_livequerycallback_on_update() != 39796.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_mailboxbackgroundresult_on_background_result() != 44320.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_messagescrollerlivequerycallback_on_update() != 53722.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_oskeychain_store() != 10961.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_oskeychain_delete() != 36169.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_proton_mail_uniffi_checksum_method_oskeychain_load() != 22292.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}
internal inline fun<T> uniffiTraitInterfaceCallAsync(
    crossinline makeCall: suspend () -> T,
    crossinline handleSuccess: (T) -> Unit,
    crossinline handleError: (UniffiRustCallStatus.ByValue) -> Unit,
): UniffiForeignFuture {
    // Using `GlobalScope` is labeled as a "delicate API" and generally discouraged in Kotlin programs, since it breaks structured concurrency.
    // However, our parent task is a Rust future, so we're going to need to break structure concurrency in any case.
    //
    // Uniffi does its best to support structured concurrency across the FFI.
    // If the Rust future is dropped, `uniffiForeignFutureFreeImpl` is called, which will cancel the Kotlin coroutine if it's still running.
    @OptIn(DelicateCoroutinesApi::class)
    val job = GlobalScope.launch {
        try {
            handleSuccess(makeCall())
        } catch(e: kotlin.Exception) {
            handleError(
                UniffiRustCallStatus.create(
                    UNIFFI_CALL_UNEXPECTED_ERROR,
                    FfiConverterString.lower(e.toString()),
                )
            )
        }
    }
    val handle = uniffiForeignFutureHandleMap.insert(job)
    return UniffiForeignFuture(handle, uniffiForeignFutureFreeImpl)
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallAsyncWithError(
    crossinline makeCall: suspend () -> T,
    crossinline handleSuccess: (T) -> Unit,
    crossinline handleError: (UniffiRustCallStatus.ByValue) -> Unit,
    crossinline lowerError: (E) -> RustBuffer.ByValue,
): UniffiForeignFuture {
    // See uniffiTraitInterfaceCallAsync for details on `DelicateCoroutinesApi`
    @OptIn(DelicateCoroutinesApi::class)
    val job = GlobalScope.launch {
        try {
            handleSuccess(makeCall())
        } catch(e: kotlin.Exception) {
            if (e is E) {
                handleError(
                    UniffiRustCallStatus.create(
                        UNIFFI_CALL_ERROR,
                        lowerError(e),
                    )
                )
            } else {
                handleError(
                    UniffiRustCallStatus.create(
                        UNIFFI_CALL_UNEXPECTED_ERROR,
                        FfiConverterString.lower(e.toString()),
                    )
                )
            }
        }
    }
    val handle = uniffiForeignFutureHandleMap.insert(job)
    return UniffiForeignFuture(handle, uniffiForeignFutureFreeImpl)
}

internal val uniffiForeignFutureHandleMap = UniffiHandleMap<Job>()

internal object uniffiForeignFutureFreeImpl: UniffiForeignFutureFree {
    override fun callback(handle: Long) {
        val job = uniffiForeignFutureHandleMap.remove(handle)
        if (!job.isCompleted) {
            job.cancel()
        }
    }
}

// For testing
public fun uniffiForeignFutureHandleCount() = uniffiForeignFutureHandleMap.size

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.


private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
        AndroidSystemCleaner()
    } else {
        UniffiJnaCleaner()
    }

// The SystemCleaner, available from API Level 33.
// Some API Level 33 OSes do not support using it, so we require API Level 34.
@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleaner : UniffiCleaner {
    val cleaner = android.system.SystemCleaner.cleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        AndroidSystemCleanable(cleaner.register(value, cleanUpTask))
}

@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleanable(
    private val cleanable: java.lang.ref.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterInt: FfiConverter<Int, Int> {
    override fun lift(value: Int): Int {
        return value
    }

    override fun read(buf: ByteBuffer): Int {
        return buf.getInt()
    }

    override fun lower(value: Int): Int {
        return value
    }

    override fun allocationSize(value: Int) = 4UL

    override fun write(value: Int, buf: ByteBuffer) {
        buf.putInt(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * > [!WARNING]
 * >
 * > This interface is soft-deprecated. It tends to cause issues on android. Use `...Stream` pattern instead.
 * >
 * > See for example [`WatchUserStream`].

 */
public interface AsyncLiveQueryCallback {
    
    /**
     * Notify the client that the observed data has been updated.
     *
     * This method is called when the observed data has been updated. It does
     * not provide any information about the update, but the client can use
     * this as a signal to refresh its view of the data.

     */
    suspend fun `onUpdate`()
    
    companion object
}

/**
 * > [!WARNING]
 * >
 * > This interface is soft-deprecated. It tends to cause issues on android. Use `...Stream` pattern instead.
 * >
 * > See for example [`WatchUserStream`].

 */
open class AsyncLiveQueryCallbackImpl: Disposable, AutoCloseable, AsyncLiveQueryCallback
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_asynclivequerycallback(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_asynclivequerycallback(pointer!!, status)
        }
    }

    
    /**
     * Notify the client that the observed data has been updated.
     *
     * This method is called when the observed data has been updated. It does
     * not provide any information about the update, but the client can use
     * this as a signal to refresh its view of the data.

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `onUpdate`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_asynclivequerycallback_on_update(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceAsyncLiveQueryCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceAsyncLiveQueryCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeAsyncLiveQueryCallback.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`onUpdate`(
                )
            }
            val uniffiHandleSuccess = { _: Unit ->
                val uniffiResult = UniffiForeignFutureStructVoid.UniffiByValue(
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid.UniffiByValue(
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeAsyncLiveQueryCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceAsyncLiveQueryCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_asynclivequerycallback(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeAsyncLiveQueryCallback: FfiConverter<AsyncLiveQueryCallback, Pointer> {
    internal val handleMap = UniffiHandleMap<AsyncLiveQueryCallback>()

    override fun lower(value: AsyncLiveQueryCallback): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): AsyncLiveQueryCallback {
        return AsyncLiveQueryCallbackImpl(value)
    }

    override fun read(buf: ByteBuffer): AsyncLiveQueryCallback {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: AsyncLiveQueryCallback) = 8UL

    override fun write(value: AsyncLiveQueryCallback, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Access and modify the [`Draft`]'s attachments.
 */
public interface AttachmentListInterface {
    
    /**
     * Add a new attachment to this draft. If `filename_override` is present, that will become
     * the filename of the attachment. Otherwise, it is extracted from the path.
     */
    suspend fun `add`(`path`: kotlin.String, `filenameOverride`: kotlin.String?): AttachmentListAddResult
    
    /**
     * Add a new inline attachment to this draft. If `filename_override` is present, that will become
     * the filename of the attachment. Otherwise, it is extracted from the path.
     *
     * Returns the assigned content id.
     */
    suspend fun `addInline`(`path`: kotlin.String, `filenameOverride`: kotlin.String?): AttachmentListAddInlineResult
    
    /**
     * Get the directory for attachment uploads.
     */
    fun `attachmentUploadDirectory`(): kotlin.String
    
    /**
     * Get the list of attachments.
     */
    suspend fun `attachments`(): AttachmentListAttachmentsResult
    
    /**
     * Remove an attachment from this draft.
     */
    suspend fun `remove`(`id`: Id): AttachmentListRemoveResult
    
    /**
     * Remove an attachment from this draft by `content-id`.
     */
    suspend fun `removeWithCid`(`contentId`: kotlin.String): AttachmentListRemoveWithCidResult
    
    /**
     * Retry the upload of a failed attachment.
     */
    suspend fun `retry`(`attachmentId`: Id): AttachmentListRetryResult
    
    suspend fun `swapAttachmentDisposition`(`contentId`: kotlin.String): VoidDraftAttachmentDispositionSwapResult
    
    /**
     * Create a new watcher for attachment status updates..
     */
    suspend fun `watcher`(`callback`: AsyncLiveQueryCallback): AttachmentListWatcherResult
    
    suspend fun `watcherStream`(): AttachmentListWatcherStreamResult
    
    companion object
}

/**
 * Access and modify the [`Draft`]'s attachments.
 */
open class AttachmentList: Disposable, AutoCloseable, AttachmentListInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_attachmentlist(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_attachmentlist(pointer!!, status)
        }
    }

    
    /**
     * Add a new attachment to this draft. If `filename_override` is present, that will become
     * the filename of the attachment. Otherwise, it is extracted from the path.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `add`(`path`: kotlin.String, `filenameOverride`: kotlin.String?) : AttachmentListAddResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_add(
                thisPtr,
                FfiConverterString.lower(`path`),FfiConverterOptionalString.lower(`filenameOverride`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListAddResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Add a new inline attachment to this draft. If `filename_override` is present, that will become
     * the filename of the attachment. Otherwise, it is extracted from the path.
     *
     * Returns the assigned content id.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `addInline`(`path`: kotlin.String, `filenameOverride`: kotlin.String?) : AttachmentListAddInlineResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_add_inline(
                thisPtr,
                FfiConverterString.lower(`path`),FfiConverterOptionalString.lower(`filenameOverride`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListAddInlineResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the directory for attachment uploads.
     */override fun `attachmentUploadDirectory`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_attachment_upload_directory(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the list of attachments.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `attachments`() : AttachmentListAttachmentsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_attachments(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListAttachmentsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Remove an attachment from this draft.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `remove`(`id`: Id) : AttachmentListRemoveResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_remove(
                thisPtr,
                FfiConverterTypeId.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListRemoveResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Remove an attachment from this draft by `content-id`.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removeWithCid`(`contentId`: kotlin.String) : AttachmentListRemoveWithCidResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_remove_with_cid(
                thisPtr,
                FfiConverterString.lower(`contentId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListRemoveWithCidResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Retry the upload of a failed attachment.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `retry`(`attachmentId`: Id) : AttachmentListRetryResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_retry(
                thisPtr,
                FfiConverterTypeId.lower(`attachmentId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListRetryResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `swapAttachmentDisposition`(`contentId`: kotlin.String) : VoidDraftAttachmentDispositionSwapResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_swap_attachment_disposition(
                thisPtr,
                FfiConverterString.lower(`contentId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftAttachmentDispositionSwapResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Create a new watcher for attachment status updates..
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watcher`(`callback`: AsyncLiveQueryCallback) : AttachmentListWatcherResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_watcher(
                thisPtr,
                FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListWatcherResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watcherStream`() : AttachmentListWatcherStreamResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_attachmentlist_watcher_stream(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentListWatcherStreamResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentList: FfiConverter<AttachmentList, Pointer> {

    override fun lower(value: AttachmentList): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): AttachmentList {
        return AttachmentList(value)
    }

    override fun read(buf: ByteBuffer): AttachmentList {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: AttachmentList) = 8UL

    override fun write(value: AttachmentList, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface BackgroundExecutionCallback {
    
    suspend fun `onExecutionCompleted`(`result`: BackgroundExecutionResult)
    
    companion object
}

open class BackgroundExecutionCallbackImpl: Disposable, AutoCloseable, BackgroundExecutionCallback
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_backgroundexecutioncallback(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_backgroundexecutioncallback(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `onExecutionCompleted`(`result`: BackgroundExecutionResult) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_backgroundexecutioncallback_on_execution_completed(
                thisPtr,
                FfiConverterTypeBackgroundExecutionResult.lower(`result`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceBackgroundExecutionCallback {
    internal object `onExecutionCompleted`: UniffiCallbackInterfaceBackgroundExecutionCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`result`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeBackgroundExecutionCallback.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`onExecutionCompleted`(
                    FfiConverterTypeBackgroundExecutionResult.lift(`result`),
                )
            }
            val uniffiHandleSuccess = { _: Unit ->
                val uniffiResult = UniffiForeignFutureStructVoid.UniffiByValue(
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid.UniffiByValue(
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeBackgroundExecutionCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceBackgroundExecutionCallback.UniffiByValue(
        `onExecutionCompleted`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_backgroundexecutioncallback(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeBackgroundExecutionCallback: FfiConverter<BackgroundExecutionCallback, Pointer> {
    internal val handleMap = UniffiHandleMap<BackgroundExecutionCallback>()

    override fun lower(value: BackgroundExecutionCallback): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): BackgroundExecutionCallback {
        return BackgroundExecutionCallbackImpl(value)
    }

    override fun read(buf: ByteBuffer): BackgroundExecutionCallback {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: BackgroundExecutionCallback) = 8UL

    override fun write(value: BackgroundExecutionCallback, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface BackgroundExecutionHandleInterface {
    
    suspend fun `abort`(`inForeground`: kotlin.Boolean)
    
    companion object
}

open class BackgroundExecutionHandle: Disposable, AutoCloseable, BackgroundExecutionHandleInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_backgroundexecutionhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_backgroundexecutionhandle(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `abort`(`inForeground`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_backgroundexecutionhandle_abort(
                thisPtr,
                FfiConverterBoolean.lower(`inForeground`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeBackgroundExecutionHandle: FfiConverter<BackgroundExecutionHandle, Pointer> {

    override fun lower(value: BackgroundExecutionHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): BackgroundExecutionHandle {
        return BackgroundExecutionHandle(value)
    }

    override fun read(buf: ByteBuffer): BackgroundExecutionHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: BackgroundExecutionHandle) = 8UL

    override fun write(value: BackgroundExecutionHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The payload of a human verification challenge.
 */
public interface ChallengeLoaderInterface {
    
    /**
     * Send a GET request to the server and return the response.
     */
    suspend fun `get`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>): ChallengeLoaderGetResult
    
    /**
     * Send a POST request to the server and return the response.
     */
    suspend fun `post`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>, `body`: kotlin.ByteArray): ChallengeLoaderPostResult
    
    /**
     * Send a PUT request to the server and return the response.
     */
    suspend fun `put`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>, `body`: kotlin.ByteArray): ChallengeLoaderPutResult
    
    companion object
}

/**
 * The payload of a human verification challenge.
 */
open class ChallengeLoader: Disposable, AutoCloseable, ChallengeLoaderInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_challengeloader(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_challengeloader(pointer!!, status)
        }
    }

    
    /**
     * Send a GET request to the server and return the response.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `get`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>) : ChallengeLoaderGetResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeloader_get(
                thisPtr,
                FfiConverterString.lower(`base`),FfiConverterString.lower(`path`),FfiConverterSequenceTypeQuery.lower(`query`),FfiConverterSequenceTypeHeader.lower(`header`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeChallengeLoaderGetResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Send a POST request to the server and return the response.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `post`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>, `body`: kotlin.ByteArray) : ChallengeLoaderPostResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeloader_post(
                thisPtr,
                FfiConverterString.lower(`base`),FfiConverterString.lower(`path`),FfiConverterSequenceTypeQuery.lower(`query`),FfiConverterSequenceTypeHeader.lower(`header`),FfiConverterByteArray.lower(`body`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeChallengeLoaderPostResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Send a PUT request to the server and return the response.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `put`(`base`: kotlin.String, `path`: kotlin.String, `query`: List<Query>, `header`: List<Header>, `body`: kotlin.ByteArray) : ChallengeLoaderPutResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeloader_put(
                thisPtr,
                FfiConverterString.lower(`base`),FfiConverterString.lower(`path`),FfiConverterSequenceTypeQuery.lower(`query`),FfiConverterSequenceTypeHeader.lower(`header`),FfiConverterByteArray.lower(`body`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeChallengeLoaderPutResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeLoader: FfiConverter<ChallengeLoader, Pointer> {

    override fun lower(value: ChallengeLoader): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ChallengeLoader {
        return ChallengeLoader(value)
    }

    override fun read(buf: ByteBuffer): ChallengeLoader {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ChallengeLoader) = 8UL

    override fun write(value: ChallengeLoader, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * An interface by which human verification challenges can be handled.
 */
public interface ChallengeNotifier {
    
    /**
     * Called when a human verification challenge is encountered.
     *
     * The `server` is the server that sent the challenge, and it may be a direct server,
     * such as `mail.proton.me`, or an indirect server (aka alternative routing),
     * such as `d{base32}.protonpro.xyz`.
     */
    suspend fun `onChallenge`(`server`: ChallengeServer, `payload`: ChallengePayload): ChallengeResponse
    
    companion object
}

/**
 * An interface by which human verification challenges can be handled.
 */
open class ChallengeNotifierImpl: Disposable, AutoCloseable, ChallengeNotifier
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_challengenotifier(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_challengenotifier(pointer!!, status)
        }
    }

    
    /**
     * Called when a human verification challenge is encountered.
     *
     * The `server` is the server that sent the challenge, and it may be a direct server,
     * such as `mail.proton.me`, or an indirect server (aka alternative routing),
     * such as `d{base32}.protonpro.xyz`.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `onChallenge`(`server`: ChallengeServer, `payload`: ChallengePayload) : ChallengeResponse {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengenotifier_on_challenge(
                thisPtr,
                FfiConverterTypeChallengeServer.lower(`server`),FfiConverterTypeChallengePayload.lower(`payload`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeChallengeResponse.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceChallengeNotifier {
    internal object `onChallenge`: UniffiCallbackInterfaceChallengeNotifierMethod0 {
        override fun callback(`uniffiHandle`: Long,`server`: Pointer,`payload`: Pointer,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeChallengeNotifier.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`onChallenge`(
                    FfiConverterTypeChallengeServer.lift(`server`),
                    FfiConverterTypeChallengePayload.lift(`payload`),
                )
            }
            val uniffiHandleSuccess = { returnValue: ChallengeResponse ->
                val uniffiResult = UniffiForeignFutureStructRustBuffer.UniffiByValue(
                    FfiConverterTypeChallengeResponse.lower(returnValue),
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer.UniffiByValue(
                        RustBuffer.ByValue(),
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeChallengeNotifier.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceChallengeNotifier.UniffiByValue(
        `onChallenge`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_challengenotifier(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeNotifier: FfiConverter<ChallengeNotifier, Pointer> {
    internal val handleMap = UniffiHandleMap<ChallengeNotifier>()

    override fun lower(value: ChallengeNotifier): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): ChallengeNotifier {
        return ChallengeNotifierImpl(value)
    }

    override fun read(buf: ByteBuffer): ChallengeNotifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ChallengeNotifier) = 8UL

    override fun write(value: ChallengeNotifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The payload of a human verification challenge.
 */
public interface ChallengePayloadInterface {
    
    /**
     * The URL base.
     */
    fun `base`(): kotlin.String
    
    /**
     * The challenge description.
     */
    fun `description`(): kotlin.String
    
    fun `expiresAt`(): kotlin.ULong
    
    /**
     * The verification methods available.
     */
    fun `methods`(): List<kotlin.String>
    
    /**
     * The URL path.
     */
    fun `path`(): kotlin.String
    
    /**
     * The query parameters of the URL.
     */
    fun `query`(): List<Query>
    
    /**
     * The initial human verification token.
     */
    fun `token`(): kotlin.String
    
    companion object
}

/**
 * The payload of a human verification challenge.
 */
open class ChallengePayload: Disposable, AutoCloseable, ChallengePayloadInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_challengepayload(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_challengepayload(pointer!!, status)
        }
    }

    
    /**
     * The URL base.
     */override fun `base`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_base(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The challenge description.
     */override fun `description`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_description(
        it, _status)
}
    }
    )
    }
    

    override fun `expiresAt`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_expires_at(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The verification methods available.
     */override fun `methods`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_methods(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The URL path.
     */override fun `path`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_path(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The query parameters of the URL.
     */override fun `query`(): List<Query> {
            return FfiConverterSequenceTypeQuery.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_query(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The initial human verification token.
     */override fun `token`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengepayload_token(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengePayload: FfiConverter<ChallengePayload, Pointer> {

    override fun lower(value: ChallengePayload): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ChallengePayload {
        return ChallengePayload(value)
    }

    override fun read(buf: ByteBuffer): ChallengePayload {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ChallengePayload) = 8UL

    override fun write(value: ChallengePayload, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The server of a human verification challenge.
 */
public interface ChallengeServerInterface {
    
    /**
     * Whether alternative routing is enabled.
     */
    fun `doh`(): kotlin.Boolean
    
    /**
     * The original hostname of the server.
     */
    fun `originalHost`(): kotlin.String
    
    /**
     * The path of the server.
     */
    fun `path`(): kotlin.String
    
    /**
     * The port of the server.
     */
    fun `port`(): kotlin.UShort
    
    /**
     * The resolved hostname of the server.
     */
    fun `resolvedHost`(): kotlin.String
    
    /**
     * The scheme of the server.
     */
    fun `scheme`(): kotlin.String
    
    companion object
}

/**
 * The server of a human verification challenge.
 */
open class ChallengeServer: Disposable, AutoCloseable, ChallengeServerInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_challengeserver(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_challengeserver(pointer!!, status)
        }
    }

    
    /**
     * Whether alternative routing is enabled.
     */override fun `doh`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_doh(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The original hostname of the server.
     */override fun `originalHost`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_original_host(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The path of the server.
     */override fun `path`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_path(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The port of the server.
     */override fun `port`(): kotlin.UShort {
            return FfiConverterUShort.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_port(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The resolved hostname of the server.
     */override fun `resolvedHost`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_resolved_host(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The scheme of the server.
     */override fun `scheme`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_challengeserver_scheme(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeServer: FfiConverter<ChallengeServer, Pointer> {

    override fun lower(value: ChallengeServer): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ChallengeServer {
        return ChallengeServer(value)
    }

    override fun read(buf: ByteBuffer): ChallengeServer {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ChallengeServer) = 8UL

    override fun write(value: ChallengeServer, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ComposerRecipientListInterface {
    
    /**
     * Add or extend the contact group with `group_name` with the given `recipients`.
     *
     * Note that `total_contacts_in_group` should be total value of elements in this group. It is
     * expected that this is retrieved from the contacts api.
     */
    fun `addGroupRecipient`(`groupName`: kotlin.String, `recipients`: List<SingleRecipientEntry>, `totalContactsInGroup`: kotlin.ULong): AddGroupRecipientError
    
    /**
     * Add a new single recipient to the list.
     */
    fun `addSingleRecipient`(`recipient`: SingleRecipientEntry): AddSingleRecipientError
    
    /**
     * Get the ordered list of recipients.
     */
    fun `recipients`(): List<ComposerRecipient>
    
    /**
     * Remove a contact group by `group_name`
     */
    fun `removeGroup`(`groupName`: kotlin.String): RemoveRecipientError
    
    /**
     * Remove a recipient with `email` from a contact group with `group_name`.
     */
    fun `removeRecipientFromGroup`(`groupName`: kotlin.String, `email`: kotlin.String): RemoveRecipientError
    
    /**
     * Remove a single recipient by `email`.
     */
    fun `removeSingleRecipient`(`email`: kotlin.String): RemoveRecipientError
    
    /**
     * Set the callback to receive validation updates.
     */
    fun `setCallback`(`cb`: ComposerRecipientValidationCallback)
    
    companion object
}

open class ComposerRecipientList: Disposable, AutoCloseable, ComposerRecipientListInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_composerrecipientlist(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_composerrecipientlist(pointer!!, status)
        }
    }

    
    /**
     * Add or extend the contact group with `group_name` with the given `recipients`.
     *
     * Note that `total_contacts_in_group` should be total value of elements in this group. It is
     * expected that this is retrieved from the contacts api.
     */override fun `addGroupRecipient`(`groupName`: kotlin.String, `recipients`: List<SingleRecipientEntry>, `totalContactsInGroup`: kotlin.ULong): AddGroupRecipientError {
            return FfiConverterTypeAddGroupRecipientError.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_add_group_recipient(
        it, FfiConverterString.lower(`groupName`),FfiConverterSequenceTypeSingleRecipientEntry.lower(`recipients`),FfiConverterULong.lower(`totalContactsInGroup`),_status)
}
    }
    )
    }
    

    
    /**
     * Add a new single recipient to the list.
     */override fun `addSingleRecipient`(`recipient`: SingleRecipientEntry): AddSingleRecipientError {
            return FfiConverterTypeAddSingleRecipientError.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_add_single_recipient(
        it, FfiConverterTypeSingleRecipientEntry.lower(`recipient`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the ordered list of recipients.
     */override fun `recipients`(): List<ComposerRecipient> {
            return FfiConverterSequenceTypeComposerRecipient.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_recipients(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remove a contact group by `group_name`
     */override fun `removeGroup`(`groupName`: kotlin.String): RemoveRecipientError {
            return FfiConverterTypeRemoveRecipientError.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_group(
        it, FfiConverterString.lower(`groupName`),_status)
}
    }
    )
    }
    

    
    /**
     * Remove a recipient with `email` from a contact group with `group_name`.
     */override fun `removeRecipientFromGroup`(`groupName`: kotlin.String, `email`: kotlin.String): RemoveRecipientError {
            return FfiConverterTypeRemoveRecipientError.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_recipient_from_group(
        it, FfiConverterString.lower(`groupName`),FfiConverterString.lower(`email`),_status)
}
    }
    )
    }
    

    
    /**
     * Remove a single recipient by `email`.
     */override fun `removeSingleRecipient`(`email`: kotlin.String): RemoveRecipientError {
            return FfiConverterTypeRemoveRecipientError.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_remove_single_recipient(
        it, FfiConverterString.lower(`email`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the callback to receive validation updates.
     */override fun `setCallback`(`cb`: ComposerRecipientValidationCallback)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientlist_set_callback(
        it, FfiConverterTypeComposerRecipientValidationCallback.lower(`cb`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipientList: FfiConverter<ComposerRecipientList, Pointer> {

    override fun lower(value: ComposerRecipientList): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ComposerRecipientList {
        return ComposerRecipientList(value)
    }

    override fun read(buf: ByteBuffer): ComposerRecipientList {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ComposerRecipientList) = 8UL

    override fun write(value: ComposerRecipientList, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Callback invoked when the recipient list validation triggers an update.
 */
public interface ComposerRecipientValidationCallback {
    
    fun `onUpdate`()
    
    companion object
}

/**
 * Callback invoked when the recipient list validation triggers an update.
 */
open class ComposerRecipientValidationCallbackImpl: Disposable, AutoCloseable, ComposerRecipientValidationCallback
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_composerrecipientvalidationcallback(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_composerrecipientvalidationcallback(pointer!!, status)
        }
    }

    override fun `onUpdate`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_composerrecipientvalidationcallback_on_update(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceComposerRecipientValidationCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceComposerRecipientValidationCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeComposerRecipientValidationCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeComposerRecipientValidationCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceComposerRecipientValidationCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_composerrecipientvalidationcallback(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipientValidationCallback: FfiConverter<ComposerRecipientValidationCallback, Pointer> {
    internal val handleMap = UniffiHandleMap<ComposerRecipientValidationCallback>()

    override fun lower(value: ComposerRecipientValidationCallback): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): ComposerRecipientValidationCallback {
        return ComposerRecipientValidationCallbackImpl(value)
    }

    override fun read(buf: ByteBuffer): ComposerRecipientValidationCallback {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ComposerRecipientValidationCallback) = 8UL

    override fun write(value: ComposerRecipientValidationCallback, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Collection of sorted contact suggestions
 */
public interface ContactSuggestionsInterface {
    
    /**
     * Returns all contact suggestions

     */
    fun `all`(): List<ContactSuggestion>
    
    /**
     * Returns suggestions filtered by the query

     */
    fun `filtered`(`query`: kotlin.String): List<ContactSuggestion>
    
    companion object
}

/**
 * Collection of sorted contact suggestions
 */
open class ContactSuggestions: Disposable, AutoCloseable, ContactSuggestionsInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_contactsuggestions(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_contactsuggestions(pointer!!, status)
        }
    }

    
    /**
     * Returns all contact suggestions

     */override fun `all`(): List<ContactSuggestion> {
            return FfiConverterSequenceTypeContactSuggestion.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_contactsuggestions_all(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns suggestions filtered by the query

     */override fun `filtered`(`query`: kotlin.String): List<ContactSuggestion> {
            return FfiConverterSequenceTypeContactSuggestion.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_contactsuggestions_filtered(
        it, FfiConverterString.lower(`query`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeContactSuggestions: FfiConverter<ContactSuggestions, Pointer> {

    override fun lower(value: ContactSuggestions): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ContactSuggestions {
        return ContactSuggestions(value)
    }

    override fun read(buf: ByteBuffer): ContactSuggestions {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ContactSuggestions) = 8UL

    override fun write(value: ContactSuggestions, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ConversationScrollerInterface {
    
    fun `changeFilter`(`unread`: ReadFilter): ConversationScrollerChangeFilterResult
    
    fun `changeInclude`(`include`: IncludeSwitch): ConversationScrollerChangeIncludeResult
    
    suspend fun `cursor`(`lookingAt`: Id): ConversationScrollerCursorResult
    
    /**
     * Moves to the next page and retrieves its results.
     */
    fun `fetchMore`(): ConversationScrollerFetchMoreResult
    
    /**
     * Tries to fetch the newest items.
     */
    fun `fetchNew`(): ConversationScrollerFetchNewResult
    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */
    fun `forceRefresh`(): ConversationScrollerForceRefreshResult
    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */
    fun `getItems`(): ConversationScrollerGetItemsResult
    
    fun `handle`(): WatchHandle
    
    suspend fun `hasMore`(): ConversationScrollerHasMoreResult
    
    /**
     * Returns the unique identifier for this scroller instance.
     */
    fun `id`(): kotlin.String
    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */
    fun `refresh`(): ConversationScrollerRefreshResult
    
    suspend fun `supportsIncludeFilter`(): ConversationScrollerSupportsIncludeFilterResult
    
    fun `terminate`()
    
    suspend fun `total`(): ConversationScrollerTotalResult
    
    companion object
}

open class ConversationScroller: Disposable, AutoCloseable, ConversationScrollerInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_conversationscroller(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_conversationscroller(pointer!!, status)
        }
    }

    override fun `changeFilter`(`unread`: ReadFilter): ConversationScrollerChangeFilterResult {
            return FfiConverterTypeConversationScrollerChangeFilterResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_change_filter(
        it, FfiConverterTypeReadFilter.lower(`unread`),_status)
}
    }
    )
    }
    

    override fun `changeInclude`(`include`: IncludeSwitch): ConversationScrollerChangeIncludeResult {
            return FfiConverterTypeConversationScrollerChangeIncludeResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_change_include(
        it, FfiConverterTypeIncludeSwitch.lower(`include`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cursor`(`lookingAt`: Id) : ConversationScrollerCursorResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_cursor(
                thisPtr,
                FfiConverterTypeId.lower(`lookingAt`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConversationScrollerCursorResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Moves to the next page and retrieves its results.
     */override fun `fetchMore`(): ConversationScrollerFetchMoreResult {
            return FfiConverterTypeConversationScrollerFetchMoreResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_fetch_more(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Tries to fetch the newest items.
     */override fun `fetchNew`(): ConversationScrollerFetchNewResult {
            return FfiConverterTypeConversationScrollerFetchNewResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_fetch_new(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */override fun `forceRefresh`(): ConversationScrollerForceRefreshResult {
            return FfiConverterTypeConversationScrollerForceRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_force_refresh(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */override fun `getItems`(): ConversationScrollerGetItemsResult {
            return FfiConverterTypeConversationScrollerGetItemsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_get_items(
        it, _status)
}
    }
    )
    }
    

    override fun `handle`(): WatchHandle {
            return FfiConverterTypeWatchHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_handle(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `hasMore`() : ConversationScrollerHasMoreResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_has_more(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConversationScrollerHasMoreResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns the unique identifier for this scroller instance.
     */override fun `id`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */override fun `refresh`(): ConversationScrollerRefreshResult {
            return FfiConverterTypeConversationScrollerRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_refresh(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `supportsIncludeFilter`() : ConversationScrollerSupportsIncludeFilterResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_supports_include_filter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConversationScrollerSupportsIncludeFilterResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `terminate`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_terminate(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `total`() : ConversationScrollerTotalResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_conversationscroller_total(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConversationScrollerTotalResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScroller: FfiConverter<ConversationScroller, Pointer> {

    override fun lower(value: ConversationScroller): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ConversationScroller {
        return ConversationScroller(value)
    }

    override fun read(buf: ByteBuffer): ConversationScroller {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ConversationScroller) = 8UL

    override fun write(value: ConversationScroller, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface CustomSettingsInterface {
    
    suspend fun `mobileSignature`(): CustomSettingsMobileSignatureResult
    
    suspend fun `setMobileSignature`(`signature`: kotlin.String): CustomSettingsSetMobileSignatureResult
    
    suspend fun `setMobileSignatureEnabled`(`enabled`: kotlin.Boolean): CustomSettingsSetMobileSignatureEnabledResult
    
    suspend fun `setSwipeToAdjacentConversation`(`enabled`: kotlin.Boolean): CustomSettingsSetSwipeToAdjacentConversationResult
    
    suspend fun `swipeToAdjacentConversation`(): CustomSettingsSwipeToAdjacentConversationResult
    
    companion object
}

open class CustomSettings: Disposable, AutoCloseable, CustomSettingsInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_customsettings(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_customsettings(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `mobileSignature`() : CustomSettingsMobileSignatureResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_customsettings_mobile_signature(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeCustomSettingsMobileSignatureResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setMobileSignature`(`signature`: kotlin.String) : CustomSettingsSetMobileSignatureResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_customsettings_set_mobile_signature(
                thisPtr,
                FfiConverterString.lower(`signature`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeCustomSettingsSetMobileSignatureResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setMobileSignatureEnabled`(`enabled`: kotlin.Boolean) : CustomSettingsSetMobileSignatureEnabledResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_customsettings_set_mobile_signature_enabled(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeCustomSettingsSetMobileSignatureEnabledResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setSwipeToAdjacentConversation`(`enabled`: kotlin.Boolean) : CustomSettingsSetSwipeToAdjacentConversationResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_customsettings_set_swipe_to_adjacent_conversation(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeCustomSettingsSetSwipeToAdjacentConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `swipeToAdjacentConversation`() : CustomSettingsSwipeToAdjacentConversationResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_customsettings_swipe_to_adjacent_conversation(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeCustomSettingsSwipeToAdjacentConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettings: FfiConverter<CustomSettings, Pointer> {

    override fun lower(value: CustomSettings): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): CustomSettings {
        return CustomSettings(value)
    }

    override fun read(buf: ByteBuffer): CustomSettings {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: CustomSettings) = 8UL

    override fun write(value: CustomSettings, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DecryptedMessageInterface {
    
    /**
     * The full attachment list contained inside the message body.
     *
     * Message/Conversation attachments are limited to only 10.
     */
    fun `attachments`(): List<AttachmentMetadata>
    
    /**
     * Gets the message body as an HTML. This does all of the transformations that are
     * required based on the options and the user settings.
     */
    suspend fun `body`(`opts`: TransformOpts): BodyOutputResult
    
    fun `failedToDecrypt`(): kotlin.Boolean
    
    fun `getPgpSubject`(): kotlin.String?
    
    /**
     * Checks if this mail contains an invitation and, if so, returns its
     * identifier - you can then use this identifier to fetch event details.
     *
     * [1] TODO (NGC-57) implement support for offline-mode
     * (this function probably will probably not have to be adjusted, but
     * I'm leaving a comment so that we know to update the docs above)
     */
    suspend fun `identifyRsvp`(): RsvpEventServiceProvider?
    
    suspend fun `loadImage`(`url`: kotlin.String, `policy`: ImagePolicy): AttachmentDataResult
    
    fun `mimeType`(): MimeType
    
    fun `parsedHeaderValue`(`key`: kotlin.String): List<kotlin.String>
    
    /**
     * Calculate the privacy lock for this message.
     *
     * Note: this is an expensive operation and should e launched on a background
     * task.
     */
    suspend fun `privacyLock`(): PrivacyLock?
    
    fun `rawBody`(): kotlin.String
    
    fun `rawHeaders`(): kotlin.String
    
    suspend fun `unsubscribeFromNewsletter`(): VoidActionResult
    
    companion object
}

open class DecryptedMessage: Disposable, AutoCloseable, DecryptedMessageInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_decryptedmessage(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_decryptedmessage(pointer!!, status)
        }
    }

    
    /**
     * The full attachment list contained inside the message body.
     *
     * Message/Conversation attachments are limited to only 10.
     */override fun `attachments`(): List<AttachmentMetadata> {
            return FfiConverterSequenceTypeAttachmentMetadata.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_attachments(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Gets the message body as an HTML. This does all of the transformations that are
     * required based on the options and the user settings.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `body`(`opts`: TransformOpts) : BodyOutputResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_body(
                thisPtr,
                FfiConverterTypeTransformOpts.lower(`opts`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeBodyOutputResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `failedToDecrypt`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_failed_to_decrypt(
        it, _status)
}
    }
    )
    }
    

    override fun `getPgpSubject`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_get_pgp_subject(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Checks if this mail contains an invitation and, if so, returns its
     * identifier - you can then use this identifier to fetch event details.
     *
     * [1] TODO (NGC-57) implement support for offline-mode
     * (this function probably will probably not have to be adjusted, but
     * I'm leaving a comment so that we know to update the docs above)
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `identifyRsvp`() : RsvpEventServiceProvider? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_identify_rsvp(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRsvpEventServiceProvider.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadImage`(`url`: kotlin.String, `policy`: ImagePolicy) : AttachmentDataResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_load_image(
                thisPtr,
                FfiConverterString.lower(`url`),FfiConverterTypeImagePolicy.lower(`policy`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentDataResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `mimeType`(): MimeType {
            return FfiConverterTypeMimeType.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_mime_type(
        it, _status)
}
    }
    )
    }
    

    override fun `parsedHeaderValue`(`key`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_parsed_header_value(
        it, FfiConverterString.lower(`key`),_status)
}
    }
    )
    }
    

    
    /**
     * Calculate the privacy lock for this message.
     *
     * Note: this is an expensive operation and should e launched on a background
     * task.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `privacyLock`() : PrivacyLock? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_privacy_lock(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypePrivacyLock.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `rawBody`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_raw_body(
        it, _status)
}
    }
    )
    }
    

    override fun `rawHeaders`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_raw_headers(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unsubscribeFromNewsletter`() : VoidActionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_decryptedmessage_unsubscribe_from_newsletter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedMessage: FfiConverter<DecryptedMessage, Pointer> {

    override fun lower(value: DecryptedMessage): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DecryptedMessage {
        return DecryptedMessage(value)
    }

    override fun read(buf: ByteBuffer): DecryptedMessage {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DecryptedMessage) = 8UL

    override fun write(value: DecryptedMessage, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * An interface to provide device info from native.
 */
public interface DeviceInfoProvider {
    
    suspend fun `getDeviceInfo`(): DeviceInfo
    
    companion object
}

/**
 * An interface to provide device info from native.
 */
open class DeviceInfoProviderImpl: Disposable, AutoCloseable, DeviceInfoProvider
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_deviceinfoprovider(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_deviceinfoprovider(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getDeviceInfo`() : DeviceInfo {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_deviceinfoprovider_get_device_info(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDeviceInfo.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceDeviceInfoProvider {
    internal object `getDeviceInfo`: UniffiCallbackInterfaceDeviceInfoProviderMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeDeviceInfoProvider.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`getDeviceInfo`(
                )
            }
            val uniffiHandleSuccess = { returnValue: DeviceInfo ->
                val uniffiResult = UniffiForeignFutureStructRustBuffer.UniffiByValue(
                    FfiConverterTypeDeviceInfo.lower(returnValue),
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer.UniffiByValue(
                        RustBuffer.ByValue(),
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeDeviceInfoProvider.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceDeviceInfoProvider.UniffiByValue(
        `getDeviceInfo`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_deviceinfoprovider(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeDeviceInfoProvider: FfiConverter<DeviceInfoProvider, Pointer> {
    internal val handleMap = UniffiHandleMap<DeviceInfoProvider>()

    override fun lower(value: DeviceInfoProvider): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): DeviceInfoProvider {
        return DeviceInfoProviderImpl(value)
    }

    override fun read(buf: ByteBuffer): DeviceInfoProvider {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DeviceInfoProvider) = 8UL

    override fun write(value: DeviceInfoProvider, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DraftInterface {
    
    fun `addressValidationResult`(): DraftAddressValidationResult?
    
    fun `attachmentList`(): AttachmentList
    
    fun `bccRecipients`(): ComposerRecipientList
    
    fun `body`(): kotlin.String
    
    fun `ccRecipients`(): ComposerRecipientList
    
    suspend fun `changeSenderAddress`(`email`: kotlin.String): DraftChangeSenderAddressResult
    
    fun `clearAddressValidationError`()
    
    /**
     * Returns both HTML content for <head> in the composer editor, as well as modified (as in with dark mode)
     * body of the draft.
     * Used to initialize the composer editor.
     *
     * **WARNING**: This function modifies the draft content by removing `!important` flag.
     *
     * # Parameters
     *
     * * `theme_opts` - theme options - used to determine html content theme.
     * * `editor_id` - the HTML ID of the editor that wraps the message. The same used to reference DOM in javascript.
     *
     * # Example of usage
     *
     * ```ignore
     * let composer_content = draft.composer_content(theme_opts, "editor");
     * let head_to_inject = composer_content.head;
     * let body = composer_content.body;
     *
     * let template = format!("
     * <html>
     * <head>
     *
     * <meta ...things set up for the composer />
     *
     * {head_to_inject}
     *
     * </head>
     * <body>
     * ...
     * {body}
     * ...
     * </body>
     * </html>
     * ");
     * ```
     */
    fun `composerContent`(`themeOpts`: ThemeOpts, `editorId`: kotlin.String): DraftComposerContentResult
    
    suspend fun `discard`(): VoidDraftDiscardResult
    
    fun `expirationTime`(): DraftExpirationTimeResult
    
    fun `getPassword`(): DraftGetPasswordResult
    
    fun `isPasswordProtected`(): DraftIsPasswordProtectedResult
    
    suspend fun `listSenderAddresses`(): DraftListSenderAddressesResult
    
    suspend fun `loadImage`(`url`: kotlin.String, `policy`: ImagePolicy): AttachmentDataResult
    
    fun `loadImageSync`(`cid`: kotlin.String, `policy`: ImagePolicy): AttachmentDataResult
    
    suspend fun `messageId`(): DraftMessageIdResult
    
    fun `mimeType`(): MimeType
    
    suspend fun `removePassword`(): VoidDraftPasswordResult
    
    suspend fun `save`(): VoidDraftSaveResult
    
    suspend fun `schedule`(`timestamp`: UnixTimestamp): VoidDraftSendResult
    
    fun `scheduleSendOptions`(): DraftScheduleSendOptionsResult
    
    suspend fun `send`(): VoidDraftSendResult
    
    /**
     * Retrieve the send result associated with draft.
     *
     * Note this only loaded with [`open_draft()`].
     */
    fun `sendResult`(): DraftSendResult?
    
    fun `sender`(): kotlin.String
    
    fun `setBody`(`body`: kotlin.String): VoidDraftSaveResult
    
    suspend fun `setExpirationTime`(`expirationTime`: DraftExpirationTime): VoidDraftExpirationResult
    
    suspend fun `setPassword`(`password`: kotlin.String, `hint`: kotlin.String?): VoidDraftPasswordResult
    
    fun `setSubject`(`subject`: kotlin.String): VoidDraftSaveResult
    
    fun `subject`(): kotlin.String
    
    fun `toRecipients`(): ComposerRecipientList
    
    fun `validateRecipientsExpirationFeature`(): DraftValidateRecipientsExpirationFeatureResult
    
    companion object
}

open class Draft: Disposable, AutoCloseable, DraftInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_draft(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_draft(pointer!!, status)
        }
    }

    override fun `addressValidationResult`(): DraftAddressValidationResult? {
            return FfiConverterOptionalTypeDraftAddressValidationResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_address_validation_result(
        it, _status)
}
    }
    )
    }
    

    override fun `attachmentList`(): AttachmentList {
            return FfiConverterTypeAttachmentList.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_attachment_list(
        it, _status)
}
    }
    )
    }
    

    override fun `bccRecipients`(): ComposerRecipientList {
            return FfiConverterTypeComposerRecipientList.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_bcc_recipients(
        it, _status)
}
    }
    )
    }
    

    override fun `body`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_body(
        it, _status)
}
    }
    )
    }
    

    override fun `ccRecipients`(): ComposerRecipientList {
            return FfiConverterTypeComposerRecipientList.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_cc_recipients(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `changeSenderAddress`(`email`: kotlin.String) : DraftChangeSenderAddressResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_change_sender_address(
                thisPtr,
                FfiConverterString.lower(`email`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDraftChangeSenderAddressResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `clearAddressValidationError`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_clear_address_validation_error(
        it, _status)
}
    }
    
    

    
    /**
     * Returns both HTML content for <head> in the composer editor, as well as modified (as in with dark mode)
     * body of the draft.
     * Used to initialize the composer editor.
     *
     * **WARNING**: This function modifies the draft content by removing `!important` flag.
     *
     * # Parameters
     *
     * * `theme_opts` - theme options - used to determine html content theme.
     * * `editor_id` - the HTML ID of the editor that wraps the message. The same used to reference DOM in javascript.
     *
     * # Example of usage
     *
     * ```ignore
     * let composer_content = draft.composer_content(theme_opts, "editor");
     * let head_to_inject = composer_content.head;
     * let body = composer_content.body;
     *
     * let template = format!("
     * <html>
     * <head>
     *
     * <meta ...things set up for the composer />
     *
     * {head_to_inject}
     *
     * </head>
     * <body>
     * ...
     * {body}
     * ...
     * </body>
     * </html>
     * ");
     * ```
     */override fun `composerContent`(`themeOpts`: ThemeOpts, `editorId`: kotlin.String): DraftComposerContentResult {
            return FfiConverterTypeDraftComposerContentResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_composer_content(
        it, FfiConverterTypeThemeOpts.lower(`themeOpts`),FfiConverterString.lower(`editorId`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `discard`() : VoidDraftDiscardResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_discard(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftDiscardResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `expirationTime`(): DraftExpirationTimeResult {
            return FfiConverterTypeDraftExpirationTimeResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_expiration_time(
        it, _status)
}
    }
    )
    }
    

    override fun `getPassword`(): DraftGetPasswordResult {
            return FfiConverterTypeDraftGetPasswordResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_get_password(
        it, _status)
}
    }
    )
    }
    

    override fun `isPasswordProtected`(): DraftIsPasswordProtectedResult {
            return FfiConverterTypeDraftIsPasswordProtectedResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_is_password_protected(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listSenderAddresses`() : DraftListSenderAddressesResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_list_sender_addresses(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDraftListSenderAddressesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadImage`(`url`: kotlin.String, `policy`: ImagePolicy) : AttachmentDataResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_load_image(
                thisPtr,
                FfiConverterString.lower(`url`),FfiConverterTypeImagePolicy.lower(`policy`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAttachmentDataResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `loadImageSync`(`cid`: kotlin.String, `policy`: ImagePolicy): AttachmentDataResult {
            return FfiConverterTypeAttachmentDataResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_load_image_sync(
        it, FfiConverterString.lower(`cid`),FfiConverterTypeImagePolicy.lower(`policy`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `messageId`() : DraftMessageIdResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_message_id(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDraftMessageIdResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `mimeType`(): MimeType {
            return FfiConverterTypeMimeType.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_mime_type(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removePassword`() : VoidDraftPasswordResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_remove_password(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftPasswordResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `save`() : VoidDraftSaveResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_save(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftSaveResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `schedule`(`timestamp`: UnixTimestamp) : VoidDraftSendResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_schedule(
                thisPtr,
                FfiConverterTypeUnixTimestamp.lower(`timestamp`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftSendResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `scheduleSendOptions`(): DraftScheduleSendOptionsResult {
            return FfiConverterTypeDraftScheduleSendOptionsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_schedule_send_options(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `send`() : VoidDraftSendResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_send(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftSendResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Retrieve the send result associated with draft.
     *
     * Note this only loaded with [`open_draft()`].
     */override fun `sendResult`(): DraftSendResult? {
            return FfiConverterOptionalTypeDraftSendResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_send_result(
        it, _status)
}
    }
    )
    }
    

    override fun `sender`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_sender(
        it, _status)
}
    }
    )
    }
    

    override fun `setBody`(`body`: kotlin.String): VoidDraftSaveResult {
            return FfiConverterTypeVoidDraftSaveResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_set_body(
        it, FfiConverterString.lower(`body`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setExpirationTime`(`expirationTime`: DraftExpirationTime) : VoidDraftExpirationResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_set_expiration_time(
                thisPtr,
                FfiConverterTypeDraftExpirationTime.lower(`expirationTime`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftExpirationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setPassword`(`password`: kotlin.String, `hint`: kotlin.String?) : VoidDraftPasswordResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_set_password(
                thisPtr,
                FfiConverterString.lower(`password`),FfiConverterOptionalString.lower(`hint`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftPasswordResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `setSubject`(`subject`: kotlin.String): VoidDraftSaveResult {
            return FfiConverterTypeVoidDraftSaveResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_set_subject(
        it, FfiConverterString.lower(`subject`),_status)
}
    }
    )
    }
    

    override fun `subject`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_subject(
        it, _status)
}
    }
    )
    }
    

    override fun `toRecipients`(): ComposerRecipientList {
            return FfiConverterTypeComposerRecipientList.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_to_recipients(
        it, _status)
}
    }
    )
    }
    

    override fun `validateRecipientsExpirationFeature`(): DraftValidateRecipientsExpirationFeatureResult {
            return FfiConverterTypeDraftValidateRecipientsExpirationFeatureResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draft_validate_recipients_expiration_feature(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDraft: FfiConverter<Draft, Pointer> {

    override fun lower(value: Draft): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Draft {
        return Draft(value)
    }

    override fun read(buf: ByteBuffer): Draft {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Draft) = 8UL

    override fun write(value: Draft, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface DraftAttachmentListUpdateStreamInterface {
    
    fun `cancel`()
    
    suspend fun `nextAsync`(): VoidProtonResult
    
    companion object
}

open class DraftAttachmentListUpdateStream: Disposable, AutoCloseable, DraftAttachmentListUpdateStreamInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_draftattachmentlistupdatestream(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_draftattachmentlistupdatestream(pointer!!, status)
        }
    }

    override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draftattachmentlistupdatestream_cancel(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextAsync`() : VoidProtonResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draftattachmentlistupdatestream_next_async(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidProtonResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentListUpdateStream: FfiConverter<DraftAttachmentListUpdateStream, Pointer> {

    override fun lower(value: DraftAttachmentListUpdateStream): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DraftAttachmentListUpdateStream {
        return DraftAttachmentListUpdateStream(value)
    }

    override fun read(buf: ByteBuffer): DraftAttachmentListUpdateStream {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DraftAttachmentListUpdateStream) = 8UL

    override fun write(value: DraftAttachmentListUpdateStream, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Observe draft send results.
 *
 * Note that this will only notify you of new records that have not been seen before.
 */
public interface DraftAttachmentWatcherInterface {
    
    fun `disconnect`()
    
    companion object
}

/**
 * Observe draft send results.
 *
 * Note that this will only notify you of new records that have not been seen before.
 */
open class DraftAttachmentWatcher: Disposable, AutoCloseable, DraftAttachmentWatcherInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_draftattachmentwatcher(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_draftattachmentwatcher(pointer!!, status)
        }
    }

    override fun `disconnect`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draftattachmentwatcher_disconnect(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentWatcher: FfiConverter<DraftAttachmentWatcher, Pointer> {

    override fun lower(value: DraftAttachmentWatcher): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DraftAttachmentWatcher {
        return DraftAttachmentWatcher(value)
    }

    override fun read(buf: ByteBuffer): DraftAttachmentWatcher {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DraftAttachmentWatcher) = 8UL

    override fun write(value: DraftAttachmentWatcher, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Callback interface to be notified of new draft send results.
 */
public interface DraftSendResultCallback {
    
    /**
     * Will be invoked with a list of at least 1 new send result.
     */
    fun `onNewSendResult`(`details`: List<DraftSendResult>)
    
    companion object
}

/**
 * Callback interface to be notified of new draft send results.
 */
open class DraftSendResultCallbackImpl: Disposable, AutoCloseable, DraftSendResultCallback
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_draftsendresultcallback(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_draftsendresultcallback(pointer!!, status)
        }
    }

    
    /**
     * Will be invoked with a list of at least 1 new send result.
     */override fun `onNewSendResult`(`details`: List<DraftSendResult>)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draftsendresultcallback_on_new_send_result(
        it, FfiConverterSequenceTypeDraftSendResult.lower(`details`),_status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceDraftSendResultCallback {
    internal object `onNewSendResult`: UniffiCallbackInterfaceDraftSendResultCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`details`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeDraftSendResultCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onNewSendResult`(
                    FfiConverterSequenceTypeDraftSendResult.lift(`details`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeDraftSendResultCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceDraftSendResultCallback.UniffiByValue(
        `onNewSendResult`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_draftsendresultcallback(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendResultCallback: FfiConverter<DraftSendResultCallback, Pointer> {
    internal val handleMap = UniffiHandleMap<DraftSendResultCallback>()

    override fun lower(value: DraftSendResultCallback): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): DraftSendResultCallback {
        return DraftSendResultCallbackImpl(value)
    }

    override fun read(buf: ByteBuffer): DraftSendResultCallback {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DraftSendResultCallback) = 8UL

    override fun write(value: DraftSendResultCallback, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Observe draft send results.
 *
 * Note that this will only notify you of new records that have not been seen before.
 */
public interface DraftSendResultWatcherInterface {
    
    /**
     * Disconnect the watcher and stop observing the table.
     */
    fun `disconnect`()
    
    companion object
}

/**
 * Observe draft send results.
 *
 * Note that this will only notify you of new records that have not been seen before.
 */
open class DraftSendResultWatcher: Disposable, AutoCloseable, DraftSendResultWatcherInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_draftsendresultwatcher(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_draftsendresultwatcher(pointer!!, status)
        }
    }

    
    /**
     * Disconnect the watcher and stop observing the table.
     */override fun `disconnect`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_draftsendresultwatcher_disconnect(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendResultWatcher: FfiConverter<DraftSendResultWatcher, Pointer> {

    override fun lower(value: DraftSendResultWatcher): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DraftSendResultWatcher {
        return DraftSendResultWatcher(value)
    }

    override fun read(buf: ByteBuffer): DraftSendResultWatcher {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DraftSendResultWatcher) = 8UL

    override fun write(value: DraftSendResultWatcher, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Event loop error observer callback.
 */
public interface EventLoopErrorObserver {
    
    /**
     * Invoked when the event loop runs into an error that prevents it from progressing.
     */
    suspend fun `onEventLoopError`(`error`: EventError)
    
    companion object
}

/**
 * Event loop error observer callback.
 */
open class EventLoopErrorObserverImpl: Disposable, AutoCloseable, EventLoopErrorObserver
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_eventlooperrorobserver(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_eventlooperrorobserver(pointer!!, status)
        }
    }

    
    /**
     * Invoked when the event loop runs into an error that prevents it from progressing.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `onEventLoopError`(`error`: EventError) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_eventlooperrorobserver_on_event_loop_error(
                thisPtr,
                FfiConverterTypeEventError.lower(`error`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceEventLoopErrorObserver {
    internal object `onEventLoopError`: UniffiCallbackInterfaceEventLoopErrorObserverMethod0 {
        override fun callback(`uniffiHandle`: Long,`error`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeEventLoopErrorObserver.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`onEventLoopError`(
                    FfiConverterTypeEventError.lift(`error`),
                )
            }
            val uniffiHandleSuccess = { _: Unit ->
                val uniffiResult = UniffiForeignFutureStructVoid.UniffiByValue(
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid.UniffiByValue(
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeEventLoopErrorObserver.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceEventLoopErrorObserver.UniffiByValue(
        `onEventLoopError`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_eventlooperrorobserver(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeEventLoopErrorObserver: FfiConverter<EventLoopErrorObserver, Pointer> {
    internal val handleMap = UniffiHandleMap<EventLoopErrorObserver>()

    override fun lower(value: EventLoopErrorObserver): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): EventLoopErrorObserver {
        return EventLoopErrorObserverImpl(value)
    }

    override fun read(buf: ByteBuffer): EventLoopErrorObserver {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: EventLoopErrorObserver) = 8UL

    override fun write(value: EventLoopErrorObserver, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Handle returned when observing event loop errors.
 *
 * Keep this handle alive to maintain the callback alive.
 */
public interface EventLoopErrorObserverHandleInterface {
    
    /**
     * Disconnect this observer and release all associated resources.
     */
    fun `disconnect`()
    
    companion object
}

/**
 * Handle returned when observing event loop errors.
 *
 * Keep this handle alive to maintain the callback alive.
 */
open class EventLoopErrorObserverHandle: Disposable, AutoCloseable, EventLoopErrorObserverHandleInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_eventlooperrorobserverhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_eventlooperrorobserverhandle(pointer!!, status)
        }
    }

    
    /**
     * Disconnect this observer and release all associated resources.
     */override fun `disconnect`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_eventlooperrorobserverhandle_disconnect(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeEventLoopErrorObserverHandle: FfiConverter<EventLoopErrorObserverHandle, Pointer> {

    override fun lower(value: EventLoopErrorObserverHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): EventLoopErrorObserverHandle {
        return EventLoopErrorObserverHandle(value)
    }

    override fun read(buf: ByteBuffer): EventLoopErrorObserverHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: EventLoopErrorObserverHandle) = 8UL

    override fun write(value: EventLoopErrorObserverHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ExecuteWhenOnlineCallback {
    
    fun `onOnline`()
    
    companion object
}

open class ExecuteWhenOnlineCallbackImpl: Disposable, AutoCloseable, ExecuteWhenOnlineCallback
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_executewhenonlinecallback(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_executewhenonlinecallback(pointer!!, status)
        }
    }

    override fun `onOnline`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_executewhenonlinecallback_on_online(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceExecuteWhenOnlineCallback {
    internal object `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeExecuteWhenOnlineCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onOnline`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeExecuteWhenOnlineCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceExecuteWhenOnlineCallback.UniffiByValue(
        `onOnline`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_executewhenonlinecallback(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeExecuteWhenOnlineCallback: FfiConverter<ExecuteWhenOnlineCallback, Pointer> {
    internal val handleMap = UniffiHandleMap<ExecuteWhenOnlineCallback>()

    override fun lower(value: ExecuteWhenOnlineCallback): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): ExecuteWhenOnlineCallback {
        return ExecuteWhenOnlineCallbackImpl(value)
    }

    override fun read(buf: ByteBuffer): ExecuteWhenOnlineCallback {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ExecuteWhenOnlineCallback) = 8UL

    override fun write(value: ExecuteWhenOnlineCallback, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ExecuteWhenOnlineCallbackAsync {
    
    suspend fun `onOnline`()
    
    companion object
}

open class ExecuteWhenOnlineCallbackAsyncImpl: Disposable, AutoCloseable, ExecuteWhenOnlineCallbackAsync
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_executewhenonlinecallbackasync(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_executewhenonlinecallbackasync(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `onOnline`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_executewhenonlinecallbackasync_on_online(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceExecuteWhenOnlineCallbackAsync {
    internal object `onOnline`: UniffiCallbackInterfaceExecuteWhenOnlineCallbackAsyncMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiFutureCallback`: UniffiForeignFutureCompleteVoid,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeExecuteWhenOnlineCallbackAsync.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`onOnline`(
                )
            }
            val uniffiHandleSuccess = { _: Unit ->
                val uniffiResult = UniffiForeignFutureStructVoid.UniffiByValue(
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid.UniffiByValue(
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsync(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeExecuteWhenOnlineCallbackAsync.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceExecuteWhenOnlineCallbackAsync.UniffiByValue(
        `onOnline`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_executewhenonlinecallbackasync(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeExecuteWhenOnlineCallbackAsync: FfiConverter<ExecuteWhenOnlineCallbackAsync, Pointer> {
    internal val handleMap = UniffiHandleMap<ExecuteWhenOnlineCallbackAsync>()

    override fun lower(value: ExecuteWhenOnlineCallbackAsync): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): ExecuteWhenOnlineCallbackAsync {
        return ExecuteWhenOnlineCallbackAsyncImpl(value)
    }

    override fun read(buf: ByteBuffer): ExecuteWhenOnlineCallbackAsync {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ExecuteWhenOnlineCallbackAsync) = 8UL

    override fun write(value: ExecuteWhenOnlineCallbackAsync, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MailConversationCursorInterface {
    
    suspend fun `fetchNext`(): MailConversationCursorFetchNextResult
    
    fun `gotoNext`()
    
    fun `gotoPrev`()
    
    fun `peekNext`(): NextMailCursorConversation
    
    fun `peekPrev`(): Conversation?
    
    companion object
}

open class MailConversationCursor: Disposable, AutoCloseable, MailConversationCursorInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_mailconversationcursor(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_mailconversationcursor(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchNext`() : MailConversationCursorFetchNextResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_fetch_next(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailConversationCursorFetchNextResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `gotoNext`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_goto_next(
        it, _status)
}
    }
    
    

    override fun `gotoPrev`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_goto_prev(
        it, _status)
}
    }
    
    

    override fun `peekNext`(): NextMailCursorConversation {
            return FfiConverterTypeNextMailCursorConversation.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_peek_next(
        it, _status)
}
    }
    )
    }
    

    override fun `peekPrev`(): Conversation? {
            return FfiConverterOptionalTypeConversation.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailconversationcursor_peek_prev(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMailConversationCursor: FfiConverter<MailConversationCursor, Pointer> {

    override fun lower(value: MailConversationCursor): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MailConversationCursor {
        return MailConversationCursor(value)
    }

    override fun read(buf: ByteBuffer): MailConversationCursor {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MailConversationCursor) = 8UL

    override fun write(value: MailConversationCursor, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MailMessageCursorInterface {
    
    suspend fun `fetchNext`(): MailMessageCursorFetchNextResult
    
    fun `gotoNext`()
    
    fun `gotoPrev`()
    
    fun `peekNext`(): NextMailCursorMessage
    
    fun `peekPrev`(): Message?
    
    companion object
}

open class MailMessageCursor: Disposable, AutoCloseable, MailMessageCursorInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_mailmessagecursor(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_mailmessagecursor(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchNext`() : MailMessageCursorFetchNextResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_fetch_next(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailMessageCursorFetchNextResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `gotoNext`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_goto_next(
        it, _status)
}
    }
    
    

    override fun `gotoPrev`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_goto_prev(
        it, _status)
}
    }
    
    

    override fun `peekNext`(): NextMailCursorMessage {
            return FfiConverterTypeNextMailCursorMessage.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_peek_next(
        it, _status)
}
    }
    )
    }
    

    override fun `peekPrev`(): Message? {
            return FfiConverterOptionalTypeMessage.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailmessagecursor_peek_prev(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMailMessageCursor: FfiConverter<MailMessageCursor, Pointer> {

    override fun lower(value: MailMessageCursor): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MailMessageCursor {
        return MailMessageCursor(value)
    }

    override fun read(buf: ByteBuffer): MailMessageCursor {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MailMessageCursor) = 8UL

    override fun write(value: MailMessageCursor, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MailSessionInterface {
    
    suspend fun `appProtection`(): MailSessionAppProtectionResult
    
    /**
     * Mark biometrics check as passed.
     *
     * This method is used to mark that the biometrics check has been passed
     * for autolock to reset the timer.

     */
    fun `biometricsCheckPassed`()
    
    suspend fun `changeAppSettings`(`settings`: AppSettingsDiff): MailSessionChangeAppSettingsResult
    
    suspend fun `deleteAccount`(`userId`: kotlin.String): VoidSessionResult
    
    /**
     * Delete stored PIN
     *
     * This method also carries verification of the PIN to remove, that is why
     * it returns PinAuthError type. If verification is unsuccessful it won't
     * remove the PIN and return proper Error Reason.

     */
    suspend fun `deletePinCode`(`pin`: List<kotlin.UInt>): MailSessionDeletePinCodeResult
    
    suspend fun `executeNotificationQuickAction`(`session`: StoredSession, `action`: PushNotificationQuickAction, `timeLeftMs`: kotlin.ULong?): VoidActionResult
    
    /**
     * Export all logs into a single file wih the given `file_path`
     *
     * Returns the number of bytes written.
     */
    fun `exportLogs`(`filePath`: kotlin.String): MailSessionExportLogsResult
    
    suspend fun `getAccount`(`userId`: kotlin.String): MailSessionGetAccountResult
    
    fun `getAccountBlocking`(`userId`: kotlin.String): MailSessionGetAccountResult
    
    suspend fun `getAccountSessions`(`account`: StoredAccount): MailSessionGetAccountSessionsResult
    
    suspend fun `getAccountState`(`userId`: kotlin.String): MailSessionGetAccountStateResult
    
    fun `getAccountStateBlocking`(`userId`: kotlin.String): MailSessionGetAccountStateResult
    
    suspend fun `getAccounts`(): MailSessionGetAccountsResult
    
    fun `getAccountsBlocking`(): MailSessionGetAccountsResult
    
    suspend fun `getAppSettings`(): MailSessionGetAppSettingsResult
    
    suspend fun `getPrimaryAccount`(): MailSessionGetPrimaryAccountResult
    
    fun `getPrimaryAccountBlocking`(): MailSessionGetPrimaryAccountResult
    
    suspend fun `getSession`(`sessionId`: kotlin.String): MailSessionGetSessionResult
    
    fun `getSessionBlocking`(`sessionId`: kotlin.String): MailSessionGetSessionResult
    
    suspend fun `getSessionState`(`sessionId`: kotlin.String): MailSessionGetSessionStateResult
    
    fun `getSessionStateBlocking`(`sessionId`: kotlin.String): MailSessionGetSessionStateResult
    
    suspend fun `getSessions`(): MailSessionGetSessionsResult
    
    fun `getSessionsBlocking`(`account`: StoredAccount): MailSessionGetAccountSessionsResult
    
    suspend fun `initializedUserSessionFromStoredSession`(`session`: StoredSession): MailSessionInitializedUserSessionFromStoredSessionResult
    
    /**
     * Is the Unleash feature enabled. Only returns **global** feature flags.
     *
     * These flags are not refreshed if there is an active user session.
     * Use [`MailUserSession::is_feature_enabled`] whenever it is possible.
     *
     * Currently:
     * * Returns None if feature is was never present
     * * Returns Some(true) if feature is present
     * * Returns Some(false) if feature was present and enabled but got disabled
     */
    suspend fun `isFeatureEnabled`(`featureId`: kotlin.String): MailSessionIsFeatureEnabledResult
    
    suspend fun `logoutAccount`(`userId`: kotlin.String): VoidSessionResult
    
    suspend fun `newLoginFlow`(): MailSessionNewLoginFlowResult
    
    suspend fun `newSignupFlow`(): MailSessionNewSignupFlowResult
    
    fun `onEnterForeground`()
    
    fun `onExitForeground`()
    
    /**
     * Spawns new background task responsible for registering device for the push notification.
     * That task will automatically watch for new sessions and register them with latest known device
     * token.
     *
     * In order to provide device registration details, this function returns an object [`RegisterDeviceTaskHandle`]
     * that has a method [`RegisterDeviceTaskHandle::update_device`].

     */
    fun `registerDeviceTask`(): MailSessionRegisterDeviceTaskResult
    
    /**
     * Return remaining attempts at verifing PIN code.
     *
     * Method will return None when PIN protection is not set.
     * Method will return Some(value) when PIN protection is in use.

     */
    suspend fun `remainingPinAttempts`(): MailSessionRemainingPinAttemptsResult
    
    suspend fun `resumeLoginFlow`(`userId`: kotlin.String, `sessionId`: kotlin.String): MailSessionResumeLoginFlowResult
    
    suspend fun `setBiometricsAppProtection`(): MailSessionSetBiometricsAppProtectionResult
    
    suspend fun `setPinCode`(`pin`: List<kotlin.UInt>): MailSessionSetPinCodeResult
    
    suspend fun `setPrimaryAccount`(`userId`: kotlin.String): VoidSessionResult
    
    /**
     * Should invoke app lock according to app settings.
     *
     * Method will update itself to new access time when returning `true`,
     * It assumes client will invoke the app protection by themself

     */
    suspend fun `shouldAutoLock`(): MailSessionShouldAutoLockResult
    
    /**
     * Sing out from all accounts.
     *
     * This method is going to remove all user data & account data
     * associated with the mail application.
     *
     * This method is meant to be used when someone decides to sign out on
     * authentication screen such as PIN or Biometrics verification.
     *
     * This method will recover an empty state of the mail application ready to
     * log user back in.

     */
    suspend fun `signOutAll`(): MailSessionSignOutAllResult
    
    /**
     * Start the auto lock countdown.
     *
     * This method is meant to be used when app is about to be put in the background.
     * It will start the auto lock countdown and will be used to determine if the app
     * spent enough time in the background to be locked.

     */
    fun `startAutoLockCountdown`()
    
    /**
     * Functionality to execute pending actions for all logged in accounts in controlled manner.
     *
     * This method is meant to be executed when putting application to sleep or running it in the background.
     *
     * It will stop when aborted or when finished whatever comes first.
     * On exit the callback will be triggered to notify caller that it finished.
     *
     * A default time out of 30 seconds is assigned to this method, for more control use
     * [`start_background_execution_with_duration`].
     */
    fun `startBackgroundExecution`(`callback`: BackgroundExecutionCallback): MailSessionStartBackgroundExecutionResult
    
    /**
     * Same as [`start_background_execution`] but an optional `duration_seconds` can be specified.
     *
     * Note that the duration is the maximum time we will wait for either the background work
     * to finish or the abort handle to be called. We can still  spend some time after that
     * waiting for task completion.
     */
    fun `startBackgroundExecutionWithDuration`(`durationSeconds`: kotlin.ULong, `callback`: BackgroundExecutionCallback): MailSessionStartBackgroundExecutionWithDurationResult
    
    /**
     * Converts this session into a [`MailUserSession`] for the primary user.
     *
     * This is meant to be used only within extensions - in particular, it
     * assumes that the primary user is already logged in.
     */
    suspend fun `toPrimaryUserSession`(): MailSessionToPrimaryUserSessionResult
    
    suspend fun `toUserSession`(`ffiFlow`: LoginFlow): MailSessionToUserSessionResult
    
    suspend fun `unsetBiometricsAppProtection`(): MailSessionUnsetBiometricsAppProtectionResult
    
    fun `updateOsNetworkStatus`(`osNetworkStatus`: OsNetworkStatus)
    
    suspend fun `userSessionFromStoredSession`(`session`: StoredSession): MailSessionUserSessionFromStoredSessionResult
    
    suspend fun `verifyPinCode`(`pin`: List<kotlin.UInt>): MailSessionVerifyPinCodeResult
    
    suspend fun `watchAccountSessions`(`account`: StoredAccount, `callback`: LiveQueryCallback): MailSessionWatchAccountSessionsResult
    
    suspend fun `watchAccounts`(`callback`: LiveQueryCallback): MailSessionWatchAccountsResult
    
    suspend fun `watchAccountsAsync`(`callback`: AsyncLiveQueryCallback): MailSessionWatchAccountsAsyncResult
    
    suspend fun `watchFeatureFlags`(`callback`: LiveQueryCallback): MailSessionWatchFeatureFlagsResult
    
    suspend fun `watchFeatureFlagsAsync`(`callback`: AsyncLiveQueryCallback): MailSessionWatchFeatureFlagsAsyncResult
    
    suspend fun `watchSessions`(`callback`: LiveQueryCallback): MailSessionWatchSessionsResult
    
    suspend fun `watchSessionsAsync`(`callback`: AsyncLiveQueryCallback): MailSessionWatchSessionsAsyncResult
    
    companion object
}

open class MailSession: Disposable, AutoCloseable, MailSessionInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_mailsession(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_mailsession(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `appProtection`() : MailSessionAppProtectionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_app_protection(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionAppProtectionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Mark biometrics check as passed.
     *
     * This method is used to mark that the biometrics check has been passed
     * for autolock to reset the timer.

     */override fun `biometricsCheckPassed`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_biometrics_check_passed(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `changeAppSettings`(`settings`: AppSettingsDiff) : MailSessionChangeAppSettingsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_change_app_settings(
                thisPtr,
                FfiConverterTypeAppSettingsDiff.lower(`settings`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionChangeAppSettingsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `deleteAccount`(`userId`: kotlin.String) : VoidSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_delete_account(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Delete stored PIN
     *
     * This method also carries verification of the PIN to remove, that is why
     * it returns PinAuthError type. If verification is unsuccessful it won't
     * remove the PIN and return proper Error Reason.

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `deletePinCode`(`pin`: List<kotlin.UInt>) : MailSessionDeletePinCodeResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_delete_pin_code(
                thisPtr,
                FfiConverterSequenceUInt.lower(`pin`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionDeletePinCodeResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `executeNotificationQuickAction`(`session`: StoredSession, `action`: PushNotificationQuickAction, `timeLeftMs`: kotlin.ULong?) : VoidActionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_execute_notification_quick_action(
                thisPtr,
                FfiConverterTypeStoredSession.lower(`session`),FfiConverterTypePushNotificationQuickAction.lower(`action`),FfiConverterOptionalULong.lower(`timeLeftMs`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Export all logs into a single file wih the given `file_path`
     *
     * Returns the number of bytes written.
     */override fun `exportLogs`(`filePath`: kotlin.String): MailSessionExportLogsResult {
            return FfiConverterTypeMailSessionExportLogsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_export_logs(
        it, FfiConverterString.lower(`filePath`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAccount`(`userId`: kotlin.String) : MailSessionGetAccountResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_account(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetAccountResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getAccountBlocking`(`userId`: kotlin.String): MailSessionGetAccountResult {
            return FfiConverterTypeMailSessionGetAccountResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_blocking(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAccountSessions`(`account`: StoredAccount) : MailSessionGetAccountSessionsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_sessions(
                thisPtr,
                FfiConverterTypeStoredAccount.lower(`account`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetAccountSessionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAccountState`(`userId`: kotlin.String) : MailSessionGetAccountStateResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_state(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetAccountStateResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getAccountStateBlocking`(`userId`: kotlin.String): MailSessionGetAccountStateResult {
            return FfiConverterTypeMailSessionGetAccountStateResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_account_state_blocking(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAccounts`() : MailSessionGetAccountsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_accounts(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetAccountsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getAccountsBlocking`(): MailSessionGetAccountsResult {
            return FfiConverterTypeMailSessionGetAccountsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_accounts_blocking(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAppSettings`() : MailSessionGetAppSettingsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_app_settings(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetAppSettingsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPrimaryAccount`() : MailSessionGetPrimaryAccountResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_primary_account(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetPrimaryAccountResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getPrimaryAccountBlocking`(): MailSessionGetPrimaryAccountResult {
            return FfiConverterTypeMailSessionGetPrimaryAccountResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_primary_account_blocking(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getSession`(`sessionId`: kotlin.String) : MailSessionGetSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_session(
                thisPtr,
                FfiConverterString.lower(`sessionId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getSessionBlocking`(`sessionId`: kotlin.String): MailSessionGetSessionResult {
            return FfiConverterTypeMailSessionGetSessionResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_blocking(
        it, FfiConverterString.lower(`sessionId`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getSessionState`(`sessionId`: kotlin.String) : MailSessionGetSessionStateResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_state(
                thisPtr,
                FfiConverterString.lower(`sessionId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetSessionStateResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getSessionStateBlocking`(`sessionId`: kotlin.String): MailSessionGetSessionStateResult {
            return FfiConverterTypeMailSessionGetSessionStateResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_session_state_blocking(
        it, FfiConverterString.lower(`sessionId`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getSessions`() : MailSessionGetSessionsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_sessions(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionGetSessionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `getSessionsBlocking`(`account`: StoredAccount): MailSessionGetAccountSessionsResult {
            return FfiConverterTypeMailSessionGetAccountSessionsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_get_sessions_blocking(
        it, FfiConverterTypeStoredAccount.lower(`account`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `initializedUserSessionFromStoredSession`(`session`: StoredSession) : MailSessionInitializedUserSessionFromStoredSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_initialized_user_session_from_stored_session(
                thisPtr,
                FfiConverterTypeStoredSession.lower(`session`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionInitializedUserSessionFromStoredSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Is the Unleash feature enabled. Only returns **global** feature flags.
     *
     * These flags are not refreshed if there is an active user session.
     * Use [`MailUserSession::is_feature_enabled`] whenever it is possible.
     *
     * Currently:
     * * Returns None if feature is was never present
     * * Returns Some(true) if feature is present
     * * Returns Some(false) if feature was present and enabled but got disabled
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isFeatureEnabled`(`featureId`: kotlin.String) : MailSessionIsFeatureEnabledResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_is_feature_enabled(
                thisPtr,
                FfiConverterString.lower(`featureId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionIsFeatureEnabledResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `logoutAccount`(`userId`: kotlin.String) : VoidSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_logout_account(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `newLoginFlow`() : MailSessionNewLoginFlowResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_new_login_flow(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionNewLoginFlowResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `newSignupFlow`() : MailSessionNewSignupFlowResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_new_signup_flow(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionNewSignupFlowResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `onEnterForeground`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_on_enter_foreground(
        it, _status)
}
    }
    
    

    override fun `onExitForeground`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_on_exit_foreground(
        it, _status)
}
    }
    
    

    
    /**
     * Spawns new background task responsible for registering device for the push notification.
     * That task will automatically watch for new sessions and register them with latest known device
     * token.
     *
     * In order to provide device registration details, this function returns an object [`RegisterDeviceTaskHandle`]
     * that has a method [`RegisterDeviceTaskHandle::update_device`].

     */override fun `registerDeviceTask`(): MailSessionRegisterDeviceTaskResult {
            return FfiConverterTypeMailSessionRegisterDeviceTaskResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_register_device_task(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Return remaining attempts at verifing PIN code.
     *
     * Method will return None when PIN protection is not set.
     * Method will return Some(value) when PIN protection is in use.

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `remainingPinAttempts`() : MailSessionRemainingPinAttemptsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_remaining_pin_attempts(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionRemainingPinAttemptsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resumeLoginFlow`(`userId`: kotlin.String, `sessionId`: kotlin.String) : MailSessionResumeLoginFlowResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_resume_login_flow(
                thisPtr,
                FfiConverterString.lower(`userId`),FfiConverterString.lower(`sessionId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionResumeLoginFlowResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setBiometricsAppProtection`() : MailSessionSetBiometricsAppProtectionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_set_biometrics_app_protection(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionSetBiometricsAppProtectionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setPinCode`(`pin`: List<kotlin.UInt>) : MailSessionSetPinCodeResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_set_pin_code(
                thisPtr,
                FfiConverterSequenceUInt.lower(`pin`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionSetPinCodeResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setPrimaryAccount`(`userId`: kotlin.String) : VoidSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_set_primary_account(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Should invoke app lock according to app settings.
     *
     * Method will update itself to new access time when returning `true`,
     * It assumes client will invoke the app protection by themself

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `shouldAutoLock`() : MailSessionShouldAutoLockResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_should_auto_lock(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionShouldAutoLockResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Sing out from all accounts.
     *
     * This method is going to remove all user data & account data
     * associated with the mail application.
     *
     * This method is meant to be used when someone decides to sign out on
     * authentication screen such as PIN or Biometrics verification.
     *
     * This method will recover an empty state of the mail application ready to
     * log user back in.

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `signOutAll`() : MailSessionSignOutAllResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_sign_out_all(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionSignOutAllResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Start the auto lock countdown.
     *
     * This method is meant to be used when app is about to be put in the background.
     * It will start the auto lock countdown and will be used to determine if the app
     * spent enough time in the background to be locked.

     */override fun `startAutoLockCountdown`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_start_auto_lock_countdown(
        it, _status)
}
    }
    
    

    
    /**
     * Functionality to execute pending actions for all logged in accounts in controlled manner.
     *
     * This method is meant to be executed when putting application to sleep or running it in the background.
     *
     * It will stop when aborted or when finished whatever comes first.
     * On exit the callback will be triggered to notify caller that it finished.
     *
     * A default time out of 30 seconds is assigned to this method, for more control use
     * [`start_background_execution_with_duration`].
     */override fun `startBackgroundExecution`(`callback`: BackgroundExecutionCallback): MailSessionStartBackgroundExecutionResult {
            return FfiConverterTypeMailSessionStartBackgroundExecutionResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_start_background_execution(
        it, FfiConverterTypeBackgroundExecutionCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    
    /**
     * Same as [`start_background_execution`] but an optional `duration_seconds` can be specified.
     *
     * Note that the duration is the maximum time we will wait for either the background work
     * to finish or the abort handle to be called. We can still  spend some time after that
     * waiting for task completion.
     */override fun `startBackgroundExecutionWithDuration`(`durationSeconds`: kotlin.ULong, `callback`: BackgroundExecutionCallback): MailSessionStartBackgroundExecutionWithDurationResult {
            return FfiConverterTypeMailSessionStartBackgroundExecutionWithDurationResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_start_background_execution_with_duration(
        it, FfiConverterULong.lower(`durationSeconds`),FfiConverterTypeBackgroundExecutionCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    
    /**
     * Converts this session into a [`MailUserSession`] for the primary user.
     *
     * This is meant to be used only within extensions - in particular, it
     * assumes that the primary user is already logged in.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `toPrimaryUserSession`() : MailSessionToPrimaryUserSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_to_primary_user_session(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionToPrimaryUserSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `toUserSession`(`ffiFlow`: LoginFlow) : MailSessionToUserSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_to_user_session(
                thisPtr,
                FfiConverterTypeLoginFlow.lower(`ffiFlow`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionToUserSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unsetBiometricsAppProtection`() : MailSessionUnsetBiometricsAppProtectionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_unset_biometrics_app_protection(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionUnsetBiometricsAppProtectionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `updateOsNetworkStatus`(`osNetworkStatus`: OsNetworkStatus)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_update_os_network_status(
        it, FfiConverterTypeOsNetworkStatus.lower(`osNetworkStatus`),_status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `userSessionFromStoredSession`(`session`: StoredSession) : MailSessionUserSessionFromStoredSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_user_session_from_stored_session(
                thisPtr,
                FfiConverterTypeStoredSession.lower(`session`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionUserSessionFromStoredSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `verifyPinCode`(`pin`: List<kotlin.UInt>) : MailSessionVerifyPinCodeResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_verify_pin_code(
                thisPtr,
                FfiConverterSequenceUInt.lower(`pin`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionVerifyPinCodeResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchAccountSessions`(`account`: StoredAccount, `callback`: LiveQueryCallback) : MailSessionWatchAccountSessionsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_account_sessions(
                thisPtr,
                FfiConverterTypeStoredAccount.lower(`account`),FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchAccountSessionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchAccounts`(`callback`: LiveQueryCallback) : MailSessionWatchAccountsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_accounts(
                thisPtr,
                FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchAccountsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchAccountsAsync`(`callback`: AsyncLiveQueryCallback) : MailSessionWatchAccountsAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_accounts_async(
                thisPtr,
                FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchAccountsAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchFeatureFlags`(`callback`: LiveQueryCallback) : MailSessionWatchFeatureFlagsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_feature_flags(
                thisPtr,
                FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchFeatureFlagsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchFeatureFlagsAsync`(`callback`: AsyncLiveQueryCallback) : MailSessionWatchFeatureFlagsAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_feature_flags_async(
                thisPtr,
                FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchFeatureFlagsAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchSessions`(`callback`: LiveQueryCallback) : MailSessionWatchSessionsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_sessions(
                thisPtr,
                FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchSessionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchSessionsAsync`(`callback`: AsyncLiveQueryCallback) : MailSessionWatchSessionsAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailsession_watch_sessions_async(
                thisPtr,
                FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSessionWatchSessionsAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSession: FfiConverter<MailSession, Pointer> {

    override fun lower(value: MailSession): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MailSession {
        return MailSession(value)
    }

    override fun read(buf: ByteBuffer): MailSession {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MailSession) = 8UL

    override fun write(value: MailSession, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MailUserSessionInterface {
    
    suspend fun `accountDetails`(): MailUserSessionAccountDetailsResult
    
    /**
     * Return the list of labels of type Label that can be applied to conversations or
     * messages.
     */
    suspend fun `applicableLabels`(): MailUserSessionApplicableLabelsResult
    
    suspend fun `connectionStatus`(): MailUserSessionConnectionStatusResult
    
    /**
     * Execute callback when connection status is online
     *
     * The method will execute callback immediately when current status is online
     * otherwise it will wait till the status is online again and then execute callback

     */
    fun `executeWhenOnline`(`callback`: ExecuteWhenOnlineCallback)
    
    /**
     * Execute callback when connection status is online
     *
     * The method will execute callback immediately when current status is online
     * otherwise it will wait till the status is online again and then execute callback

     */
    fun `executeWhenOnlineAsync`(`callback`: ExecuteWhenOnlineCallbackAsync)
    
    /**
     * Queue an event loop poll action regardless of polling mode.
     *
     * # Errors
     *
     * Errors returned here are only related to queuing of the action. To get information
     * about the event loop execution, please use [`MailUserSession::observe_event_loop_errors`].
     */
    suspend fun `forceEventLoopPoll`(): VoidEventResult
    
    suspend fun `forceEventLoopPollAndWait`(): VoidEventResult
    
    /**
     * Fork the current session for a child with the given platform and product.
     *
     * This call has to be made from a parent session, and forks the current
     * logged-in user session in order to provide a new session for the same
     * user.
     *
     * If successful, this will return the "Selector" string for the new
     * session. The child must present an app version that matches the platform
     * and product.

     */
    suspend fun `fork`(`platform`: kotlin.String, `product`: kotlin.String): MailUserSessionForkResult
    
    suspend fun `getAttachment`(`localAttachmentId`: Id): MailUserSessionGetAttachmentResult
    
    suspend fun `getPaymentMethod`(`id`: kotlin.String): MailUserSessionGetPaymentMethodResult
    
    suspend fun `getPaymentsPlans`(`options`: GetPaymentsPlansOptions): MailUserSessionGetPaymentsPlansResult
    
    suspend fun `getPaymentsResourcesIcons`(`name`: kotlin.String): MailUserSessionGetPaymentsResourcesIconsResult
    
    suspend fun `getPaymentsStatus`(`vendor`: kotlin.String): MailUserSessionGetPaymentsStatusResult
    
    suspend fun `getPaymentsSubscription`(): MailUserSessionGetPaymentsSubscriptionResult
    
    suspend fun `hasValidSenderAddress`(): MailUserSessionHasValidSenderAddressResult
    
    /**
     * Get a path to the sender image.
     *
     * # Parameters
     * * `address`: Email address of the sender.
     * * `bimi_selector`: BIMI protocol selector.
     * * `display_sender_image`: Whether this sender would has sender image enabled.
     * * `size`: Is used to give the x*x size of the returned image (will default to 32 if none provided).
     * * `mode`: Can be used to select if the "light" or "dark" mode of the image is desired (default is light).
     * * `format`: Desired image format, if none is specified the default format of the image will be used.
     *
     * Returns a path toward the image file or `None` if no image needs to be displayed.
     */
    suspend fun `imageForSender`(`address`: kotlin.String, `bimiSelector`: kotlin.String?, `displaySenderImage`: kotlin.Boolean, `size`: kotlin.UInt?, `mode`: kotlin.String?, `format`: kotlin.String?): MailUserSessionImageForSenderResult
    
    /**
     * Is the Unleash OR legacy feature enabled. Returns not only global feature flags,
     * but also user-specific ones.
     *
     * If you don't have an active user session, use [`MailSession::is_feature_enabled`] instead.
     *
     * Currently:
     * * Returns None if feature is not found
     * * Returns Some(true) if feature is enabled (or present in case of Unleash)
     * * Returns Some(false) if feature is disabled (only legacy, Unleash returns None in that case)
     *
     * If there are two features with the same id, coming from unleash and legacy, unleash takes the precedence.
     */
    suspend fun `isFeatureEnabled`(`featureId`: kotlin.String): MailUserSessionIsFeatureEnabledResult
    
    /**
     * Log out a session and delete all user data.
     */
    suspend fun `logout`(): VoidSessionResult
    
    /**
     * Return the list of labels of type Folder into which a conversations or
     * message can be moved.
     */
    suspend fun `movableFolders`(): MailUserSessionMovableFoldersResult
    
    suspend fun `newPasswordChangeFlow`(): MailUserSessionNewPasswordChangeFlowResult
    
    /**
     * Observe event loop errors.
     *
     * When an error occurs the `callback` is invoked.
     *
     * This method returns an [`EventLoopErrorObserverHandle`] which needs to be kept
     * alive. Once the handle is disconnected or dropped, the `callback` is removed.
     */
    fun `observeEventLoopErrors`(`callback`: EventLoopErrorObserver): MailUserSessionObserveEventLoopErrorsResult
    
    /**
     * Fails if:
     * * Feature is missing
     * * Feature is not writable
     * * All Unleash flags are not writable.
     */
    suspend fun `overrideUserFeatureFlag`(`flagName`: kotlin.String, `newValue`: kotlin.Boolean): MailUserSessionOverrideUserFeatureFlagResult
    
    fun `passwordValidator`(): PasswordValidatorService?
    
    suspend fun `postPaymentsSubscription`(`subscription`: NewSubscription, `newValues`: NewSubscriptionValues): MailUserSessionPostPaymentsSubscriptionResult
    
    suspend fun `postPaymentsTokens`(`amount`: kotlin.ULong, `currency`: kotlin.String, `payment`: PaymentReceipt): MailUserSessionPostPaymentsTokensResult
    
    /**
     * Processes a QR code from a Target Device to initiate a secure session fork.
     *
     * This function parses the provided QR code, retrieves the current device's session passphrase,
     * optionally encrypts it using the encryption key from the QR code, and sends a fork confirmation
     * to the Target Device.
     */
    suspend fun `processTargetDeviceQrCode`(`qrCode`: kotlin.String): MailUserSessionProcessTargetDeviceQrCodeResult
    
    fun `sessionId`(): MailUserSessionSessionIdResult
    
    suspend fun `sessionUuid`(): MailUserSessionSessionUuidResult
    
    suspend fun `upsellEligibility`(): MailUserSessionUpsellEligibilityResult
    
    suspend fun `user`(): MailUserSessionUserResult
    
    fun `userId`(): MailUserSessionUserIdResult
    
    suspend fun `userSettings`(): MailUserSessionUserSettingsResult
    
    fun `watchAddresses`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchAddressesResult
    
    fun `watchFeatureFlagsStream`(): MailUserSessionWatchFeatureFlagsStreamResult
    
    fun `watchUpsellEligibility`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUpsellEligibilityResult
    
    fun `watchUser`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUserResult
    
    fun `watchUserSettings`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUserSettingsResult
    
    fun `watchUserStream`(): MailUserSessionWatchUserStreamResult
    
    companion object
}

open class MailUserSession: Disposable, AutoCloseable, MailUserSessionInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_mailusersession(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_mailusersession(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `accountDetails`() : MailUserSessionAccountDetailsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_account_details(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionAccountDetailsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Return the list of labels of type Label that can be applied to conversations or
     * messages.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `applicableLabels`() : MailUserSessionApplicableLabelsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_applicable_labels(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionApplicableLabelsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `connectionStatus`() : MailUserSessionConnectionStatusResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_connection_status(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionConnectionStatusResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Execute callback when connection status is online
     *
     * The method will execute callback immediately when current status is online
     * otherwise it will wait till the status is online again and then execute callback

     */override fun `executeWhenOnline`(`callback`: ExecuteWhenOnlineCallback)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_execute_when_online(
        it, FfiConverterTypeExecuteWhenOnlineCallback.lower(`callback`),_status)
}
    }
    
    

    
    /**
     * Execute callback when connection status is online
     *
     * The method will execute callback immediately when current status is online
     * otherwise it will wait till the status is online again and then execute callback

     */override fun `executeWhenOnlineAsync`(`callback`: ExecuteWhenOnlineCallbackAsync)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_execute_when_online_async(
        it, FfiConverterTypeExecuteWhenOnlineCallbackAsync.lower(`callback`),_status)
}
    }
    
    

    
    /**
     * Queue an event loop poll action regardless of polling mode.
     *
     * # Errors
     *
     * Errors returned here are only related to queuing of the action. To get information
     * about the event loop execution, please use [`MailUserSession::observe_event_loop_errors`].
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forceEventLoopPoll`() : VoidEventResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_force_event_loop_poll(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidEventResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forceEventLoopPollAndWait`() : VoidEventResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_force_event_loop_poll_and_wait(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidEventResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Fork the current session for a child with the given platform and product.
     *
     * This call has to be made from a parent session, and forks the current
     * logged-in user session in order to provide a new session for the same
     * user.
     *
     * If successful, this will return the "Selector" string for the new
     * session. The child must present an app version that matches the platform
     * and product.

     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fork`(`platform`: kotlin.String, `product`: kotlin.String) : MailUserSessionForkResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_fork(
                thisPtr,
                FfiConverterString.lower(`platform`),FfiConverterString.lower(`product`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionForkResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAttachment`(`localAttachmentId`: Id) : MailUserSessionGetAttachmentResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_attachment(
                thisPtr,
                FfiConverterTypeId.lower(`localAttachmentId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetAttachmentResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPaymentMethod`(`id`: kotlin.String) : MailUserSessionGetPaymentMethodResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payment_method(
                thisPtr,
                FfiConverterString.lower(`id`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetPaymentMethodResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPaymentsPlans`(`options`: GetPaymentsPlansOptions) : MailUserSessionGetPaymentsPlansResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_plans(
                thisPtr,
                FfiConverterTypeGetPaymentsPlansOptions.lower(`options`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetPaymentsPlansResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPaymentsResourcesIcons`(`name`: kotlin.String) : MailUserSessionGetPaymentsResourcesIconsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_resources_icons(
                thisPtr,
                FfiConverterString.lower(`name`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetPaymentsResourcesIconsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPaymentsStatus`(`vendor`: kotlin.String) : MailUserSessionGetPaymentsStatusResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_status(
                thisPtr,
                FfiConverterString.lower(`vendor`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetPaymentsStatusResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPaymentsSubscription`() : MailUserSessionGetPaymentsSubscriptionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_get_payments_subscription(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionGetPaymentsSubscriptionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `hasValidSenderAddress`() : MailUserSessionHasValidSenderAddressResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_has_valid_sender_address(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionHasValidSenderAddressResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get a path to the sender image.
     *
     * # Parameters
     * * `address`: Email address of the sender.
     * * `bimi_selector`: BIMI protocol selector.
     * * `display_sender_image`: Whether this sender would has sender image enabled.
     * * `size`: Is used to give the x*x size of the returned image (will default to 32 if none provided).
     * * `mode`: Can be used to select if the "light" or "dark" mode of the image is desired (default is light).
     * * `format`: Desired image format, if none is specified the default format of the image will be used.
     *
     * Returns a path toward the image file or `None` if no image needs to be displayed.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `imageForSender`(`address`: kotlin.String, `bimiSelector`: kotlin.String?, `displaySenderImage`: kotlin.Boolean, `size`: kotlin.UInt?, `mode`: kotlin.String?, `format`: kotlin.String?) : MailUserSessionImageForSenderResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_image_for_sender(
                thisPtr,
                FfiConverterString.lower(`address`),FfiConverterOptionalString.lower(`bimiSelector`),FfiConverterBoolean.lower(`displaySenderImage`),FfiConverterOptionalUInt.lower(`size`),FfiConverterOptionalString.lower(`mode`),FfiConverterOptionalString.lower(`format`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionImageForSenderResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Is the Unleash OR legacy feature enabled. Returns not only global feature flags,
     * but also user-specific ones.
     *
     * If you don't have an active user session, use [`MailSession::is_feature_enabled`] instead.
     *
     * Currently:
     * * Returns None if feature is not found
     * * Returns Some(true) if feature is enabled (or present in case of Unleash)
     * * Returns Some(false) if feature is disabled (only legacy, Unleash returns None in that case)
     *
     * If there are two features with the same id, coming from unleash and legacy, unleash takes the precedence.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isFeatureEnabled`(`featureId`: kotlin.String) : MailUserSessionIsFeatureEnabledResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_is_feature_enabled(
                thisPtr,
                FfiConverterString.lower(`featureId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionIsFeatureEnabledResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Log out a session and delete all user data.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `logout`() : VoidSessionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_logout(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Return the list of labels of type Folder into which a conversations or
     * message can be moved.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `movableFolders`() : MailUserSessionMovableFoldersResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_movable_folders(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionMovableFoldersResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `newPasswordChangeFlow`() : MailUserSessionNewPasswordChangeFlowResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_new_password_change_flow(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionNewPasswordChangeFlowResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Observe event loop errors.
     *
     * When an error occurs the `callback` is invoked.
     *
     * This method returns an [`EventLoopErrorObserverHandle`] which needs to be kept
     * alive. Once the handle is disconnected or dropped, the `callback` is removed.
     */override fun `observeEventLoopErrors`(`callback`: EventLoopErrorObserver): MailUserSessionObserveEventLoopErrorsResult {
            return FfiConverterTypeMailUserSessionObserveEventLoopErrorsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_observe_event_loop_errors(
        it, FfiConverterTypeEventLoopErrorObserver.lower(`callback`),_status)
}
    }
    )
    }
    

    
    /**
     * Fails if:
     * * Feature is missing
     * * Feature is not writable
     * * All Unleash flags are not writable.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `overrideUserFeatureFlag`(`flagName`: kotlin.String, `newValue`: kotlin.Boolean) : MailUserSessionOverrideUserFeatureFlagResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_override_user_feature_flag(
                thisPtr,
                FfiConverterString.lower(`flagName`),FfiConverterBoolean.lower(`newValue`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionOverrideUserFeatureFlagResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `passwordValidator`(): PasswordValidatorService? {
            return FfiConverterOptionalTypePasswordValidatorService.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_password_validator(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `postPaymentsSubscription`(`subscription`: NewSubscription, `newValues`: NewSubscriptionValues) : MailUserSessionPostPaymentsSubscriptionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_post_payments_subscription(
                thisPtr,
                FfiConverterTypeNewSubscription.lower(`subscription`),FfiConverterTypeNewSubscriptionValues.lower(`newValues`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionPostPaymentsSubscriptionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `postPaymentsTokens`(`amount`: kotlin.ULong, `currency`: kotlin.String, `payment`: PaymentReceipt) : MailUserSessionPostPaymentsTokensResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_post_payments_tokens(
                thisPtr,
                FfiConverterULong.lower(`amount`),FfiConverterString.lower(`currency`),FfiConverterTypePaymentReceipt.lower(`payment`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionPostPaymentsTokensResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Processes a QR code from a Target Device to initiate a secure session fork.
     *
     * This function parses the provided QR code, retrieves the current device's session passphrase,
     * optionally encrypts it using the encryption key from the QR code, and sends a fork confirmation
     * to the Target Device.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `processTargetDeviceQrCode`(`qrCode`: kotlin.String) : MailUserSessionProcessTargetDeviceQrCodeResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_process_target_device_qr_code(
                thisPtr,
                FfiConverterString.lower(`qrCode`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionProcessTargetDeviceQrCodeResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `sessionId`(): MailUserSessionSessionIdResult {
            return FfiConverterTypeMailUserSessionSessionIdResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_session_id(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sessionUuid`() : MailUserSessionSessionUuidResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_session_uuid(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionSessionUuidResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `upsellEligibility`() : MailUserSessionUpsellEligibilityResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_upsell_eligibility(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionUpsellEligibilityResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `user`() : MailUserSessionUserResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_user(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionUserResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `userId`(): MailUserSessionUserIdResult {
            return FfiConverterTypeMailUserSessionUserIdResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_user_id(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `userSettings`() : MailUserSessionUserSettingsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_user_settings(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailUserSessionUserSettingsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `watchAddresses`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchAddressesResult {
            return FfiConverterTypeMailUserSessionWatchAddressesResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_addresses(
        it, FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    override fun `watchFeatureFlagsStream`(): MailUserSessionWatchFeatureFlagsStreamResult {
            return FfiConverterTypeMailUserSessionWatchFeatureFlagsStreamResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_feature_flags_stream(
        it, _status)
}
    }
    )
    }
    

    override fun `watchUpsellEligibility`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUpsellEligibilityResult {
            return FfiConverterTypeMailUserSessionWatchUpsellEligibilityResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_upsell_eligibility(
        it, FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    override fun `watchUser`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUserResult {
            return FfiConverterTypeMailUserSessionWatchUserResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user(
        it, FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    override fun `watchUserSettings`(`callback`: AsyncLiveQueryCallback): MailUserSessionWatchUserSettingsResult {
            return FfiConverterTypeMailUserSessionWatchUserSettingsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user_settings(
        it, FfiConverterTypeAsyncLiveQueryCallback.lower(`callback`),_status)
}
    }
    )
    }
    

    override fun `watchUserStream`(): MailUserSessionWatchUserStreamResult {
            return FfiConverterTypeMailUserSessionWatchUserStreamResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailusersession_watch_user_stream(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSession: FfiConverter<MailUserSession, Pointer> {

    override fun lower(value: MailUserSession): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MailUserSession {
        return MailUserSession(value)
    }

    override fun read(buf: ByteBuffer): MailUserSession {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MailUserSession) = 8UL

    override fun write(value: MailUserSession, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MailboxInterface {
    
    /**
     * Loads the metadata and file path for the given local [`attachment_id`]
     * into a [`DecryptedAttachment`].
     *
     * If the attachment is not present on the device it is retrieved from
     * the server, decrypted and stored in the cache.
     *
     * Additionally, attempts to verify any attached signatures with the
     * sender's keys. The result can be accessed via the [`VerificationResult`]
     * result return type.
     *
     * # Warning
     *
     * Signature verification is currently always failing since no sender keys
     * are fetched yet.
     *
     * # Errors
     *
     * Returns an error if the encrypted attachment fetching or decryption fails.
     * Signature verification failures are not returned as errors.
     */
    suspend fun `getAttachment`(`localAttachmentId`: Id): MailboxGetAttachmentResult
    
    fun `labelId`(): Id
    
    fun `recipientDisplayMode`(): MessageRecipientDisplayMode
    
    suspend fun `unreadCount`(): MailboxUnreadCountResult
    
    fun `viewMode`(): ViewMode
    
    suspend fun `watchUnreadCount`(`callback`: LiveQueryCallback): MailboxWatchUnreadCountResult
    
    companion object
}

open class Mailbox: Disposable, AutoCloseable, MailboxInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_mailbox(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_mailbox(pointer!!, status)
        }
    }

    
    /**
     * Loads the metadata and file path for the given local [`attachment_id`]
     * into a [`DecryptedAttachment`].
     *
     * If the attachment is not present on the device it is retrieved from
     * the server, decrypted and stored in the cache.
     *
     * Additionally, attempts to verify any attached signatures with the
     * sender's keys. The result can be accessed via the [`VerificationResult`]
     * result return type.
     *
     * # Warning
     *
     * Signature verification is currently always failing since no sender keys
     * are fetched yet.
     *
     * # Errors
     *
     * Returns an error if the encrypted attachment fetching or decryption fails.
     * Signature verification failures are not returned as errors.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAttachment`(`localAttachmentId`: Id) : MailboxGetAttachmentResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_get_attachment(
                thisPtr,
                FfiConverterTypeId.lower(`localAttachmentId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailboxGetAttachmentResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `labelId`(): Id {
            return FfiConverterTypeId.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_label_id(
        it, _status)
}
    }
    )
    }
    

    override fun `recipientDisplayMode`(): MessageRecipientDisplayMode {
            return FfiConverterTypeMessageRecipientDisplayMode.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_recipient_display_mode(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unreadCount`() : MailboxUnreadCountResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_unread_count(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailboxUnreadCountResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `viewMode`(): ViewMode {
            return FfiConverterTypeViewMode.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_view_mode(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchUnreadCount`(`callback`: LiveQueryCallback) : MailboxWatchUnreadCountResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_mailbox_watch_unread_count(
                thisPtr,
                FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailboxWatchUnreadCountResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMailbox: FfiConverter<Mailbox, Pointer> {

    override fun lower(value: Mailbox): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Mailbox {
        return Mailbox(value)
    }

    override fun read(buf: ByteBuffer): Mailbox {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Mailbox) = 8UL

    override fun write(value: Mailbox, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MessageScrollerInterface {
    
    /**
     * Changes the filter of the scroller.
     */
    fun `changeFilter`(`unread`: ReadFilter): MessageScrollerChangeFilterResult
    
    fun `changeInclude`(`include`: IncludeSwitch): MessageScrollerChangeIncludeResult
    
    suspend fun `cursor`(`lookingAt`: Id): MessageScrollerCursorResult
    
    /**
     * Moves to the next page and retrieves its results.
     */
    fun `fetchMore`(): MessageScrollerFetchMoreResult
    
    /**
     * Tries to fetch the newest items.
     */
    fun `fetchNew`(): MessageScrollerFetchNewResult
    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */
    fun `forceRefresh`(): MessageScrollerForceRefreshResult
    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */
    fun `getItems`(): MessageScrollerGetItemsResult
    
    fun `handle`(): WatchHandle
    
    suspend fun `hasMore`(): MessageScrollerHasMoreResult
    
    /**
     * Returns the unique identifier for this scroller instance.
     */
    fun `id`(): kotlin.String
    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */
    fun `refresh`(): MessageScrollerRefreshResult
    
    suspend fun `supportsIncludeFilter`(): MessageScrollerSupportsIncludeFilterResult
    
    fun `terminate`()
    
    suspend fun `total`(): MessageScrollerTotalResult
    
    companion object
}

open class MessageScroller: Disposable, AutoCloseable, MessageScrollerInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_messagescroller(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_messagescroller(pointer!!, status)
        }
    }

    
    /**
     * Changes the filter of the scroller.
     */override fun `changeFilter`(`unread`: ReadFilter): MessageScrollerChangeFilterResult {
            return FfiConverterTypeMessageScrollerChangeFilterResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_change_filter(
        it, FfiConverterTypeReadFilter.lower(`unread`),_status)
}
    }
    )
    }
    

    override fun `changeInclude`(`include`: IncludeSwitch): MessageScrollerChangeIncludeResult {
            return FfiConverterTypeMessageScrollerChangeIncludeResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_change_include(
        it, FfiConverterTypeIncludeSwitch.lower(`include`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cursor`(`lookingAt`: Id) : MessageScrollerCursorResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_cursor(
                thisPtr,
                FfiConverterTypeId.lower(`lookingAt`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMessageScrollerCursorResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Moves to the next page and retrieves its results.
     */override fun `fetchMore`(): MessageScrollerFetchMoreResult {
            return FfiConverterTypeMessageScrollerFetchMoreResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_fetch_more(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Tries to fetch the newest items.
     */override fun `fetchNew`(): MessageScrollerFetchNewResult {
            return FfiConverterTypeMessageScrollerFetchNewResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_fetch_new(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */override fun `forceRefresh`(): MessageScrollerForceRefreshResult {
            return FfiConverterTypeMessageScrollerForceRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_force_refresh(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */override fun `getItems`(): MessageScrollerGetItemsResult {
            return FfiConverterTypeMessageScrollerGetItemsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_get_items(
        it, _status)
}
    }
    )
    }
    

    override fun `handle`(): WatchHandle {
            return FfiConverterTypeWatchHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_handle(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `hasMore`() : MessageScrollerHasMoreResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_has_more(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMessageScrollerHasMoreResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns the unique identifier for this scroller instance.
     */override fun `id`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */override fun `refresh`(): MessageScrollerRefreshResult {
            return FfiConverterTypeMessageScrollerRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_refresh(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `supportsIncludeFilter`() : MessageScrollerSupportsIncludeFilterResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_supports_include_filter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMessageScrollerSupportsIncludeFilterResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `terminate`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_terminate(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `total`() : MessageScrollerTotalResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_messagescroller_total(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMessageScrollerTotalResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScroller: FfiConverter<MessageScroller, Pointer> {

    override fun lower(value: MessageScroller): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MessageScroller {
        return MessageScroller(value)
    }

    override fun read(buf: ByteBuffer): MessageScroller {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MessageScroller) = 8UL

    override fun write(value: MessageScroller, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A handle to a background task responsible for registering devices.
 * Keep it in memory for as long as you wish to have registration.
 * It will abort the background task on drop.
 *
 * Additionally, in order to provide device registration details,
 * this handle provides a method, [`Self::update_device`].

 */
public interface RegisterDeviceTaskHandleInterface {
    
    fun `updateDevice`(`device`: RegisteredDevice): VoidActionResult
    
    companion object
}

/**
 * A handle to a background task responsible for registering devices.
 * Keep it in memory for as long as you wish to have registration.
 * It will abort the background task on drop.
 *
 * Additionally, in order to provide device registration details,
 * this handle provides a method, [`Self::update_device`].

 */
open class RegisterDeviceTaskHandle: Disposable, AutoCloseable, RegisterDeviceTaskHandleInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_registerdevicetaskhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_registerdevicetaskhandle(pointer!!, status)
        }
    }

    override fun `updateDevice`(`device`: RegisteredDevice): VoidActionResult {
            return FfiConverterTypeVoidActionResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_registerdevicetaskhandle_update_device(
        it, FfiConverterTypeRegisteredDevice.lower(`device`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeRegisterDeviceTaskHandle: FfiConverter<RegisterDeviceTaskHandle, Pointer> {

    override fun lower(value: RegisterDeviceTaskHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RegisterDeviceTaskHandle {
        return RegisterDeviceTaskHandle(value)
    }

    override fun read(buf: ByteBuffer): RegisterDeviceTaskHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RegisterDeviceTaskHandle) = 8UL

    override fun write(value: RegisterDeviceTaskHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface Resolver {
    
    /**
     * Resolve the given host to a set of IP addresses.
     */
    suspend fun `resolve`(`host`: kotlin.String): List<IpAddr>?
    
    companion object
}

open class ResolverImpl: Disposable, AutoCloseable, Resolver
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_resolver(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_resolver(pointer!!, status)
        }
    }

    
    /**
     * Resolve the given host to a set of IP addresses.
     */
    @Throws(ResolverException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resolve`(`host`: kotlin.String) : List<IpAddr>? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_resolver_resolve(
                thisPtr,
                FfiConverterString.lower(`host`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalSequenceTypeIpAddr.lift(it) },
        // Error FFI converter
        ResolverException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceResolver {
    internal object `resolve`: UniffiCallbackInterfaceResolverMethod0 {
        override fun callback(`uniffiHandle`: Long,`host`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutReturn`: UniffiForeignFuture,) {
            val uniffiObj = FfiConverterTypeResolver.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`resolve`(
                    FfiConverterString.lift(`host`),
                )
            }
            val uniffiHandleSuccess = { returnValue: List<IpAddr>? ->
                val uniffiResult = UniffiForeignFutureStructRustBuffer.UniffiByValue(
                    FfiConverterOptionalSequenceTypeIpAddr.lower(returnValue),
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer.UniffiByValue(
                        RustBuffer.ByValue(),
                        callStatus,
                    ),
                )
            }

            uniffiOutReturn.uniffiSetValue(
                uniffiTraitInterfaceCallAsyncWithError(
                    makeCall,
                    uniffiHandleSuccess,
                    uniffiHandleError,
                    { e: ResolverException -> FfiConverterTypeResolverError.lower(e) }
                )
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeResolver.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceResolver.UniffiByValue(
        `resolve`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_resolver(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeResolver: FfiConverter<Resolver, Pointer> {
    internal val handleMap = UniffiHandleMap<Resolver>()

    override fun lower(value: Resolver): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): Resolver {
        return ResolverImpl(value)
    }

    override fun read(buf: ByteBuffer): Resolver {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Resolver) = 8UL

    override fun write(value: Resolver, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RsvpEventServiceInterface {
    
    /**
     * Answers this event.
     *
     * After returned `Future` succeeds, call [`Self::details()`] to get an
     * updated event object (with refreshed attendee status).
     */
    suspend fun `answer`(`answer`: RsvpAnswer): VoidAnswerRsvpResult
    
    fun `get`(): RsvpEventGetResult
    
    companion object
}

open class RsvpEventService: Disposable, AutoCloseable, RsvpEventServiceInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_rsvpeventservice(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_rsvpeventservice(pointer!!, status)
        }
    }

    
    /**
     * Answers this event.
     *
     * After returned `Future` succeeds, call [`Self::details()`] to get an
     * updated event object (with refreshed attendee status).
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `answer`(`answer`: RsvpAnswer) : VoidAnswerRsvpResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_rsvpeventservice_answer(
                thisPtr,
                FfiConverterTypeRsvpAnswer.lower(`answer`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidAnswerRsvpResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `get`(): RsvpEventGetResult {
            return FfiConverterTypeRsvpEventGetResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_rsvpeventservice_get(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpEventService: FfiConverter<RsvpEventService, Pointer> {

    override fun lower(value: RsvpEventService): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RsvpEventService {
        return RsvpEventService(value)
    }

    override fun read(buf: ByteBuffer): RsvpEventService {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RsvpEventService) = 8UL

    override fun write(value: RsvpEventService, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RsvpEventServiceProviderInterface {
    
    /**
     * Fetches event details from the API.
     *
     * Note that this might return `None` - this will be the case e.g. for
     * reminders when there's no network connection available (since we need
     * network connection in order to fetch reminder details from the API).
     */
    suspend fun `eventService`(): RsvpEventService?
    
    companion object
}

open class RsvpEventServiceProvider: Disposable, AutoCloseable, RsvpEventServiceProviderInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_rsvpeventserviceprovider(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_rsvpeventserviceprovider(pointer!!, status)
        }
    }

    
    /**
     * Fetches event details from the API.
     *
     * Note that this might return `None` - this will be the case e.g. for
     * reminders when there's no network connection available (since we need
     * network connection in order to fetch reminder details from the API).
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `eventService`() : RsvpEventService? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_rsvpeventserviceprovider_event_service(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRsvpEventService.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpEventServiceProvider: FfiConverter<RsvpEventServiceProvider, Pointer> {

    override fun lower(value: RsvpEventServiceProvider): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RsvpEventServiceProvider {
        return RsvpEventServiceProvider(value)
    }

    override fun read(buf: ByteBuffer): RsvpEventServiceProvider {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RsvpEventServiceProvider) = 8UL

    override fun write(value: RsvpEventServiceProvider, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SearchScrollerInterface {
    
    fun `changeInclude`(`include`: IncludeSwitch): SearchScrollerChangeIncludeResult
    
    fun `changeKeywords`(`keywords`: PaginatorSearchOptions): SearchScrollerChangeKeywordsResult
    
    suspend fun `cursor`(`lookingAt`: Id): SearchScrollerCursorResult
    
    /**
     * Moves to the next page and retrieves its results.
     */
    fun `fetchMore`(): SearchScrollerFetchMoreResult
    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */
    fun `forceRefresh`(): SearchScrollerForceRefreshResult
    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */
    fun `getItems`(): SearchScrollerGetItemsResult
    
    fun `handle`(): WatchHandle
    
    suspend fun `hasMore`(): SearchScrollerHasMoreResult
    
    /**
     * Returns the unique identifier for this scroller instance.
     */
    fun `id`(): kotlin.String
    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */
    fun `refresh`(): SearchScrollerRefreshResult
    
    suspend fun `supportsIncludeFilter`(): SearchScrollerSupportsIncludeFilterResult
    
    fun `terminate`()
    
    suspend fun `total`(): SearchScrollerTotalResult
    
    companion object
}

open class SearchScroller: Disposable, AutoCloseable, SearchScrollerInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_searchscroller(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_searchscroller(pointer!!, status)
        }
    }

    override fun `changeInclude`(`include`: IncludeSwitch): SearchScrollerChangeIncludeResult {
            return FfiConverterTypeSearchScrollerChangeIncludeResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_change_include(
        it, FfiConverterTypeIncludeSwitch.lower(`include`),_status)
}
    }
    )
    }
    

    override fun `changeKeywords`(`keywords`: PaginatorSearchOptions): SearchScrollerChangeKeywordsResult {
            return FfiConverterTypeSearchScrollerChangeKeywordsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_change_keywords(
        it, FfiConverterTypePaginatorSearchOptions.lower(`keywords`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cursor`(`lookingAt`: Id) : SearchScrollerCursorResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_cursor(
                thisPtr,
                FfiConverterTypeId.lower(`lookingAt`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSearchScrollerCursorResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Moves to the next page and retrieves its results.
     */override fun `fetchMore`(): SearchScrollerFetchMoreResult {
            return FfiConverterTypeSearchScrollerFetchMoreResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_fetch_more(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Forces a refresh of the scroller. The callback will receive the full
     * list of items.
     */override fun `forceRefresh`(): SearchScrollerForceRefreshResult {
            return FfiConverterTypeSearchScrollerForceRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_force_refresh(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Retrieves the current items in the scroller, the items will be returned
     * in the callback with the `ReplaceFrom { idx: 0, items }` update.
     */override fun `getItems`(): SearchScrollerGetItemsResult {
            return FfiConverterTypeSearchScrollerGetItemsResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_get_items(
        it, _status)
}
    }
    )
    }
    

    override fun `handle`(): WatchHandle {
            return FfiConverterTypeWatchHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_handle(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `hasMore`() : SearchScrollerHasMoreResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_has_more(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSearchScrollerHasMoreResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns the unique identifier for this scroller instance.
     */override fun `id`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Refreshes the scroller, providing a smallest possible update
     * to the client via the callback.
     */override fun `refresh`(): SearchScrollerRefreshResult {
            return FfiConverterTypeSearchScrollerRefreshResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_refresh(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `supportsIncludeFilter`() : SearchScrollerSupportsIncludeFilterResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_supports_include_filter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSearchScrollerSupportsIncludeFilterResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `terminate`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_terminate(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `total`() : SearchScrollerTotalResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_searchscroller_total(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSearchScrollerTotalResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScroller: FfiConverter<SearchScroller, Pointer> {

    override fun lower(value: SearchScroller): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SearchScroller {
        return SearchScroller(value)
    }

    override fun read(buf: ByteBuffer): SearchScroller {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SearchScroller) = 8UL

    override fun write(value: SearchScroller, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SidebarInterface {
    
    suspend fun `allCustomFolders`(): SidebarAllCustomFoldersResult
    
    suspend fun `collapseFolder`(`localId`: Id): VoidActionResult
    
    suspend fun `customFolders`(): SidebarCustomFoldersResult
    
    suspend fun `customLabels`(): SidebarCustomLabelsResult
    
    suspend fun `expandFolder`(`localId`: Id): VoidActionResult
    
    suspend fun `systemLabels`(): SidebarSystemLabelsResult
    
    suspend fun `watchLabels`(`callback`: LiveQueryCallback): SidebarWatchLabelsResult
    
    companion object
}

open class Sidebar: Disposable, AutoCloseable, SidebarInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor(`session`: MailUserSession) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_constructor_sidebar_new(
        FfiConverterTypeMailUserSession.lower(`session`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_sidebar(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_sidebar(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `allCustomFolders`() : SidebarAllCustomFoldersResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_all_custom_folders(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSidebarAllCustomFoldersResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `collapseFolder`(`localId`: Id) : VoidActionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_collapse_folder(
                thisPtr,
                FfiConverterTypeId.lower(`localId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `customFolders`() : SidebarCustomFoldersResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_custom_folders(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSidebarCustomFoldersResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `customLabels`() : SidebarCustomLabelsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_custom_labels(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSidebarCustomLabelsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `expandFolder`(`localId`: Id) : VoidActionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_expand_folder(
                thisPtr,
                FfiConverterTypeId.lower(`localId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `systemLabels`() : SidebarSystemLabelsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_system_labels(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSidebarSystemLabelsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `watchLabels`(`callback`: LiveQueryCallback) : SidebarWatchLabelsResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_sidebar_watch_labels(
                thisPtr,
                FfiConverterTypeLiveQueryCallback.lower(`callback`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSidebarWatchLabelsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebar: FfiConverter<Sidebar, Pointer> {

    override fun lower(value: Sidebar): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Sidebar {
        return Sidebar(value)
    }

    override fun read(buf: ByteBuffer): Sidebar {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Sidebar) = 8UL

    override fun write(value: Sidebar, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Represent the result of a `OpenPGP` signature verification.
 */
public interface SignatureVerificationResultInterface {
    
    /**
     * Returns more info about the signature verification error.
     *
     * If the verification was successful there is no message.
     */
    fun `errorInfo`(): kotlin.String?
    
    /**
     * Returns the creation time of the signature.
     */
    fun `signatureCreationTime`(): kotlin.ULong?
    
    /**
     * Returns the key id of the key the signature was created with if any.
     */
    fun `signatureKeyId`(): kotlin.ULong?
    
    /**
     * The result of the signature verification with an enum type.
     */
    fun `verificationResult`(): SignatureVerification
    
    companion object
}

/**
 * Represent the result of a `OpenPGP` signature verification.
 */
open class SignatureVerificationResult: Disposable, AutoCloseable, SignatureVerificationResultInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_signatureverificationresult(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_signatureverificationresult(pointer!!, status)
        }
    }

    
    /**
     * Returns more info about the signature verification error.
     *
     * If the verification was successful there is no message.
     */override fun `errorInfo`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_error_info(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the creation time of the signature.
     */override fun `signatureCreationTime`(): kotlin.ULong? {
            return FfiConverterOptionalULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_signature_creation_time(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the key id of the key the signature was created with if any.
     */override fun `signatureKeyId`(): kotlin.ULong? {
            return FfiConverterOptionalULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_signature_key_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The result of the signature verification with an enum type.
     */override fun `verificationResult`(): SignatureVerification {
            return FfiConverterTypeSignatureVerification.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_signatureverificationresult_verification_result(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSignatureVerificationResult: FfiConverter<SignatureVerificationResult, Pointer> {

    override fun lower(value: SignatureVerificationResult): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SignatureVerificationResult {
        return SignatureVerificationResult(value)
    }

    override fun read(buf: ByteBuffer): SignatureVerificationResult {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SignatureVerificationResult) = 8UL

    override fun write(value: SignatureVerificationResult, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Represents an account known to the system.
 */
public interface StoredAccountInterface {
    
    /**
     * Retrieves account details including the name, email, and avatar information.
     *
     * This method constructs the account details using the available fields. If the display name
     * or username is not set, it falls back to `name_or_addr`. Similarly, the email defaults to
     * `name_or_addr` if the primary address is unavailable.
     *
     * # Returns
     * - `AccountDetails`: A struct containing the account's name, email, and avatar information.
     */
    fun `details`(): AccountDetails
    
    /**
     * Sequence number of when the account was last set as the primary account.
     */
    fun `primarySeq`(): kotlin.Long
    
    /**
     * Returns whether the account has 2FA enabled.
     */
    fun `secondFactorStatus`(): SecondFactorStatus?
    
    /**
     * Returns whether the account has a second (mailbox) password.
     */
    fun `secondPasswordStatus`(): SecondPasswordStatus?
    
    /**
     * Get the state of the account.
     */
    fun `state`(): StoredAccountState
    
    /**
     * Get the account's user id.
     */
    fun `userId`(): kotlin.String
    
    companion object
}

/**
 * Represents an account known to the system.
 */
open class StoredAccount: Disposable, AutoCloseable, StoredAccountInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_storedaccount(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_storedaccount(pointer!!, status)
        }
    }

    
    /**
     * Retrieves account details including the name, email, and avatar information.
     *
     * This method constructs the account details using the available fields. If the display name
     * or username is not set, it falls back to `name_or_addr`. Similarly, the email defaults to
     * `name_or_addr` if the primary address is unavailable.
     *
     * # Returns
     * - `AccountDetails`: A struct containing the account's name, email, and avatar information.
     */override fun `details`(): AccountDetails {
            return FfiConverterTypeAccountDetails.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_details(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Sequence number of when the account was last set as the primary account.
     */override fun `primarySeq`(): kotlin.Long {
            return FfiConverterLong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_primary_seq(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns whether the account has 2FA enabled.
     */override fun `secondFactorStatus`(): SecondFactorStatus? {
            return FfiConverterOptionalTypeSecondFactorStatus.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_second_factor_status(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns whether the account has a second (mailbox) password.
     */override fun `secondPasswordStatus`(): SecondPasswordStatus? {
            return FfiConverterOptionalTypeSecondPasswordStatus.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_second_password_status(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the state of the account.
     */override fun `state`(): StoredAccountState {
            return FfiConverterTypeStoredAccountState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the account's user id.
     */override fun `userId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedaccount_user_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeStoredAccount: FfiConverter<StoredAccount, Pointer> {

    override fun lower(value: StoredAccount): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): StoredAccount {
        return StoredAccount(value)
    }

    override fun read(buf: ByteBuffer): StoredAccount {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: StoredAccount) = 8UL

    override fun write(value: StoredAccount, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Represents an account known to the system.
 */
public interface StoredSessionInterface {
    
    /**
     * Get the ID of the session.
     */
    fun `sessionId`(): kotlin.String
    
    /**
     * Get the state of the session.
     */
    fun `state`(): StoredSessionState
    
    /**
     * Get the account id of the session.
     */
    fun `userId`(): kotlin.String
    
    companion object
}

/**
 * Represents an account known to the system.
 */
open class StoredSession: Disposable, AutoCloseable, StoredSessionInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_storedsession(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_storedsession(pointer!!, status)
        }
    }

    
    /**
     * Get the ID of the session.
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedsession_session_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the state of the session.
     */override fun `state`(): StoredSessionState {
            return FfiConverterTypeStoredSessionState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedsession_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the account id of the session.
     */override fun `userId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_storedsession_user_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeStoredSession: FfiConverter<StoredSession, Pointer> {

    override fun lower(value: StoredSession): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): StoredSession {
        return StoredSession(value)
    }

    override fun read(buf: ByteBuffer): StoredSession {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: StoredSession) = 8UL

    override fun write(value: StoredSession, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface UndoInterface {
    
    suspend fun `undo`(`ctx`: MailUserSession): UndoUndoResult
    
    companion object
}

open class Undo: Disposable, AutoCloseable, UndoInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_undo(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_undo(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `undo`(`ctx`: MailUserSession) : UndoUndoResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_undo_undo(
                thisPtr,
                FfiConverterTypeMailUserSession.lower(`ctx`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUndoUndoResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeUndo: FfiConverter<Undo, Pointer> {

    override fun lower(value: Undo): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Undo {
        return Undo(value)
    }

    override fun read(buf: ByteBuffer): Undo {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Undo) = 8UL

    override fun write(value: Undo, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A handle to a live query.
 *
 * This handle can be used to disconnect from the live query.

 */
public interface WatchHandleInterface {
    
    fun `disconnect`()
    
    companion object
}

/**
 * A handle to a live query.
 *
 * This handle can be used to disconnect from the live query.

 */
open class WatchHandle: Disposable, AutoCloseable, WatchHandleInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_watchhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_watchhandle(pointer!!, status)
        }
    }

    override fun `disconnect`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchhandle_disconnect(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchHandle: FfiConverter<WatchHandle, Pointer> {

    override fun lower(value: WatchHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WatchHandle {
        return WatchHandle(value)
    }

    override fun read(buf: ByteBuffer): WatchHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WatchHandle) = 8UL

    override fun write(value: WatchHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface WatchPrivacyInfoStreamInterface {
    
    fun `cancel`()
    
    fun `initialInfo`(): PrivacyInfo
    
    suspend fun `nextAsync`(): WatchPrivacyInfoStreamNextAsyncResult
    
    companion object
}

open class WatchPrivacyInfoStream: Disposable, AutoCloseable, WatchPrivacyInfoStreamInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_watchprivacyinfostream(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_watchprivacyinfostream(pointer!!, status)
        }
    }

    override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_cancel(
        it, _status)
}
    }
    
    

    override fun `initialInfo`(): PrivacyInfo {
            return FfiConverterTypePrivacyInfo.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_initial_info(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextAsync`() : WatchPrivacyInfoStreamNextAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchprivacyinfostream_next_async(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchPrivacyInfoStreamNextAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchPrivacyInfoStream: FfiConverter<WatchPrivacyInfoStream, Pointer> {

    override fun lower(value: WatchPrivacyInfoStream): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WatchPrivacyInfoStream {
        return WatchPrivacyInfoStream(value)
    }

    override fun read(buf: ByteBuffer): WatchPrivacyInfoStream {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WatchPrivacyInfoStream) = 8UL

    override fun write(value: WatchPrivacyInfoStream, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface WatchUserFeatureFlagsStreamInterface {
    
    fun `cancel`()
    
    suspend fun `nextAsync`(): WatchUserFeatureFlagsStreamNextAsyncResult
    
    companion object
}

open class WatchUserFeatureFlagsStream: Disposable, AutoCloseable, WatchUserFeatureFlagsStreamInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_watchuserfeatureflagsstream(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_watchuserfeatureflagsstream(pointer!!, status)
        }
    }

    override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchuserfeatureflagsstream_cancel(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextAsync`() : WatchUserFeatureFlagsStreamNextAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchuserfeatureflagsstream_next_async(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchUserFeatureFlagsStreamNextAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchUserFeatureFlagsStream: FfiConverter<WatchUserFeatureFlagsStream, Pointer> {

    override fun lower(value: WatchUserFeatureFlagsStream): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WatchUserFeatureFlagsStream {
        return WatchUserFeatureFlagsStream(value)
    }

    override fun read(buf: ByteBuffer): WatchUserFeatureFlagsStream {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WatchUserFeatureFlagsStream) = 8UL

    override fun write(value: WatchUserFeatureFlagsStream, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface WatchUserStreamInterface {
    
    fun `cancel`()
    
    suspend fun `nextAsync`(): WatchUserStreamNextAsyncResult
    
    companion object
}

open class WatchUserStream: Disposable, AutoCloseable, WatchUserStreamInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_free_watchuserstream(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_clone_watchuserstream(pointer!!, status)
        }
    }

    override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchuserstream_cancel(
        it, _status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextAsync`() : WatchUserStreamNextAsyncResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_method_watchuserstream_next_async(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchUserStreamNextAsyncResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchUserStream: FfiConverter<WatchUserStream, Pointer> {

    override fun lower(value: WatchUserStream): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WatchUserStream {
        return WatchUserStream(value)
    }

    override fun read(buf: ByteBuffer): WatchUserStream {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WatchUserStream) = 8UL

    override fun write(value: WatchUserStream, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



/**
 * Represents detailed information about a user account.
 *
 * This struct contains the name, email, and avatar information
 * associated with an account.
 */
data class AccountDetails (
    /**
     * The user's display name.
     */
    var `name`: kotlin.String, 
    /**
     * The user's email address.
     */
    var `email`: kotlin.String, 
    /**
     * Information about the user's avatar.
     */
    var `avatarInformation`: AvatarInformation
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAccountDetails: FfiConverterRustBuffer<AccountDetails> {
    override fun read(buf: ByteBuffer): AccountDetails {
        return AccountDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
        )
    }

    override fun allocationSize(value: AccountDetails) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatarInformation`)
    )

    override fun write(value: AccountDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatarInformation`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Address (
    /**
     * The local ID of the record, i.e. the ID assigned by the client
     * application. This is a restricted-scope unique identifier for the record
     * within the set of all records of this type, and is important for
     * relating local records. It has no relationship to the centrally-stored
     * API ID, and never leaves the local system.
     */
    var `id`: Id, 
    /**
     * TODO: Document this field.
     */
    var `addressType`: AddressType, 
    /**
     * TODO: Document this field.
     */
    var `catchAll`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `displayName`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `displayOrder`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `domainId`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `email`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `protonMx`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `receive`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `send`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `signature`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `signedKeyList`: AddressSignedKeyList, 
    /**
     * TODO: Document this field.
     */
    var `status`: AddressStatus
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddress: FfiConverterRustBuffer<Address> {
    override fun read(buf: ByteBuffer): Address {
        return Address(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeAddressType.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeAddressSignedKeyList.read(buf),
            FfiConverterTypeAddressStatus.read(buf),
        )
    }

    override fun allocationSize(value: Address) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterTypeAddressType.allocationSize(value.`addressType`) +
            FfiConverterBoolean.allocationSize(value.`catchAll`) +
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterUInt.allocationSize(value.`displayOrder`) +
            FfiConverterOptionalString.allocationSize(value.`domainId`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterBoolean.allocationSize(value.`protonMx`) +
            FfiConverterBoolean.allocationSize(value.`receive`) +
            FfiConverterBoolean.allocationSize(value.`send`) +
            FfiConverterString.allocationSize(value.`signature`) +
            FfiConverterTypeAddressSignedKeyList.allocationSize(value.`signedKeyList`) +
            FfiConverterTypeAddressStatus.allocationSize(value.`status`)
    )

    override fun write(value: Address, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterTypeAddressType.write(value.`addressType`, buf)
            FfiConverterBoolean.write(value.`catchAll`, buf)
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterUInt.write(value.`displayOrder`, buf)
            FfiConverterOptionalString.write(value.`domainId`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterBoolean.write(value.`protonMx`, buf)
            FfiConverterBoolean.write(value.`receive`, buf)
            FfiConverterBoolean.write(value.`send`, buf)
            FfiConverterString.write(value.`signature`, buf)
            FfiConverterTypeAddressSignedKeyList.write(value.`signedKeyList`, buf)
            FfiConverterTypeAddressStatus.write(value.`status`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class AddressSignedKeyList (
    /**
     * TODO: Document this field.
     */
    var `data`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `expectedMinEpochId`: kotlin.ULong?, 
    /**
     * TODO: Document this field.
     */
    var `maxEpochId`: kotlin.ULong?, 
    /**
     * TODO: Document this field.
     */
    var `minEpochId`: kotlin.ULong?, 
    /**
     * TODO: Document this field.
     */
    var `obsolescenceToken`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `revision`: kotlin.ULong, 
    /**
     * TODO: Document this field.
     */
    var `signature`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddressSignedKeyList: FfiConverterRustBuffer<AddressSignedKeyList> {
    override fun read(buf: ByteBuffer): AddressSignedKeyList {
        return AddressSignedKeyList(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: AddressSignedKeyList) = (
            FfiConverterOptionalString.allocationSize(value.`data`) +
            FfiConverterOptionalULong.allocationSize(value.`expectedMinEpochId`) +
            FfiConverterOptionalULong.allocationSize(value.`maxEpochId`) +
            FfiConverterOptionalULong.allocationSize(value.`minEpochId`) +
            FfiConverterOptionalString.allocationSize(value.`obsolescenceToken`) +
            FfiConverterULong.allocationSize(value.`revision`) +
            FfiConverterOptionalString.allocationSize(value.`signature`)
    )

    override fun write(value: AddressSignedKeyList, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`data`, buf)
            FfiConverterOptionalULong.write(value.`expectedMinEpochId`, buf)
            FfiConverterOptionalULong.write(value.`maxEpochId`, buf)
            FfiConverterOptionalULong.write(value.`minEpochId`, buf)
            FfiConverterOptionalString.write(value.`obsolescenceToken`, buf)
            FfiConverterULong.write(value.`revision`, buf)
            FfiConverterOptionalString.write(value.`signature`, buf)
    }
}



/**
 * All actions on conversation selection.
 */
data class AllConversationActions (
    /**
     * Actions hidden in conversation toolbar, but to be shown in corresponding More action
     */
    var `hiddenListActions`: List<ConversationAction>, 
    /**
     * Actions that must be in the conversation toolbar
     */
    var `visibleListActions`: List<ConversationAction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllConversationActions: FfiConverterRustBuffer<AllConversationActions> {
    override fun read(buf: ByteBuffer): AllConversationActions {
        return AllConversationActions(
            FfiConverterSequenceTypeConversationAction.read(buf),
            FfiConverterSequenceTypeConversationAction.read(buf),
        )
    }

    override fun allocationSize(value: AllConversationActions) = (
            FfiConverterSequenceTypeConversationAction.allocationSize(value.`hiddenListActions`) +
            FfiConverterSequenceTypeConversationAction.allocationSize(value.`visibleListActions`)
    )

    override fun write(value: AllConversationActions, buf: ByteBuffer) {
            FfiConverterSequenceTypeConversationAction.write(value.`hiddenListActions`, buf)
            FfiConverterSequenceTypeConversationAction.write(value.`visibleListActions`, buf)
    }
}



/**
 * All actions on messages selection.
 */
data class AllListActions (
    /**
     * Actions hidden in list toolbar, but to be shown in corresponding More action
     */
    var `hiddenListActions`: List<ListActions>, 
    /**
     * Actions that must be in the list toolbar
     */
    var `visibleListActions`: List<ListActions>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllListActions: FfiConverterRustBuffer<AllListActions> {
    override fun read(buf: ByteBuffer): AllListActions {
        return AllListActions(
            FfiConverterSequenceTypeListActions.read(buf),
            FfiConverterSequenceTypeListActions.read(buf),
        )
    }

    override fun allocationSize(value: AllListActions) = (
            FfiConverterSequenceTypeListActions.allocationSize(value.`hiddenListActions`) +
            FfiConverterSequenceTypeListActions.allocationSize(value.`visibleListActions`)
    )

    override fun write(value: AllListActions, buf: ByteBuffer) {
            FfiConverterSequenceTypeListActions.write(value.`hiddenListActions`, buf)
            FfiConverterSequenceTypeListActions.write(value.`visibleListActions`, buf)
    }
}



/**
 * All actions on message selection.
 */
data class AllMessageActions (
    /**
     * Actions hidden in message toolbar, but to be shown in corresponding More action
     */
    var `hiddenMessageActions`: List<MessageAction>, 
    /**
     * Actions that must be in the message toolbar
     */
    var `visibleMessageActions`: List<MessageAction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllMessageActions: FfiConverterRustBuffer<AllMessageActions> {
    override fun read(buf: ByteBuffer): AllMessageActions {
        return AllMessageActions(
            FfiConverterSequenceTypeMessageAction.read(buf),
            FfiConverterSequenceTypeMessageAction.read(buf),
        )
    }

    override fun allocationSize(value: AllMessageActions) = (
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`hiddenMessageActions`) +
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`visibleMessageActions`)
    )

    override fun write(value: AllMessageActions, buf: ByteBuffer) {
            FfiConverterSequenceTypeMessageAction.write(value.`hiddenMessageActions`, buf)
            FfiConverterSequenceTypeMessageAction.write(value.`visibleMessageActions`, buf)
    }
}



/**
 * The configuration for the Proton API service.
 */
data class ApiConfig (
    /**
     * TODO: Document this field.
     */
    var `userAgent`: kotlin.String, 
    /**
     * Env to connect to.
     */
    var `envId`: ApiEnvId, 
    /**
     * Proxy to use.
     */
    var `proxy`: kotlin.String?, 
    /**
     * A resolver to use.
     */
    var `resolver`: Resolver?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`userAgent`,
        this.`envId`,
        this.`proxy`,
        this.`resolver`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeApiConfig: FfiConverterRustBuffer<ApiConfig> {
    override fun read(buf: ByteBuffer): ApiConfig {
        return ApiConfig(
            FfiConverterString.read(buf),
            FfiConverterTypeApiEnvId.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeResolver.read(buf),
        )
    }

    override fun allocationSize(value: ApiConfig) = (
            FfiConverterString.allocationSize(value.`userAgent`) +
            FfiConverterTypeApiEnvId.allocationSize(value.`envId`) +
            FfiConverterOptionalString.allocationSize(value.`proxy`) +
            FfiConverterOptionalTypeResolver.allocationSize(value.`resolver`)
    )

    override fun write(value: ApiConfig, buf: ByteBuffer) {
            FfiConverterString.write(value.`userAgent`, buf)
            FfiConverterTypeApiEnvId.write(value.`envId`, buf)
            FfiConverterOptionalString.write(value.`proxy`, buf)
            FfiConverterOptionalTypeResolver.write(value.`resolver`, buf)
    }
}



data class AppDetails (
    /**
     * Example: "ios"
     */
    var `platform`: kotlin.String, 
    /**
     * Example: "mail"
     */
    var `product`: kotlin.String, 
    /**
     * Example: "1.0.0"
     */
    var `version`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppDetails: FfiConverterRustBuffer<AppDetails> {
    override fun read(buf: ByteBuffer): AppDetails {
        return AppDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AppDetails) = (
            FfiConverterString.allocationSize(value.`platform`) +
            FfiConverterString.allocationSize(value.`product`) +
            FfiConverterString.allocationSize(value.`version`)
    )

    override fun write(value: AppDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`platform`, buf)
            FfiConverterString.write(value.`product`, buf)
            FfiConverterString.write(value.`version`, buf)
    }
}



/**
 * Struct Representing `AppSettings` - cross accounts settings of the application.

 */
data class AppSettings (
    /**
     * The theme of the Application
     */
    var `appearance`: AppAppearance, 
    /**
     * What additional protection of the app is in use.
     */
    var `protection`: AppProtection, 
    /**
     * Autolock time for additional protection to kick in,
     * when app is running in bg for extended time.
     */
    var `autoLock`: AutoLock, 
    /**
     * Do you want to share contacts between the accounts.
     */
    var `useCombineContacts`: kotlin.Boolean, 
    /**
     * Use alternative routing, helpful for ppl leaving in
     * area where Proton servers are blocked for any reason.
     */
    var `useAlternativeRouting`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppSettings: FfiConverterRustBuffer<AppSettings> {
    override fun read(buf: ByteBuffer): AppSettings {
        return AppSettings(
            FfiConverterTypeAppAppearance.read(buf),
            FfiConverterTypeAppProtection.read(buf),
            FfiConverterTypeAutoLock.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: AppSettings) = (
            FfiConverterTypeAppAppearance.allocationSize(value.`appearance`) +
            FfiConverterTypeAppProtection.allocationSize(value.`protection`) +
            FfiConverterTypeAutoLock.allocationSize(value.`autoLock`) +
            FfiConverterBoolean.allocationSize(value.`useCombineContacts`) +
            FfiConverterBoolean.allocationSize(value.`useAlternativeRouting`)
    )

    override fun write(value: AppSettings, buf: ByteBuffer) {
            FfiConverterTypeAppAppearance.write(value.`appearance`, buf)
            FfiConverterTypeAppProtection.write(value.`protection`, buf)
            FfiConverterTypeAutoLock.write(value.`autoLock`, buf)
            FfiConverterBoolean.write(value.`useCombineContacts`, buf)
            FfiConverterBoolean.write(value.`useAlternativeRouting`, buf)
    }
}



/**
 * Representation of diff of selected setting options
 * and stored local value of `AppSettings`
 *
 * If value was modified by the user, client suppose to include this value
 * as Some(value) in this `Record`.
 *
 * If value is suppose to left unchananged, client should left the field as `None`

 */
data class AppSettingsDiff (
    /**
     * The theme of the Application
     */
    var `appearance`: AppAppearance?, 
    /**
     * Autolock time for additional protection to kick in,
     * when app is running in bg for extended time.
     */
    var `autoLock`: AutoLock?, 
    /**
     * Do you want to share contacts between the accounts.
     */
    var `useCombineContacts`: kotlin.Boolean?, 
    /**
     * Use alternative routing, helpful for ppl leaving in
     * area where Proton servers are blocked for any reason.
     */
    var `useAlternativeRouting`: kotlin.Boolean?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppSettingsDiff: FfiConverterRustBuffer<AppSettingsDiff> {
    override fun read(buf: ByteBuffer): AppSettingsDiff {
        return AppSettingsDiff(
            FfiConverterOptionalTypeAppAppearance.read(buf),
            FfiConverterOptionalTypeAutoLock.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: AppSettingsDiff) = (
            FfiConverterOptionalTypeAppAppearance.allocationSize(value.`appearance`) +
            FfiConverterOptionalTypeAutoLock.allocationSize(value.`autoLock`) +
            FfiConverterOptionalBoolean.allocationSize(value.`useCombineContacts`) +
            FfiConverterOptionalBoolean.allocationSize(value.`useAlternativeRouting`)
    )

    override fun write(value: AppSettingsDiff, buf: ByteBuffer) {
            FfiConverterOptionalTypeAppAppearance.write(value.`appearance`, buf)
            FfiConverterOptionalTypeAutoLock.write(value.`autoLock`, buf)
            FfiConverterOptionalBoolean.write(value.`useCombineContacts`, buf)
            FfiConverterOptionalBoolean.write(value.`useAlternativeRouting`, buf)
    }
}



data class AppleRecurringReceiptDetails (
    var `transactionId`: kotlin.String, 
    var `productId`: kotlin.String, 
    var `bundleId`: kotlin.String, 
    var `receipt`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppleRecurringReceiptDetails: FfiConverterRustBuffer<AppleRecurringReceiptDetails> {
    override fun read(buf: ByteBuffer): AppleRecurringReceiptDetails {
        return AppleRecurringReceiptDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AppleRecurringReceiptDetails) = (
            FfiConverterString.allocationSize(value.`transactionId`) +
            FfiConverterString.allocationSize(value.`productId`) +
            FfiConverterString.allocationSize(value.`bundleId`) +
            FfiConverterString.allocationSize(value.`receipt`)
    )

    override fun write(value: AppleRecurringReceiptDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`transactionId`, buf)
            FfiConverterString.write(value.`productId`, buf)
            FfiConverterString.write(value.`bundleId`, buf)
            FfiConverterString.write(value.`receipt`, buf)
    }
}



/**
 * Contains information of what exactly has to happen when user swipes item (conversation, message)
 * right or left.
 *
 * Note, this information is globally shared between all conversations and messages. User can set it in mail settings and it
 * does not depend on particular instance of message or conversation

 */
data class AssignedSwipeActions (
    var `left`: AssignedSwipeAction, 
    var `right`: AssignedSwipeAction
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssignedSwipeActions: FfiConverterRustBuffer<AssignedSwipeActions> {
    override fun read(buf: ByteBuffer): AssignedSwipeActions {
        return AssignedSwipeActions(
            FfiConverterTypeAssignedSwipeAction.read(buf),
            FfiConverterTypeAssignedSwipeAction.read(buf),
        )
    }

    override fun allocationSize(value: AssignedSwipeActions) = (
            FfiConverterTypeAssignedSwipeAction.allocationSize(value.`left`) +
            FfiConverterTypeAssignedSwipeAction.allocationSize(value.`right`)
    )

    override fun write(value: AssignedSwipeActions, buf: ByteBuffer) {
            FfiConverterTypeAssignedSwipeAction.write(value.`left`, buf)
            FfiConverterTypeAssignedSwipeAction.write(value.`right`, buf)
    }
}



data class AttachmentData (
    var `data`: kotlin.ByteArray, 
    var `mime`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentData: FfiConverterRustBuffer<AttachmentData> {
    override fun read(buf: ByteBuffer): AttachmentData {
        return AttachmentData(
            FfiConverterByteArray.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AttachmentData) = (
            FfiConverterByteArray.allocationSize(value.`data`) +
            FfiConverterString.allocationSize(value.`mime`)
    )

    override fun write(value: AttachmentData, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`data`, buf)
            FfiConverterString.write(value.`mime`, buf)
    }
}



data class AttachmentMetadata (
    var `id`: Id, 
    var `disposition`: Disposition, 
    var `mimeType`: AttachmentMimeType, 
    var `name`: kotlin.String, 
    var `size`: kotlin.ULong, 
    var `isListable`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentMetadata: FfiConverterRustBuffer<AttachmentMetadata> {
    override fun read(buf: ByteBuffer): AttachmentMetadata {
        return AttachmentMetadata(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeDisposition.read(buf),
            FfiConverterTypeAttachmentMimeType.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: AttachmentMetadata) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterTypeDisposition.allocationSize(value.`disposition`) +
            FfiConverterTypeAttachmentMimeType.allocationSize(value.`mimeType`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterULong.allocationSize(value.`size`) +
            FfiConverterBoolean.allocationSize(value.`isListable`)
    )

    override fun write(value: AttachmentMetadata, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterTypeDisposition.write(value.`disposition`, buf)
            FfiConverterTypeAttachmentMimeType.write(value.`mimeType`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterULong.write(value.`size`, buf)
            FfiConverterBoolean.write(value.`isListable`, buf)
    }
}



data class AttachmentMimeType (
    var `mime`: kotlin.String, 
    var `category`: MimeTypeCategory
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentMimeType: FfiConverterRustBuffer<AttachmentMimeType> {
    override fun read(buf: ByteBuffer): AttachmentMimeType {
        return AttachmentMimeType(
            FfiConverterString.read(buf),
            FfiConverterTypeMimeTypeCategory.read(buf),
        )
    }

    override fun allocationSize(value: AttachmentMimeType) = (
            FfiConverterString.allocationSize(value.`mime`) +
            FfiConverterTypeMimeTypeCategory.allocationSize(value.`category`)
    )

    override fun write(value: AttachmentMimeType, buf: ByteBuffer) {
            FfiConverterString.write(value.`mime`, buf)
            FfiConverterTypeMimeTypeCategory.write(value.`category`, buf)
    }
}



data class AutoDeleteBanner (
    var `state`: AutoDeleteState, 
    var `folder`: SpamOrTrash
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAutoDeleteBanner: FfiConverterRustBuffer<AutoDeleteBanner> {
    override fun read(buf: ByteBuffer): AutoDeleteBanner {
        return AutoDeleteBanner(
            FfiConverterTypeAutoDeleteState.read(buf),
            FfiConverterTypeSpamOrTrash.read(buf),
        )
    }

    override fun allocationSize(value: AutoDeleteBanner) = (
            FfiConverterTypeAutoDeleteState.allocationSize(value.`state`) +
            FfiConverterTypeSpamOrTrash.allocationSize(value.`folder`)
    )

    override fun write(value: AutoDeleteBanner, buf: ByteBuffer) {
            FfiConverterTypeAutoDeleteState.write(value.`state`, buf)
            FfiConverterTypeSpamOrTrash.write(value.`folder`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class AvatarInformation (
    /**
     * TODO: Document this field.
     */
    var `text`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `color`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvatarInformation: FfiConverterRustBuffer<AvatarInformation> {
    override fun read(buf: ByteBuffer): AvatarInformation {
        return AvatarInformation(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AvatarInformation) = (
            FfiConverterString.allocationSize(value.`text`) +
            FfiConverterString.allocationSize(value.`color`)
    )

    override fun write(value: AvatarInformation, buf: ByteBuffer) {
            FfiConverterString.write(value.`text`, buf)
            FfiConverterString.write(value.`color`, buf)
    }
}



data class BackgroundExecutionResult (
    var `status`: BackgroundExecutionStatus, 
    var `hasUnsentMessages`: kotlin.Boolean, 
    var `hasPendingActions`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBackgroundExecutionResult: FfiConverterRustBuffer<BackgroundExecutionResult> {
    override fun read(buf: ByteBuffer): BackgroundExecutionResult {
        return BackgroundExecutionResult(
            FfiConverterTypeBackgroundExecutionStatus.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: BackgroundExecutionResult) = (
            FfiConverterTypeBackgroundExecutionStatus.allocationSize(value.`status`) +
            FfiConverterBoolean.allocationSize(value.`hasUnsentMessages`) +
            FfiConverterBoolean.allocationSize(value.`hasPendingActions`)
    )

    override fun write(value: BackgroundExecutionResult, buf: ByteBuffer) {
            FfiConverterTypeBackgroundExecutionStatus.write(value.`status`, buf)
            FfiConverterBoolean.write(value.`hasUnsentMessages`, buf)
            FfiConverterBoolean.write(value.`hasPendingActions`, buf)
    }
}



data class BodyOutput (
    /**
     * The transformed html of the message.
     */
    var `body`: kotlin.String, 
    /**
     * Whether or not [`RemoteContent::Strip`] removed a blockquote.
     */
    var `hadBlockquote`: kotlin.Boolean, 
    /**
     * How many html tags it has removed.
     */
    var `tagsStripped`: kotlin.ULong, 
    /**
     * The transform opts that were used. All fields are actually Some.
     */
    var `transformOpts`: TransformOpts, 
    /**
     * This instructs the client on what banners they should show.
     */
    var `bodyBanners`: List<MessageBanner>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBodyOutput: FfiConverterRustBuffer<BodyOutput> {
    override fun read(buf: ByteBuffer): BodyOutput {
        return BodyOutput(
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeTransformOpts.read(buf),
            FfiConverterSequenceTypeMessageBanner.read(buf),
        )
    }

    override fun allocationSize(value: BodyOutput) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterBoolean.allocationSize(value.`hadBlockquote`) +
            FfiConverterULong.allocationSize(value.`tagsStripped`) +
            FfiConverterTypeTransformOpts.allocationSize(value.`transformOpts`) +
            FfiConverterSequenceTypeMessageBanner.allocationSize(value.`bodyBanners`)
    )

    override fun write(value: BodyOutput, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterBoolean.write(value.`hadBlockquote`, buf)
            FfiConverterULong.write(value.`tagsStripped`, buf)
            FfiConverterTypeTransformOpts.write(value.`transformOpts`, buf)
            FfiConverterSequenceTypeMessageBanner.write(value.`bodyBanners`, buf)
    }
}



/**
 * A response to an HTTP request sent by the loader.
 */
data class ChallengeLoaderResponse (
    /**
     * The HTTP status code of the response.
     */
    var `status`: kotlin.UShort, 
    /**
     * The HTTP status text of the response.
     */
    var `reason`: kotlin.String?, 
    /**
     * The content type of the response.
     */
    var `contentType`: kotlin.String?, 
    /**
     * The content encoding of the response.
     */
    var `contentEncoding`: kotlin.String?, 
    /**
     * The headers of the response.
     */
    var `headers`: List<Header>, 
    /**
     * The contents of the response.
     */
    var `contents`: kotlin.ByteArray
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeLoaderResponse: FfiConverterRustBuffer<ChallengeLoaderResponse> {
    override fun read(buf: ByteBuffer): ChallengeLoaderResponse {
        return ChallengeLoaderResponse(
            FfiConverterUShort.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceTypeHeader.read(buf),
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: ChallengeLoaderResponse) = (
            FfiConverterUShort.allocationSize(value.`status`) +
            FfiConverterOptionalString.allocationSize(value.`reason`) +
            FfiConverterOptionalString.allocationSize(value.`contentType`) +
            FfiConverterOptionalString.allocationSize(value.`contentEncoding`) +
            FfiConverterSequenceTypeHeader.allocationSize(value.`headers`) +
            FfiConverterByteArray.allocationSize(value.`contents`)
    )

    override fun write(value: ChallengeLoaderResponse, buf: ByteBuffer) {
            FfiConverterUShort.write(value.`status`, buf)
            FfiConverterOptionalString.write(value.`reason`, buf)
            FfiConverterOptionalString.write(value.`contentType`, buf)
            FfiConverterOptionalString.write(value.`contentEncoding`, buf)
            FfiConverterSequenceTypeHeader.write(value.`headers`, buf)
            FfiConverterByteArray.write(value.`contents`, buf)
    }
}



data class ComposerContent (
    /**
     * HTML content that should be injected into `<head>` tag.
     *
     * It does not provide `<head>` tag on its own.
     * Therefore, the returned HTML can be inserted alongside with other html nodes.
     */
    var `head`: kotlin.String, 
    /**
     * The body of the draft. Initially contains signature
     * and replied quote (if applicable).
     *
     * It does not provide `<body>` tag on its own.
     */
    var `body`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerContent: FfiConverterRustBuffer<ComposerContent> {
    override fun read(buf: ByteBuffer): ComposerContent {
        return ComposerContent(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ComposerContent) = (
            FfiConverterString.allocationSize(value.`head`) +
            FfiConverterString.allocationSize(value.`body`)
    )

    override fun write(value: ComposerContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`head`, buf)
            FfiConverterString.write(value.`body`, buf)
    }
}



data class ComposerRecipientGroup (
    var `displayName`: kotlin.String, 
    var `recipients`: List<ComposerRecipientSingle>, 
    var `totalContactsInGroup`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipientGroup: FfiConverterRustBuffer<ComposerRecipientGroup> {
    override fun read(buf: ByteBuffer): ComposerRecipientGroup {
        return ComposerRecipientGroup(
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeComposerRecipientSingle.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: ComposerRecipientGroup) = (
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterSequenceTypeComposerRecipientSingle.allocationSize(value.`recipients`) +
            FfiConverterULong.allocationSize(value.`totalContactsInGroup`)
    )

    override fun write(value: ComposerRecipientGroup, buf: ByteBuffer) {
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterSequenceTypeComposerRecipientSingle.write(value.`recipients`, buf)
            FfiConverterULong.write(value.`totalContactsInGroup`, buf)
    }
}



data class ComposerRecipientSingle (
    var `displayName`: kotlin.String?, 
    var `address`: kotlin.String, 
    var `validState`: ComposerRecipientValidState, 
    var `privacyLock`: PrivacyLock?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipientSingle: FfiConverterRustBuffer<ComposerRecipientSingle> {
    override fun read(buf: ByteBuffer): ComposerRecipientSingle {
        return ComposerRecipientSingle(
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeComposerRecipientValidState.read(buf),
            FfiConverterOptionalTypePrivacyLock.read(buf),
        )
    }

    override fun allocationSize(value: ComposerRecipientSingle) = (
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterTypeComposerRecipientValidState.allocationSize(value.`validState`) +
            FfiConverterOptionalTypePrivacyLock.allocationSize(value.`privacyLock`)
    )

    override fun write(value: ComposerRecipientSingle, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterString.write(value.`address`, buf)
            FfiConverterTypeComposerRecipientValidState.write(value.`validState`, buf)
            FfiConverterOptionalTypePrivacyLock.write(value.`privacyLock`, buf)
    }
}



data class Contact (
    /**
     * TODO: Document this field.
     */
    var `cards`: List<ContactCard>, 
    /**
     * TODO: Document this field.
     */
    var `contactEmails`: List<ContactEmail>, 
    /**
     * TODO: Document this field.
     */
    var `createTime`: kotlin.ULong, 
    /**
     * TODO: Document this field.
     */
    var `labelIds`: List<Id>, 
    /**
     * TODO: Document this field.
     */
    var `modifyTime`: kotlin.ULong, 
    /**
     * TODO: Document this field.
     */
    var `name`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `size`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContact: FfiConverterRustBuffer<Contact> {
    override fun read(buf: ByteBuffer): Contact {
        return Contact(
            FfiConverterSequenceTypeContactCard.read(buf),
            FfiConverterSequenceTypeContactEmail.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceTypeId.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: Contact) = (
            FfiConverterSequenceTypeContactCard.allocationSize(value.`cards`) +
            FfiConverterSequenceTypeContactEmail.allocationSize(value.`contactEmails`) +
            FfiConverterULong.allocationSize(value.`createTime`) +
            FfiConverterSequenceTypeId.allocationSize(value.`labelIds`) +
            FfiConverterULong.allocationSize(value.`modifyTime`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterULong.allocationSize(value.`size`)
    )

    override fun write(value: Contact, buf: ByteBuffer) {
            FfiConverterSequenceTypeContactCard.write(value.`cards`, buf)
            FfiConverterSequenceTypeContactEmail.write(value.`contactEmails`, buf)
            FfiConverterULong.write(value.`createTime`, buf)
            FfiConverterSequenceTypeId.write(value.`labelIds`, buf)
            FfiConverterULong.write(value.`modifyTime`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterULong.write(value.`size`, buf)
    }
}



/**
 * Represents a contact card.
 *
 * Contact cards contain information encoded as a v-card. Cards can be
 * encrypted or signed with the user keys.

 */
data class ContactCard (
    /**
     * The local ID of the record, i.e. the ID assigned by the client
     * application. This is a restricted-scope unique identifier for the record
     * within the set of all records of this type, and is important for
     * relating local records. It has no relationship to the centrally-stored
     * API ID, and never leaves the local system.
     */
    var `id`: Id, 
    /**
     * TODO: Document this field.
     */
    var `cardType`: CardType, 
    /**
     * TODO: Document this field.
     */
    var `data`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `signature`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactCard: FfiConverterRustBuffer<ContactCard> {
    override fun read(buf: ByteBuffer): ContactCard {
        return ContactCard(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeCardType.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ContactCard) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterTypeCardType.allocationSize(value.`cardType`) +
            FfiConverterString.allocationSize(value.`data`) +
            FfiConverterOptionalString.allocationSize(value.`signature`)
    )

    override fun write(value: ContactCard, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterTypeCardType.write(value.`cardType`, buf)
            FfiConverterString.write(value.`data`, buf)
            FfiConverterOptionalString.write(value.`signature`, buf)
    }
}



/**
 * Any of the fields here might be empty
 */
data class ContactDetailAddress (
    var `street`: kotlin.String?, 
    var `city`: kotlin.String?, 
    var `region`: kotlin.String?, 
    var `postalCode`: kotlin.String?, 
    var `country`: kotlin.String?, 
    var `addrType`: List<VcardPropType>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactDetailAddress: FfiConverterRustBuffer<ContactDetailAddress> {
    override fun read(buf: ByteBuffer): ContactDetailAddress {
        return ContactDetailAddress(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceTypeVcardPropType.read(buf),
        )
    }

    override fun allocationSize(value: ContactDetailAddress) = (
            FfiConverterOptionalString.allocationSize(value.`street`) +
            FfiConverterOptionalString.allocationSize(value.`city`) +
            FfiConverterOptionalString.allocationSize(value.`region`) +
            FfiConverterOptionalString.allocationSize(value.`postalCode`) +
            FfiConverterOptionalString.allocationSize(value.`country`) +
            FfiConverterSequenceTypeVcardPropType.allocationSize(value.`addrType`)
    )

    override fun write(value: ContactDetailAddress, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`street`, buf)
            FfiConverterOptionalString.write(value.`city`, buf)
            FfiConverterOptionalString.write(value.`region`, buf)
            FfiConverterOptionalString.write(value.`postalCode`, buf)
            FfiConverterOptionalString.write(value.`country`, buf)
            FfiConverterSequenceTypeVcardPropType.write(value.`addrType`, buf)
    }
}



data class ContactDetailCard (
    var `id`: Id, 
    var `remoteId`: kotlin.String?, 
    var `avatarInformation`: AvatarInformation, 
    var `extendedName`: ExtendedName, 
    /**
     * These are sorted per display order
     */
    var `fields`: List<ContactField>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactDetailCard: FfiConverterRustBuffer<ContactDetailCard> {
    override fun read(buf: ByteBuffer): ContactDetailCard {
        return ContactDetailCard(
            FfiConverterTypeId.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
            FfiConverterTypeExtendedName.read(buf),
            FfiConverterSequenceTypeContactField.read(buf),
        )
    }

    override fun allocationSize(value: ContactDetailCard) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterOptionalString.allocationSize(value.`remoteId`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatarInformation`) +
            FfiConverterTypeExtendedName.allocationSize(value.`extendedName`) +
            FfiConverterSequenceTypeContactField.allocationSize(value.`fields`)
    )

    override fun write(value: ContactDetailCard, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterOptionalString.write(value.`remoteId`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatarInformation`, buf)
            FfiConverterTypeExtendedName.write(value.`extendedName`, buf)
            FfiConverterSequenceTypeContactField.write(value.`fields`, buf)
    }
}



data class ContactDetailsEmail (
    var `emailType`: List<VcardPropType>, 
    var `email`: kotlin.String, 
    var `groups`: List<ContactGroup>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactDetailsEmail: FfiConverterRustBuffer<ContactDetailsEmail> {
    override fun read(buf: ByteBuffer): ContactDetailsEmail {
        return ContactDetailsEmail(
            FfiConverterSequenceTypeVcardPropType.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeContactGroup.read(buf),
        )
    }

    override fun allocationSize(value: ContactDetailsEmail) = (
            FfiConverterSequenceTypeVcardPropType.allocationSize(value.`emailType`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterSequenceTypeContactGroup.allocationSize(value.`groups`)
    )

    override fun write(value: ContactDetailsEmail, buf: ByteBuffer) {
            FfiConverterSequenceTypeVcardPropType.write(value.`emailType`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterSequenceTypeContactGroup.write(value.`groups`, buf)
    }
}



data class ContactDetailsTelephones (
    var `number`: kotlin.String, 
    var `telTypes`: List<VcardPropType>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactDetailsTelephones: FfiConverterRustBuffer<ContactDetailsTelephones> {
    override fun read(buf: ByteBuffer): ContactDetailsTelephones {
        return ContactDetailsTelephones(
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeVcardPropType.read(buf),
        )
    }

    override fun allocationSize(value: ContactDetailsTelephones) = (
            FfiConverterString.allocationSize(value.`number`) +
            FfiConverterSequenceTypeVcardPropType.allocationSize(value.`telTypes`)
    )

    override fun write(value: ContactDetailsTelephones, buf: ByteBuffer) {
            FfiConverterString.write(value.`number`, buf)
            FfiConverterSequenceTypeVcardPropType.write(value.`telTypes`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class ContactEmail (
    /**
     * TODO: Document this field.
     */
    var `canonicalEmail`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `contactType`: List<kotlin.String>, 
    /**
     * TODO: Document this field.
     */
    var `defaults`: ContactSendingPreferences, 
    /**
     * TODO: Document this field.
     */
    var `displayOrder`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `email`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `isProton`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `labelIds`: List<Id>, 
    /**
     * TODO: Document this field.
     */
    var `lastUsedTime`: UnixTimestamp, 
    /**
     * TODO: Document this field.
     */
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactEmail: FfiConverterRustBuffer<ContactEmail> {
    override fun read(buf: ByteBuffer): ContactEmail {
        return ContactEmail(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterTypeContactSendingPreferences.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceTypeId.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ContactEmail) = (
            FfiConverterString.allocationSize(value.`canonicalEmail`) +
            FfiConverterSequenceString.allocationSize(value.`contactType`) +
            FfiConverterTypeContactSendingPreferences.allocationSize(value.`defaults`) +
            FfiConverterUInt.allocationSize(value.`displayOrder`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterBoolean.allocationSize(value.`isProton`) +
            FfiConverterSequenceTypeId.allocationSize(value.`labelIds`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`lastUsedTime`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: ContactEmail, buf: ByteBuffer) {
            FfiConverterString.write(value.`canonicalEmail`, buf)
            FfiConverterSequenceString.write(value.`contactType`, buf)
            FfiConverterTypeContactSendingPreferences.write(value.`defaults`, buf)
            FfiConverterUInt.write(value.`displayOrder`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterBoolean.write(value.`isProton`, buf)
            FfiConverterSequenceTypeId.write(value.`labelIds`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`lastUsedTime`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



/**
 * This is the main data structure that is used to represent the contact email.
 */
data class ContactEmailItem (
    var `contactId`: Id, 
    var `email`: kotlin.String, 
    /**
     * The field represents if the email is a proton email like foo@pm.me
     */
    var `isProton`: kotlin.Boolean, 
    var `lastUsedTime`: UnixTimestamp, 
    var `name`: kotlin.String, 
    var `avatarInformation`: AvatarInformation
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactEmailItem: FfiConverterRustBuffer<ContactEmailItem> {
    override fun read(buf: ByteBuffer): ContactEmailItem {
        return ContactEmailItem(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
        )
    }

    override fun allocationSize(value: ContactEmailItem) = (
            FfiConverterTypeId.allocationSize(value.`contactId`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterBoolean.allocationSize(value.`isProton`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`lastUsedTime`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatarInformation`)
    )

    override fun write(value: ContactEmailItem, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`contactId`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterBoolean.write(value.`isProton`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`lastUsedTime`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatarInformation`, buf)
    }
}



data class ContactGroup (
    var `name`: kotlin.String, 
    var `color`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactGroup: FfiConverterRustBuffer<ContactGroup> {
    override fun read(buf: ByteBuffer): ContactGroup {
        return ContactGroup(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ContactGroup) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`color`)
    )

    override fun write(value: ContactGroup, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`color`, buf)
    }
}



/**
 * This is the main data structure that is used to represent the contact group.
 */
data class ContactGroupItem (
    /**
     * The field represent the unique identifier of the contact group in the database
     */
    var `id`: Id, 
    /**
     * The field represent the name of the contact group
     */
    var `name`: kotlin.String, 
    /**
     * The field represent the avatar color of the contact group
     */
    var `avatarColor`: kotlin.String, 
    /**
     * The field represent the list of emails of the contact group
     */
    var `contactEmails`: List<ContactEmailItem>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactGroupItem: FfiConverterRustBuffer<ContactGroupItem> {
    override fun read(buf: ByteBuffer): ContactGroupItem {
        return ContactGroupItem(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeContactEmailItem.read(buf),
        )
    }

    override fun allocationSize(value: ContactGroupItem) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`avatarColor`) +
            FfiConverterSequenceTypeContactEmailItem.allocationSize(value.`contactEmails`)
    )

    override fun write(value: ContactGroupItem, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`avatarColor`, buf)
            FfiConverterSequenceTypeContactEmailItem.write(value.`contactEmails`, buf)
    }
}



/**
 * This is the main data structure that is used to represent the contact.
 */
data class ContactItem (
    /**
     * The field represent the unique identifier of the contact in the database
     */
    var `id`: Id, 
    /**
     * The field represent the name of the contact
     */
    var `name`: kotlin.String, 
    /**
     * The field represent the avatar information of the contact
     */
    var `avatarInformation`: AvatarInformation, 
    /**
     * The field represent the list of emails of the contact
     */
    var `emails`: List<ContactEmailItem>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactItem: FfiConverterRustBuffer<ContactItem> {
    override fun read(buf: ByteBuffer): ContactItem {
        return ContactItem(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
            FfiConverterSequenceTypeContactEmailItem.read(buf),
        )
    }

    override fun allocationSize(value: ContactItem) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatarInformation`) +
            FfiConverterSequenceTypeContactEmailItem.allocationSize(value.`emails`)
    )

    override fun write(value: ContactItem, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatarInformation`, buf)
            FfiConverterSequenceTypeContactEmailItem.write(value.`emails`, buf)
    }
}



/**
 * Used in the composer to suggest email addresses based on the user input (To:, CC: etc fields)
 * Contrary to the [`ContactItemType`] it also might be a device contact

 */
data class ContactSuggestion (
    /**
     * The field represents unique key identifier used by the user to distinguish elements in the array
     */
    var `key`: kotlin.String, 
    /**
     * The field represents the name of the contact
     */
    var `name`: kotlin.String, 
    /**
     * The field represents the avatar information of the contact
     */
    var `avatarInformation`: AvatarInformation, 
    /**
     * The kind of contact suggestion. Whether it is a native contact, proton contact or a group.
     */
    var `kind`: ContactSuggestionKind
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactSuggestion: FfiConverterRustBuffer<ContactSuggestion> {
    override fun read(buf: ByteBuffer): ContactSuggestion {
        return ContactSuggestion(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
            FfiConverterTypeContactSuggestionKind.read(buf),
        )
    }

    override fun allocationSize(value: ContactSuggestion) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatarInformation`) +
            FfiConverterTypeContactSuggestionKind.allocationSize(value.`kind`)
    )

    override fun write(value: ContactSuggestion, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatarInformation`, buf)
            FfiConverterTypeContactSuggestionKind.write(value.`kind`, buf)
    }
}



data class Conversation (
    var `id`: Id, 
    var `attachmentsMetadata`: List<AttachmentMetadata>, 
    var `customLabels`: List<InlineCustomLabel>, 
    var `displaySnoozeReminder`: kotlin.Boolean, 
    var `snoozedUntil`: UnixTimestamp?, 
    var `locations`: List<ExclusiveLocation>, 
    var `expirationTime`: UnixTimestamp, 
    var `isStarred`: kotlin.Boolean, 
    var `numAttachments`: kotlin.ULong, 
    var `numMessages`: kotlin.ULong, 
    var `numUnread`: kotlin.ULong, 
    var `totalMessages`: kotlin.ULong, 
    var `totalUnread`: kotlin.ULong, 
    var `displayOrder`: kotlin.ULong, 
    var `recipients`: List<MessageRecipient>, 
    var `senders`: List<MessageSender>, 
    var `size`: kotlin.ULong, 
    var `subject`: kotlin.String, 
    var `time`: UnixTimestamp, 
    var `avatar`: AvatarInformation, 
    var `hiddenMessagesBanner`: HiddenMessagesBanner?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversation: FfiConverterRustBuffer<Conversation> {
    override fun read(buf: ByteBuffer): Conversation {
        return Conversation(
            FfiConverterTypeId.read(buf),
            FfiConverterSequenceTypeAttachmentMetadata.read(buf),
            FfiConverterSequenceTypeInlineCustomLabel.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeUnixTimestamp.read(buf),
            FfiConverterSequenceTypeExclusiveLocation.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceTypeMessageRecipient.read(buf),
            FfiConverterSequenceTypeMessageSender.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
            FfiConverterOptionalTypeHiddenMessagesBanner.read(buf),
        )
    }

    override fun allocationSize(value: Conversation) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterSequenceTypeAttachmentMetadata.allocationSize(value.`attachmentsMetadata`) +
            FfiConverterSequenceTypeInlineCustomLabel.allocationSize(value.`customLabels`) +
            FfiConverterBoolean.allocationSize(value.`displaySnoozeReminder`) +
            FfiConverterOptionalTypeUnixTimestamp.allocationSize(value.`snoozedUntil`) +
            FfiConverterSequenceTypeExclusiveLocation.allocationSize(value.`locations`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`expirationTime`) +
            FfiConverterBoolean.allocationSize(value.`isStarred`) +
            FfiConverterULong.allocationSize(value.`numAttachments`) +
            FfiConverterULong.allocationSize(value.`numMessages`) +
            FfiConverterULong.allocationSize(value.`numUnread`) +
            FfiConverterULong.allocationSize(value.`totalMessages`) +
            FfiConverterULong.allocationSize(value.`totalUnread`) +
            FfiConverterULong.allocationSize(value.`displayOrder`) +
            FfiConverterSequenceTypeMessageRecipient.allocationSize(value.`recipients`) +
            FfiConverterSequenceTypeMessageSender.allocationSize(value.`senders`) +
            FfiConverterULong.allocationSize(value.`size`) +
            FfiConverterString.allocationSize(value.`subject`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`time`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatar`) +
            FfiConverterOptionalTypeHiddenMessagesBanner.allocationSize(value.`hiddenMessagesBanner`)
    )

    override fun write(value: Conversation, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterSequenceTypeAttachmentMetadata.write(value.`attachmentsMetadata`, buf)
            FfiConverterSequenceTypeInlineCustomLabel.write(value.`customLabels`, buf)
            FfiConverterBoolean.write(value.`displaySnoozeReminder`, buf)
            FfiConverterOptionalTypeUnixTimestamp.write(value.`snoozedUntil`, buf)
            FfiConverterSequenceTypeExclusiveLocation.write(value.`locations`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`expirationTime`, buf)
            FfiConverterBoolean.write(value.`isStarred`, buf)
            FfiConverterULong.write(value.`numAttachments`, buf)
            FfiConverterULong.write(value.`numMessages`, buf)
            FfiConverterULong.write(value.`numUnread`, buf)
            FfiConverterULong.write(value.`totalMessages`, buf)
            FfiConverterULong.write(value.`totalUnread`, buf)
            FfiConverterULong.write(value.`displayOrder`, buf)
            FfiConverterSequenceTypeMessageRecipient.write(value.`recipients`, buf)
            FfiConverterSequenceTypeMessageSender.write(value.`senders`, buf)
            FfiConverterULong.write(value.`size`, buf)
            FfiConverterString.write(value.`subject`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`time`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatar`, buf)
            FfiConverterOptionalTypeHiddenMessagesBanner.write(value.`hiddenMessagesBanner`, buf)
    }
}



/**
 * Conversation action sheet grouped by categories for UI display.
 */
data class ConversationActionSheet (
    /**
     * Core conversation actions (Mark Read/Unread, Star/Unstar, LabelAs)
     */
    var `conversationActions`: List<ConversationAction>, 
    /**
     * Movement-related actions (Archive, Trash, Move, Snooze, etc.)
     */
    var `moveActions`: List<ConversationAction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationActionSheet: FfiConverterRustBuffer<ConversationActionSheet> {
    override fun read(buf: ByteBuffer): ConversationActionSheet {
        return ConversationActionSheet(
            FfiConverterSequenceTypeConversationAction.read(buf),
            FfiConverterSequenceTypeConversationAction.read(buf),
        )
    }

    override fun allocationSize(value: ConversationActionSheet) = (
            FfiConverterSequenceTypeConversationAction.allocationSize(value.`conversationActions`) +
            FfiConverterSequenceTypeConversationAction.allocationSize(value.`moveActions`)
    )

    override fun write(value: ConversationActionSheet, buf: ByteBuffer) {
            FfiConverterSequenceTypeConversationAction.write(value.`conversationActions`, buf)
            FfiConverterSequenceTypeConversationAction.write(value.`moveActions`, buf)
    }
}



data class ConversationAndMessages (
    var `conversation`: Conversation, 
    var `messages`: List<Message>, 
    var `focusedMessageId`: Id?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationAndMessages: FfiConverterRustBuffer<ConversationAndMessages> {
    override fun read(buf: ByteBuffer): ConversationAndMessages {
        return ConversationAndMessages(
            FfiConverterTypeConversation.read(buf),
            FfiConverterSequenceTypeMessage.read(buf),
            FfiConverterOptionalTypeId.read(buf),
        )
    }

    override fun allocationSize(value: ConversationAndMessages) = (
            FfiConverterTypeConversation.allocationSize(value.`conversation`) +
            FfiConverterSequenceTypeMessage.allocationSize(value.`messages`) +
            FfiConverterOptionalTypeId.allocationSize(value.`focusedMessageId`)
    )

    override fun write(value: ConversationAndMessages, buf: ByteBuffer) {
            FfiConverterTypeConversation.write(value.`conversation`, buf)
            FfiConverterSequenceTypeMessage.write(value.`messages`, buf)
            FfiConverterOptionalTypeId.write(value.`focusedMessageId`, buf)
    }
}



/**
 * This struct represents a custom folder that can be used as an action.

 */
data class CustomFolderAction (
    var `localId`: Id, 
    var `name`: kotlin.String, 
    /**
     * Folder color is calculated based on user settings.
     * None means the folder colors are disabled.
     */
    var `color`: LabelColor?, 
    /**
     * It holds folder structure as self reference within vector.
     */
    var `children`: List<CustomFolderAction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomFolderAction: FfiConverterRustBuffer<CustomFolderAction> {
    override fun read(buf: ByteBuffer): CustomFolderAction {
        return CustomFolderAction(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeLabelColor.read(buf),
            FfiConverterSequenceTypeCustomFolderAction.read(buf),
        )
    }

    override fun allocationSize(value: CustomFolderAction) = (
            FfiConverterTypeId.allocationSize(value.`localId`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterOptionalTypeLabelColor.allocationSize(value.`color`) +
            FfiConverterSequenceTypeCustomFolderAction.allocationSize(value.`children`)
    )

    override fun write(value: CustomFolderAction, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`localId`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterOptionalTypeLabelColor.write(value.`color`, buf)
            FfiConverterSequenceTypeCustomFolderAction.write(value.`children`, buf)
    }
}



data class DecryptedAttachment (
    var `attachmentMetadata`: AttachmentMetadata, 
    var `dataPath`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedAttachment: FfiConverterRustBuffer<DecryptedAttachment> {
    override fun read(buf: ByteBuffer): DecryptedAttachment {
        return DecryptedAttachment(
            FfiConverterTypeAttachmentMetadata.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DecryptedAttachment) = (
            FfiConverterTypeAttachmentMetadata.allocationSize(value.`attachmentMetadata`) +
            FfiConverterString.allocationSize(value.`dataPath`)
    )

    override fun write(value: DecryptedAttachment, buf: ByteBuffer) {
            FfiConverterTypeAttachmentMetadata.write(value.`attachmentMetadata`, buf)
            FfiConverterString.write(value.`dataPath`, buf)
    }
}



data class DecryptedEmailPushNotification (
    var `subject`: kotlin.String, 
    var `sender`: NotificationSender, 
    var `messageId`: RemoteId, 
    var `action`: DecryptedEmailPushNotificationAction?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedEmailPushNotification: FfiConverterRustBuffer<DecryptedEmailPushNotification> {
    override fun read(buf: ByteBuffer): DecryptedEmailPushNotification {
        return DecryptedEmailPushNotification(
            FfiConverterString.read(buf),
            FfiConverterTypeNotificationSender.read(buf),
            FfiConverterTypeRemoteId.read(buf),
            FfiConverterOptionalTypeDecryptedEmailPushNotificationAction.read(buf),
        )
    }

    override fun allocationSize(value: DecryptedEmailPushNotification) = (
            FfiConverterString.allocationSize(value.`subject`) +
            FfiConverterTypeNotificationSender.allocationSize(value.`sender`) +
            FfiConverterTypeRemoteId.allocationSize(value.`messageId`) +
            FfiConverterOptionalTypeDecryptedEmailPushNotificationAction.allocationSize(value.`action`)
    )

    override fun write(value: DecryptedEmailPushNotification, buf: ByteBuffer) {
            FfiConverterString.write(value.`subject`, buf)
            FfiConverterTypeNotificationSender.write(value.`sender`, buf)
            FfiConverterTypeRemoteId.write(value.`messageId`, buf)
            FfiConverterOptionalTypeDecryptedEmailPushNotificationAction.write(value.`action`, buf)
    }
}



/**
 * Decrypted notification that is pushed when user's device has to open a web page with given URL.
 * Used for example when user logs in in the new device

 */
data class DecryptedOpenUrlPushNotification (
    var `content`: kotlin.String, 
    var `sender`: NotificationSender, 
    var `url`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedOpenUrlPushNotification: FfiConverterRustBuffer<DecryptedOpenUrlPushNotification> {
    override fun read(buf: ByteBuffer): DecryptedOpenUrlPushNotification {
        return DecryptedOpenUrlPushNotification(
            FfiConverterString.read(buf),
            FfiConverterTypeNotificationSender.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DecryptedOpenUrlPushNotification) = (
            FfiConverterString.allocationSize(value.`content`) +
            FfiConverterTypeNotificationSender.allocationSize(value.`sender`) +
            FfiConverterString.allocationSize(value.`url`)
    )

    override fun write(value: DecryptedOpenUrlPushNotification, buf: ByteBuffer) {
            FfiConverterString.write(value.`content`, buf)
            FfiConverterTypeNotificationSender.write(value.`sender`, buf)
            FfiConverterString.write(value.`url`, buf)
    }
}



/**
 * Device contact feeded by the mobile/web application.
 * Used as an input for generating list of contact suggestions ([`ContactSuggestion`])

 */
data class DeviceContact (
    /**
     * The field represents unique key identifier used by the user to distinguish elements in the array
     */
    var `key`: kotlin.String, 
    /**
     * The field represents the name of the contact
     */
    var `name`: kotlin.String, 
    /**
     * List of email addresses assigned to the contact. That list has an arbitrary order given by the user
     */
    var `emails`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDeviceContact: FfiConverterRustBuffer<DeviceContact> {
    override fun read(buf: ByteBuffer): DeviceContact {
        return DeviceContact(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: DeviceContact) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterSequenceString.allocationSize(value.`emails`)
    )

    override fun write(value: DeviceContact, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterSequenceString.write(value.`emails`, buf)
    }
}



/**
 * A device, native contact, stored only locally on the current device.

 */
data class DeviceContactSuggestion (
    /**
     * The field represents the email address used in the device contact
     */
    var `email`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDeviceContactSuggestion: FfiConverterRustBuffer<DeviceContactSuggestion> {
    override fun read(buf: ByteBuffer): DeviceContactSuggestion {
        return DeviceContactSuggestion(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DeviceContactSuggestion) = (
            FfiConverterString.allocationSize(value.`email`)
    )

    override fun write(value: DeviceContactSuggestion, buf: ByteBuffer) {
            FfiConverterString.write(value.`email`, buf)
    }
}



/**
 * The response to a device info request.
 */
data class DeviceInfo (
    /**
     * The language code of this Locale.
     */
    var `language`: kotlin.String, 
    /**
     * Time zone id, such as "Asia/Calcutta", "GMT+5:30" or "PST".
     */
    var `timezone`: kotlin.String, 
    /**
     * Time zone raw offset in minutes from GMT including daylight saving.
     */
    var `timezoneOffset`: kotlin.Int, 
    /**
     * The end-user-visible name for the end product.
     */
    var `model`: kotlin.String, 
    /**
     * The consumer-visible brand with which the product/hardware will be associated.
     */
    var `brand`: kotlin.String, 
    /**
     * The name of the industrial design.
     */
    var `codename`: kotlin.String, 
    /**
     * The device's UUID.
     */
    var `uuid`: kotlin.String, 
    /**
     * The country/region code, in ISO 3166 2-letter code, or a UN M.49 3-digit code.
     */
    var `country`: kotlin.String, 
    /**
     * If device/OS is rooted/jailbroken.
     */
    var `rooted`: kotlin.Boolean, 
    /**
     * The current scaling factor for fonts, relative to the base density scaling.
     */
    var `fontScale`: kotlin.String, 
    /**
     * The total size of the device storage in GB.
     */
    var `storage`: kotlin.Double, 
    /**
     * If the device (or current context) is using dark mode.
     */
    var `darkMode`: kotlin.Boolean, 
    /**
     * List of enabled input methods application name (e.g. packageName, bundle id).
     */
    var `keyboards`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDeviceInfo: FfiConverterRustBuffer<DeviceInfo> {
    override fun read(buf: ByteBuffer): DeviceInfo {
        return DeviceInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: DeviceInfo) = (
            FfiConverterString.allocationSize(value.`language`) +
            FfiConverterString.allocationSize(value.`timezone`) +
            FfiConverterInt.allocationSize(value.`timezoneOffset`) +
            FfiConverterString.allocationSize(value.`model`) +
            FfiConverterString.allocationSize(value.`brand`) +
            FfiConverterString.allocationSize(value.`codename`) +
            FfiConverterString.allocationSize(value.`uuid`) +
            FfiConverterString.allocationSize(value.`country`) +
            FfiConverterBoolean.allocationSize(value.`rooted`) +
            FfiConverterString.allocationSize(value.`fontScale`) +
            FfiConverterDouble.allocationSize(value.`storage`) +
            FfiConverterBoolean.allocationSize(value.`darkMode`) +
            FfiConverterSequenceString.allocationSize(value.`keyboards`)
    )

    override fun write(value: DeviceInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`language`, buf)
            FfiConverterString.write(value.`timezone`, buf)
            FfiConverterInt.write(value.`timezoneOffset`, buf)
            FfiConverterString.write(value.`model`, buf)
            FfiConverterString.write(value.`brand`, buf)
            FfiConverterString.write(value.`codename`, buf)
            FfiConverterString.write(value.`uuid`, buf)
            FfiConverterString.write(value.`country`, buf)
            FfiConverterBoolean.write(value.`rooted`, buf)
            FfiConverterString.write(value.`fontScale`, buf)
            FfiConverterDouble.write(value.`storage`, buf)
            FfiConverterBoolean.write(value.`darkMode`, buf)
            FfiConverterSequenceString.write(value.`keyboards`, buf)
    }
}



data class DraftAddressValidationResult (
    var `email`: kotlin.String, 
    var `error`: DraftAddressValidationError
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAddressValidationResult: FfiConverterRustBuffer<DraftAddressValidationResult> {
    override fun read(buf: ByteBuffer): DraftAddressValidationResult {
        return DraftAddressValidationResult(
            FfiConverterString.read(buf),
            FfiConverterTypeDraftAddressValidationError.read(buf),
        )
    }

    override fun allocationSize(value: DraftAddressValidationResult) = (
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterTypeDraftAddressValidationError.allocationSize(value.`error`)
    )

    override fun write(value: DraftAddressValidationResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`email`, buf)
            FfiConverterTypeDraftAddressValidationError.write(value.`error`, buf)
    }
}



/**
 * Represents a attachment associated with a draft.
 */
data class DraftAttachment (
    /**
     * The state at which this attachment finds itself.
     */
    var `state`: DraftAttachmentState, 
    /**
     * Metadata related to the attachment.
     */
    var `attachment`: AttachmentMetadata, 
    /**
     * Timestamp of the status change
     */
    var `stateModifiedTimestamp`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachment: FfiConverterRustBuffer<DraftAttachment> {
    override fun read(buf: ByteBuffer): DraftAttachment {
        return DraftAttachment(
            FfiConverterTypeDraftAttachmentState.read(buf),
            FfiConverterTypeAttachmentMetadata.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: DraftAttachment) = (
            FfiConverterTypeDraftAttachmentState.allocationSize(value.`state`) +
            FfiConverterTypeAttachmentMetadata.allocationSize(value.`attachment`) +
            FfiConverterLong.allocationSize(value.`stateModifiedTimestamp`)
    )

    override fun write(value: DraftAttachment, buf: ByteBuffer) {
            FfiConverterTypeDraftAttachmentState.write(value.`state`, buf)
            FfiConverterTypeAttachmentMetadata.write(value.`attachment`, buf)
            FfiConverterLong.write(value.`stateModifiedTimestamp`, buf)
    }
}



data class DraftCancelScheduledSendInfo (
    var `lastScheduledTime`: UnixTimestamp
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftCancelScheduledSendInfo: FfiConverterRustBuffer<DraftCancelScheduledSendInfo> {
    override fun read(buf: ByteBuffer): DraftCancelScheduledSendInfo {
        return DraftCancelScheduledSendInfo(
            FfiConverterTypeUnixTimestamp.read(buf),
        )
    }

    override fun allocationSize(value: DraftCancelScheduledSendInfo) = (
            FfiConverterTypeUnixTimestamp.allocationSize(value.`lastScheduledTime`)
    )

    override fun write(value: DraftCancelScheduledSendInfo, buf: ByteBuffer) {
            FfiConverterTypeUnixTimestamp.write(value.`lastScheduledTime`, buf)
    }
}



data class DraftPassword (
    var `password`: kotlin.String, 
    var `hint`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftPassword: FfiConverterRustBuffer<DraftPassword> {
    override fun read(buf: ByteBuffer): DraftPassword {
        return DraftPassword(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: DraftPassword) = (
            FfiConverterString.allocationSize(value.`password`) +
            FfiConverterOptionalString.allocationSize(value.`hint`)
    )

    override fun write(value: DraftPassword, buf: ByteBuffer) {
            FfiConverterString.write(value.`password`, buf)
            FfiConverterOptionalString.write(value.`hint`, buf)
    }
}



data class DraftRecipientExpirationFeatureReport (
    var `supported`: List<kotlin.String>, 
    var `unsupported`: List<kotlin.String>, 
    var `unknown`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftRecipientExpirationFeatureReport: FfiConverterRustBuffer<DraftRecipientExpirationFeatureReport> {
    override fun read(buf: ByteBuffer): DraftRecipientExpirationFeatureReport {
        return DraftRecipientExpirationFeatureReport(
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: DraftRecipientExpirationFeatureReport) = (
            FfiConverterSequenceString.allocationSize(value.`supported`) +
            FfiConverterSequenceString.allocationSize(value.`unsupported`) +
            FfiConverterSequenceString.allocationSize(value.`unknown`)
    )

    override fun write(value: DraftRecipientExpirationFeatureReport, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`supported`, buf)
            FfiConverterSequenceString.write(value.`unsupported`, buf)
            FfiConverterSequenceString.write(value.`unknown`, buf)
    }
}



data class DraftScheduleSendOptions (
    var `tomorrowTime`: UnixTimestamp, 
    var `mondayTime`: UnixTimestamp, 
    var `isCustomOptionAvailable`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftScheduleSendOptions: FfiConverterRustBuffer<DraftScheduleSendOptions> {
    override fun read(buf: ByteBuffer): DraftScheduleSendOptions {
        return DraftScheduleSendOptions(
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: DraftScheduleSendOptions) = (
            FfiConverterTypeUnixTimestamp.allocationSize(value.`tomorrowTime`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`mondayTime`) +
            FfiConverterBoolean.allocationSize(value.`isCustomOptionAvailable`)
    )

    override fun write(value: DraftScheduleSendOptions, buf: ByteBuffer) {
            FfiConverterTypeUnixTimestamp.write(value.`tomorrowTime`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`mondayTime`, buf)
            FfiConverterBoolean.write(value.`isCustomOptionAvailable`, buf)
    }
}



/**
 * Result of sending a draft
 */
data class DraftSendResult (
    /**
     * The id of draft message
     */
    var `messageId`: Id, 
    /**
     * Timestamp at which the operation recorded
     */
    var `timestamp`: UnixTimestamp, 
    /**
     * Success or failure status.
     */
    var `error`: DraftSendStatus, 
    /**
     * Where this report originated from.
     */
    var `origin`: DraftSendResultOrigin
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendResult: FfiConverterRustBuffer<DraftSendResult> {
    override fun read(buf: ByteBuffer): DraftSendResult {
        return DraftSendResult(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeDraftSendStatus.read(buf),
            FfiConverterTypeDraftSendResultOrigin.read(buf),
        )
    }

    override fun allocationSize(value: DraftSendResult) = (
            FfiConverterTypeId.allocationSize(value.`messageId`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`timestamp`) +
            FfiConverterTypeDraftSendStatus.allocationSize(value.`error`) +
            FfiConverterTypeDraftSendResultOrigin.allocationSize(value.`origin`)
    )

    override fun write(value: DraftSendResult, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`messageId`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`timestamp`, buf)
            FfiConverterTypeDraftSendStatus.write(value.`error`, buf)
            FfiConverterTypeDraftSendResultOrigin.write(value.`origin`, buf)
    }
}



data class DraftSenderAddressList (
    /**
     * All available addresses which can be used for sending, also includes the
     * `active` address.
     */
    var `available`: List<kotlin.String>, 
    /**
     * The current active address.
     */
    var `active`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSenderAddressList: FfiConverterRustBuffer<DraftSenderAddressList> {
    override fun read(buf: ByteBuffer): DraftSenderAddressList {
        return DraftSenderAddressList(
            FfiConverterSequenceString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DraftSenderAddressList) = (
            FfiConverterSequenceString.allocationSize(value.`available`) +
            FfiConverterString.allocationSize(value.`active`)
    )

    override fun write(value: DraftSenderAddressList, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`available`, buf)
            FfiConverterString.write(value.`active`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Email (
    /**
     * TODO: Document this field.
     */
    var `notify`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `reset`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `status`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEmail: FfiConverterRustBuffer<Email> {
    override fun read(buf: ByteBuffer): Email {
        return Email(
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Email) = (
            FfiConverterUByte.allocationSize(value.`notify`) +
            FfiConverterUByte.allocationSize(value.`reset`) +
            FfiConverterUByte.allocationSize(value.`status`) +
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: Email, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`notify`, buf)
            FfiConverterUByte.write(value.`reset`, buf)
            FfiConverterUByte.write(value.`status`, buf)
            FfiConverterString.write(value.`value`, buf)
    }
}



data class EncryptedPushNotification (
    var `sessionId`: kotlin.String, 
    var `encryptedMessage`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEncryptedPushNotification: FfiConverterRustBuffer<EncryptedPushNotification> {
    override fun read(buf: ByteBuffer): EncryptedPushNotification {
        return EncryptedPushNotification(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: EncryptedPushNotification) = (
            FfiConverterString.allocationSize(value.`sessionId`) +
            FfiConverterString.allocationSize(value.`encryptedMessage`)
    )

    override fun write(value: EncryptedPushNotification, buf: ByteBuffer) {
            FfiConverterString.write(value.`sessionId`, buf)
            FfiConverterString.write(value.`encryptedMessage`, buf)
    }
}



data class ExtendedName (
    var `last`: kotlin.String?, 
    var `first`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeExtendedName: FfiConverterRustBuffer<ExtendedName> {
    override fun read(buf: ByteBuffer): ExtendedName {
        return ExtendedName(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ExtendedName) = (
            FfiConverterOptionalString.allocationSize(value.`last`) +
            FfiConverterOptionalString.allocationSize(value.`first`)
    )

    override fun write(value: ExtendedName, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`last`, buf)
            FfiConverterOptionalString.write(value.`first`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class FidoKey (
    /**
     * TODO: Document this field.
     */
    var `attestationFormat`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `credentialId`: List<kotlin.Int>, 
    /**
     * TODO: Document this field.
     */
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFidoKey: FfiConverterRustBuffer<FidoKey> {
    override fun read(buf: ByteBuffer): FidoKey {
        return FidoKey(
            FfiConverterString.read(buf),
            FfiConverterSequenceInt.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: FidoKey) = (
            FfiConverterString.allocationSize(value.`attestationFormat`) +
            FfiConverterSequenceInt.allocationSize(value.`credentialId`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: FidoKey, buf: ByteBuffer) {
            FfiConverterString.write(value.`attestationFormat`, buf)
            FfiConverterSequenceInt.write(value.`credentialId`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Flags (
    /**
     * TODO: Document this field.
     */
    var `hasTemporaryPassword`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `noLogin`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `noProtonAddress`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `onboardChecklistStorageGranted`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `protected`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `recoveryAttempt`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `sso`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `testAccount`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFlags: FfiConverterRustBuffer<Flags> {
    override fun read(buf: ByteBuffer): Flags {
        return Flags(
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Flags) = (
            FfiConverterBoolean.allocationSize(value.`hasTemporaryPassword`) +
            FfiConverterBoolean.allocationSize(value.`noLogin`) +
            FfiConverterBoolean.allocationSize(value.`noProtonAddress`) +
            FfiConverterBoolean.allocationSize(value.`onboardChecklistStorageGranted`) +
            FfiConverterBoolean.allocationSize(value.`protected`) +
            FfiConverterBoolean.allocationSize(value.`recoveryAttempt`) +
            FfiConverterBoolean.allocationSize(value.`sso`) +
            FfiConverterBoolean.allocationSize(value.`testAccount`)
    )

    override fun write(value: Flags, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`hasTemporaryPassword`, buf)
            FfiConverterBoolean.write(value.`noLogin`, buf)
            FfiConverterBoolean.write(value.`noProtonAddress`, buf)
            FfiConverterBoolean.write(value.`onboardChecklistStorageGranted`, buf)
            FfiConverterBoolean.write(value.`protected`, buf)
            FfiConverterBoolean.write(value.`recoveryAttempt`, buf)
            FfiConverterBoolean.write(value.`sso`, buf)
            FfiConverterBoolean.write(value.`testAccount`, buf)
    }
}



data class GeneralDimensions (
    var `upsellEntryPoint`: UpsellEntryPoint, 
    var `planBeforeUpgrade`: kotlin.String, 
    var `modalVariant`: ModalVariant
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGeneralDimensions: FfiConverterRustBuffer<GeneralDimensions> {
    override fun read(buf: ByteBuffer): GeneralDimensions {
        return GeneralDimensions(
            FfiConverterTypeUpsellEntryPoint.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeModalVariant.read(buf),
        )
    }

    override fun allocationSize(value: GeneralDimensions) = (
            FfiConverterTypeUpsellEntryPoint.allocationSize(value.`upsellEntryPoint`) +
            FfiConverterString.allocationSize(value.`planBeforeUpgrade`) +
            FfiConverterTypeModalVariant.allocationSize(value.`modalVariant`)
    )

    override fun write(value: GeneralDimensions, buf: ByteBuffer) {
            FfiConverterTypeUpsellEntryPoint.write(value.`upsellEntryPoint`, buf)
            FfiConverterString.write(value.`planBeforeUpgrade`, buf)
            FfiConverterTypeModalVariant.write(value.`modalVariant`, buf)
    }
}



/**
 * Options for getting payments plans.
 */
data class GetPaymentsPlansOptions (
    var `currency`: kotlin.String?, 
    var `vendor`: kotlin.String?, 
    var `state`: kotlin.UByte?, 
    var `timestamp`: kotlin.ULong?, 
    var `fallback`: kotlin.Boolean?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetPaymentsPlansOptions: FfiConverterRustBuffer<GetPaymentsPlansOptions> {
    override fun read(buf: ByteBuffer): GetPaymentsPlansOptions {
        return GetPaymentsPlansOptions(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: GetPaymentsPlansOptions) = (
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterOptionalString.allocationSize(value.`vendor`) +
            FfiConverterOptionalUByte.allocationSize(value.`state`) +
            FfiConverterOptionalULong.allocationSize(value.`timestamp`) +
            FfiConverterOptionalBoolean.allocationSize(value.`fallback`)
    )

    override fun write(value: GetPaymentsPlansOptions, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterOptionalString.write(value.`vendor`, buf)
            FfiConverterOptionalUByte.write(value.`state`, buf)
            FfiConverterOptionalULong.write(value.`timestamp`, buf)
            FfiConverterOptionalBoolean.write(value.`fallback`, buf)
    }
}



data class GoogleRecurringReceiptDetails (
    var `orderId`: kotlin.String, 
    var `customerId`: kotlin.String, 
    var `productId`: kotlin.String, 
    var `packageName`: kotlin.String, 
    var `token`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGoogleRecurringReceiptDetails: FfiConverterRustBuffer<GoogleRecurringReceiptDetails> {
    override fun read(buf: ByteBuffer): GoogleRecurringReceiptDetails {
        return GoogleRecurringReceiptDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: GoogleRecurringReceiptDetails) = (
            FfiConverterString.allocationSize(value.`orderId`) +
            FfiConverterString.allocationSize(value.`customerId`) +
            FfiConverterString.allocationSize(value.`productId`) +
            FfiConverterString.allocationSize(value.`packageName`) +
            FfiConverterString.allocationSize(value.`token`)
    )

    override fun write(value: GoogleRecurringReceiptDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`orderId`, buf)
            FfiConverterString.write(value.`customerId`, buf)
            FfiConverterString.write(value.`productId`, buf)
            FfiConverterString.write(value.`packageName`, buf)
            FfiConverterString.write(value.`token`, buf)
    }
}



/**
 * This is the main data structure that is used to represent the group of contacts.
 */
data class GroupedContacts (
    /**
     * The field represent first grapheme of the name of the contact
     */
    var `groupedBy`: kotlin.String, 
    var `items`: List<ContactItemType>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGroupedContacts: FfiConverterRustBuffer<GroupedContacts> {
    override fun read(buf: ByteBuffer): GroupedContacts {
        return GroupedContacts(
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeContactItemType.read(buf),
        )
    }

    override fun allocationSize(value: GroupedContacts) = (
            FfiConverterString.allocationSize(value.`groupedBy`) +
            FfiConverterSequenceTypeContactItemType.allocationSize(value.`items`)
    )

    override fun write(value: GroupedContacts, buf: ByteBuffer) {
            FfiConverterString.write(value.`groupedBy`, buf)
            FfiConverterSequenceTypeContactItemType.write(value.`items`, buf)
    }
}



data class Header (
    var `key`: kotlin.String, 
    var `val`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHeader: FfiConverterRustBuffer<Header> {
    override fun read(buf: ByteBuffer): Header {
        return Header(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Header) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterString.allocationSize(value.`val`)
    )

    override fun write(value: Header, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterString.write(value.`val`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class HighSecurity (
    /**
     * TODO: Document this field.
     */
    var `eligible`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `value`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHighSecurity: FfiConverterRustBuffer<HighSecurity> {
    override fun read(buf: ByteBuffer): HighSecurity {
        return HighSecurity(
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: HighSecurity) = (
            FfiConverterBoolean.allocationSize(value.`eligible`) +
            FfiConverterBoolean.allocationSize(value.`value`)
    )

    override fun write(value: HighSecurity, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`eligible`, buf)
            FfiConverterBoolean.write(value.`value`, buf)
    }
}



/**
 * Local ID.
 *
 * This minimal struct is simply a wrapper around a [`u64`], and is used to
 * formalise all IDs used internally for saving to the database.

 */
data class Id (
    var `value`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeId: FfiConverterRustBuffer<Id> {
    override fun read(buf: ByteBuffer): Id {
        return Id(
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: Id) = (
            FfiConverterULong.allocationSize(value.`value`)
    )

    override fun write(value: Id, buf: ByteBuffer) {
            FfiConverterULong.write(value.`value`, buf)
    }
}



data class InlineCustomLabel (
    var `id`: Id, 
    var `name`: kotlin.String, 
    var `color`: LabelColor
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeInlineCustomLabel: FfiConverterRustBuffer<InlineCustomLabel> {
    override fun read(buf: ByteBuffer): InlineCustomLabel {
        return InlineCustomLabel(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeLabelColor.read(buf),
        )
    }

    override fun allocationSize(value: InlineCustomLabel) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeLabelColor.allocationSize(value.`color`)
    )

    override fun write(value: InlineCustomLabel, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeLabelColor.write(value.`color`, buf)
    }
}



data class IosShareExtAttachment (
    var `path`: kotlin.String, 
    var `name`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIosShareExtAttachment: FfiConverterRustBuffer<IosShareExtAttachment> {
    override fun read(buf: ByteBuffer): IosShareExtAttachment {
        return IosShareExtAttachment(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: IosShareExtAttachment) = (
            FfiConverterString.allocationSize(value.`path`) +
            FfiConverterOptionalString.allocationSize(value.`name`)
    )

    override fun write(value: IosShareExtAttachment, buf: ByteBuffer) {
            FfiConverterString.write(value.`path`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
    }
}



data class IosShareExtDraft (
    var `subject`: kotlin.String?, 
    var `body`: kotlin.String?, 
    var `inlineAttachments`: List<IosShareExtAttachment>, 
    var `attachments`: List<IosShareExtAttachment>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIosShareExtDraft: FfiConverterRustBuffer<IosShareExtDraft> {
    override fun read(buf: ByteBuffer): IosShareExtDraft {
        return IosShareExtDraft(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceTypeIosShareExtAttachment.read(buf),
            FfiConverterSequenceTypeIosShareExtAttachment.read(buf),
        )
    }

    override fun allocationSize(value: IosShareExtDraft) = (
            FfiConverterOptionalString.allocationSize(value.`subject`) +
            FfiConverterOptionalString.allocationSize(value.`body`) +
            FfiConverterSequenceTypeIosShareExtAttachment.allocationSize(value.`inlineAttachments`) +
            FfiConverterSequenceTypeIosShareExtAttachment.allocationSize(value.`attachments`)
    )

    override fun write(value: IosShareExtDraft, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`subject`, buf)
            FfiConverterOptionalString.write(value.`body`, buf)
            FfiConverterSequenceTypeIosShareExtAttachment.write(value.`inlineAttachments`, buf)
            FfiConverterSequenceTypeIosShareExtAttachment.write(value.`attachments`, buf)
    }
}



/**
 * Representation of User's Report of an issue.
 */
data class IssueReport (
    /**
     * Name of the operating system app was run in.
     *
     * Provided by the client.
     *
     * # Example
     *
     * `iOS - iPhone`
     */
    var `operatingSystem`: kotlin.String, 
    /**
     * Vesion of the operating system installed on the device.
     *
     * # Example
     *
     * `18.4`
     */
    var `operatingSystemVersion`: kotlin.String, 
    /**
     * Name of the client
     *
     * Provided by the client.
     *
     * # Example
     *
     * `iOS_Native`
     */
    var `client`: kotlin.String, 
    /**
     * Version of the client application
     *
     * It is not verified but Semantic Versioning is encouraged.
     * Provided by the client.
     *
     * # Example
     *
     * `4.20.0`
     */
    var `clientVersion`: kotlin.String, 
    /**
     * Type of client application
     *
     * Provided by the client.
     *
     * # Example
     *
     * `1` - Email
     */
    var `clientType`: ClientType, 
    /**
     * Common title for the client.
     *
     * Provided by the client.
     *
     * # Example
     *
     * `Proton Mail App bug report`
     */
    var `title`: kotlin.String, 
    /**
     * Summary of the stumbled upon issue.
     *
     * The string has to be at least 10 characters long.
     * Depicts incident, it is provided by the user.
     */
    var `summary`: kotlin.String, 
    /**
     * The steps needed to reproduce the issue.
     *
     * Can be empty.
     * Provided by the user.
     */
    var `stepsToReproduce`: kotlin.String, 
    /**
     * User's expected behavior.
     *
     * Can be empty.
     * Provided by the user.
     */
    var `expectedResult`: kotlin.String, 
    /**
     * What happened instead.
     *
     * Can be empty.
     * Provided by the user.
     */
    var `actualResult`: kotlin.String, 
    /**
     * Permission to attach the logs to the report.
     *
     * User gave permission to share the logs with bug report
     * by selecting an option in the client app.
     */
    var `logs`: kotlin.Boolean, 
    /**
     * List of additional file paths to include in the issue report.
     *
     * Must be file system paths, not URI resources.
     */
    var `additionalFiles`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIssueReport: FfiConverterRustBuffer<IssueReport> {
    override fun read(buf: ByteBuffer): IssueReport {
        return IssueReport(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeClientType.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: IssueReport) = (
            FfiConverterString.allocationSize(value.`operatingSystem`) +
            FfiConverterString.allocationSize(value.`operatingSystemVersion`) +
            FfiConverterString.allocationSize(value.`client`) +
            FfiConverterString.allocationSize(value.`clientVersion`) +
            FfiConverterTypeClientType.allocationSize(value.`clientType`) +
            FfiConverterString.allocationSize(value.`title`) +
            FfiConverterString.allocationSize(value.`summary`) +
            FfiConverterString.allocationSize(value.`stepsToReproduce`) +
            FfiConverterString.allocationSize(value.`expectedResult`) +
            FfiConverterString.allocationSize(value.`actualResult`) +
            FfiConverterBoolean.allocationSize(value.`logs`) +
            FfiConverterSequenceString.allocationSize(value.`additionalFiles`)
    )

    override fun write(value: IssueReport, buf: ByteBuffer) {
            FfiConverterString.write(value.`operatingSystem`, buf)
            FfiConverterString.write(value.`operatingSystemVersion`, buf)
            FfiConverterString.write(value.`client`, buf)
            FfiConverterString.write(value.`clientVersion`, buf)
            FfiConverterTypeClientType.write(value.`clientType`, buf)
            FfiConverterString.write(value.`title`, buf)
            FfiConverterString.write(value.`summary`, buf)
            FfiConverterString.write(value.`stepsToReproduce`, buf)
            FfiConverterString.write(value.`expectedResult`, buf)
            FfiConverterString.write(value.`actualResult`, buf)
            FfiConverterBoolean.write(value.`logs`, buf)
            FfiConverterSequenceString.write(value.`additionalFiles`, buf)
    }
}



/**
 * This struct represents a label that can be used as an action.

 */
data class LabelAsAction (
    var `labelId`: Id, 
    var `name`: kotlin.String, 
    var `color`: LabelColor, 
    var `order`: kotlin.UInt, 
    var `isSelected`: IsSelected
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelAsAction: FfiConverterRustBuffer<LabelAsAction> {
    override fun read(buf: ByteBuffer): LabelAsAction {
        return LabelAsAction(
            FfiConverterTypeId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeLabelColor.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypeIsSelected.read(buf),
        )
    }

    override fun allocationSize(value: LabelAsAction) = (
            FfiConverterTypeId.allocationSize(value.`labelId`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeLabelColor.allocationSize(value.`color`) +
            FfiConverterUInt.allocationSize(value.`order`) +
            FfiConverterTypeIsSelected.allocationSize(value.`isSelected`)
    )

    override fun write(value: LabelAsAction, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`labelId`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeLabelColor.write(value.`color`, buf)
            FfiConverterUInt.write(value.`order`, buf)
            FfiConverterTypeIsSelected.write(value.`isSelected`, buf)
    }
}



data class LabelAsOutput (
    var `inputLabelIsEmpty`: kotlin.Boolean, 
    var `undo`: Undo?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`inputLabelIsEmpty`,
        this.`undo`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelAsOutput: FfiConverterRustBuffer<LabelAsOutput> {
    override fun read(buf: ByteBuffer): LabelAsOutput {
        return LabelAsOutput(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeUndo.read(buf),
        )
    }

    override fun allocationSize(value: LabelAsOutput) = (
            FfiConverterBoolean.allocationSize(value.`inputLabelIsEmpty`) +
            FfiConverterOptionalTypeUndo.allocationSize(value.`undo`)
    )

    override fun write(value: LabelAsOutput, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`inputLabelIsEmpty`, buf)
            FfiConverterOptionalTypeUndo.write(value.`undo`, buf)
    }
}



data class LabelColor (
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelColor: FfiConverterRustBuffer<LabelColor> {
    override fun read(buf: ByteBuffer): LabelColor {
        return LabelColor(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LabelColor) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: LabelColor, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



data class Location (
    var `countryCode`: kotlin.String?, 
    var `state`: kotlin.String?, 
    var `zipCode`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLocation: FfiConverterRustBuffer<Location> {
    override fun read(buf: ByteBuffer): Location {
        return Location(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: Location) = (
            FfiConverterOptionalString.allocationSize(value.`countryCode`) +
            FfiConverterOptionalString.allocationSize(value.`state`) +
            FfiConverterOptionalString.allocationSize(value.`zipCode`)
    )

    override fun write(value: Location, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`countryCode`, buf)
            FfiConverterOptionalString.write(value.`state`, buf)
            FfiConverterOptionalString.write(value.`zipCode`, buf)
    }
}



data class MailSessionParams (
    var `origin`: Origin, 
    var `sessionDir`: kotlin.String, 
    var `userDir`: kotlin.String, 
    var `mailCacheDir`: kotlin.String, 
    var `mailCacheSize`: kotlin.ULong, 
    var `logDir`: kotlin.String, 
    var `logDebug`: kotlin.Boolean, 
    var `apiEnvConfig`: ApiConfig?, 
    var `appDetails`: AppDetails, 
    var `eventPollDurationSeconds`: kotlin.ULong?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`origin`,
        this.`sessionDir`,
        this.`userDir`,
        this.`mailCacheDir`,
        this.`mailCacheSize`,
        this.`logDir`,
        this.`logDebug`,
        this.`apiEnvConfig`,
        this.`appDetails`,
        this.`eventPollDurationSeconds`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionParams: FfiConverterRustBuffer<MailSessionParams> {
    override fun read(buf: ByteBuffer): MailSessionParams {
        return MailSessionParams(
            FfiConverterTypeOrigin.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeApiConfig.read(buf),
            FfiConverterTypeAppDetails.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: MailSessionParams) = (
            FfiConverterTypeOrigin.allocationSize(value.`origin`) +
            FfiConverterString.allocationSize(value.`sessionDir`) +
            FfiConverterString.allocationSize(value.`userDir`) +
            FfiConverterString.allocationSize(value.`mailCacheDir`) +
            FfiConverterULong.allocationSize(value.`mailCacheSize`) +
            FfiConverterString.allocationSize(value.`logDir`) +
            FfiConverterBoolean.allocationSize(value.`logDebug`) +
            FfiConverterOptionalTypeApiConfig.allocationSize(value.`apiEnvConfig`) +
            FfiConverterTypeAppDetails.allocationSize(value.`appDetails`) +
            FfiConverterOptionalULong.allocationSize(value.`eventPollDurationSeconds`)
    )

    override fun write(value: MailSessionParams, buf: ByteBuffer) {
            FfiConverterTypeOrigin.write(value.`origin`, buf)
            FfiConverterString.write(value.`sessionDir`, buf)
            FfiConverterString.write(value.`userDir`, buf)
            FfiConverterString.write(value.`mailCacheDir`, buf)
            FfiConverterULong.write(value.`mailCacheSize`, buf)
            FfiConverterString.write(value.`logDir`, buf)
            FfiConverterBoolean.write(value.`logDebug`, buf)
            FfiConverterOptionalTypeApiConfig.write(value.`apiEnvConfig`, buf)
            FfiConverterTypeAppDetails.write(value.`appDetails`, buf)
            FfiConverterOptionalULong.write(value.`eventPollDurationSeconds`, buf)
    }
}



data class MailSettings (
    var `almostAllMail`: AlmostAllMail, 
    var `attachPublicKey`: kotlin.Boolean, 
    var `autoDeleteSpamAndTrashDays`: kotlin.UInt?, 
    var `autoSaveContacts`: kotlin.Boolean, 
    var `blockSenderConfirmation`: kotlin.Boolean?, 
    var `composerMode`: ComposerMode, 
    var `confirmLink`: kotlin.Boolean, 
    var `delaySendSeconds`: kotlin.UInt, 
    var `displayName`: kotlin.String, 
    var `draftMimeType`: MimeType, 
    var `enableFolderColor`: kotlin.Boolean, 
    var `fontFace`: kotlin.String?, 
    var `hideRemoteImages`: kotlin.Boolean, 
    var `hideEmbeddedImages`: kotlin.Boolean, 
    var `hideSenderImages`: kotlin.Boolean, 
    var `imageProxy`: kotlin.UInt, 
    var `inheritParentFolderColor`: kotlin.Boolean, 
    var `messageButtons`: MessageButtons, 
    var `mobileSettings`: MobileSettings?, 
    var `nextMessageOnMove`: NextMessageOnMove?, 
    var `numMessagePerPage`: kotlin.UInt, 
    var `pgpScheme`: PgpScheme, 
    var `pmSignature`: PmSignature, 
    var `pmSignatureReferralLink`: kotlin.Boolean, 
    var `promptPin`: kotlin.Boolean, 
    var `receiveMimeType`: MimeType, 
    var `rightToLeft`: ComposerDirection, 
    var `shortcuts`: kotlin.Boolean, 
    var `showImages`: ShowImages, 
    var `showMimeType`: MimeType, 
    var `showMoved`: ShowMoved, 
    var `sign`: kotlin.Boolean, 
    var `signature`: kotlin.String, 
    var `spamAction`: SpamAction?, 
    var `stickyLabels`: kotlin.Boolean, 
    var `submissionAccess`: kotlin.Boolean, 
    var `swipeLeft`: SwipeAction, 
    var `swipeRight`: SwipeAction, 
    var `theme`: kotlin.String, 
    var `viewLayout`: ViewLayout, 
    var `viewMode`: ViewMode
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSettings: FfiConverterRustBuffer<MailSettings> {
    override fun read(buf: ByteBuffer): MailSettings {
        return MailSettings(
            FfiConverterTypeAlmostAllMail.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterTypeComposerMode.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeMimeType.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeMessageButtons.read(buf),
            FfiConverterOptionalTypeMobileSettings.read(buf),
            FfiConverterOptionalTypeNextMessageOnMove.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypePgpScheme.read(buf),
            FfiConverterTypePmSignature.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeMimeType.read(buf),
            FfiConverterTypeComposerDirection.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeShowImages.read(buf),
            FfiConverterTypeMimeType.read(buf),
            FfiConverterTypeShowMoved.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeSpamAction.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeSwipeAction.read(buf),
            FfiConverterTypeSwipeAction.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeViewLayout.read(buf),
            FfiConverterTypeViewMode.read(buf),
        )
    }

    override fun allocationSize(value: MailSettings) = (
            FfiConverterTypeAlmostAllMail.allocationSize(value.`almostAllMail`) +
            FfiConverterBoolean.allocationSize(value.`attachPublicKey`) +
            FfiConverterOptionalUInt.allocationSize(value.`autoDeleteSpamAndTrashDays`) +
            FfiConverterBoolean.allocationSize(value.`autoSaveContacts`) +
            FfiConverterOptionalBoolean.allocationSize(value.`blockSenderConfirmation`) +
            FfiConverterTypeComposerMode.allocationSize(value.`composerMode`) +
            FfiConverterBoolean.allocationSize(value.`confirmLink`) +
            FfiConverterUInt.allocationSize(value.`delaySendSeconds`) +
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterTypeMimeType.allocationSize(value.`draftMimeType`) +
            FfiConverterBoolean.allocationSize(value.`enableFolderColor`) +
            FfiConverterOptionalString.allocationSize(value.`fontFace`) +
            FfiConverterBoolean.allocationSize(value.`hideRemoteImages`) +
            FfiConverterBoolean.allocationSize(value.`hideEmbeddedImages`) +
            FfiConverterBoolean.allocationSize(value.`hideSenderImages`) +
            FfiConverterUInt.allocationSize(value.`imageProxy`) +
            FfiConverterBoolean.allocationSize(value.`inheritParentFolderColor`) +
            FfiConverterTypeMessageButtons.allocationSize(value.`messageButtons`) +
            FfiConverterOptionalTypeMobileSettings.allocationSize(value.`mobileSettings`) +
            FfiConverterOptionalTypeNextMessageOnMove.allocationSize(value.`nextMessageOnMove`) +
            FfiConverterUInt.allocationSize(value.`numMessagePerPage`) +
            FfiConverterTypePgpScheme.allocationSize(value.`pgpScheme`) +
            FfiConverterTypePmSignature.allocationSize(value.`pmSignature`) +
            FfiConverterBoolean.allocationSize(value.`pmSignatureReferralLink`) +
            FfiConverterBoolean.allocationSize(value.`promptPin`) +
            FfiConverterTypeMimeType.allocationSize(value.`receiveMimeType`) +
            FfiConverterTypeComposerDirection.allocationSize(value.`rightToLeft`) +
            FfiConverterBoolean.allocationSize(value.`shortcuts`) +
            FfiConverterTypeShowImages.allocationSize(value.`showImages`) +
            FfiConverterTypeMimeType.allocationSize(value.`showMimeType`) +
            FfiConverterTypeShowMoved.allocationSize(value.`showMoved`) +
            FfiConverterBoolean.allocationSize(value.`sign`) +
            FfiConverterString.allocationSize(value.`signature`) +
            FfiConverterOptionalTypeSpamAction.allocationSize(value.`spamAction`) +
            FfiConverterBoolean.allocationSize(value.`stickyLabels`) +
            FfiConverterBoolean.allocationSize(value.`submissionAccess`) +
            FfiConverterTypeSwipeAction.allocationSize(value.`swipeLeft`) +
            FfiConverterTypeSwipeAction.allocationSize(value.`swipeRight`) +
            FfiConverterString.allocationSize(value.`theme`) +
            FfiConverterTypeViewLayout.allocationSize(value.`viewLayout`) +
            FfiConverterTypeViewMode.allocationSize(value.`viewMode`)
    )

    override fun write(value: MailSettings, buf: ByteBuffer) {
            FfiConverterTypeAlmostAllMail.write(value.`almostAllMail`, buf)
            FfiConverterBoolean.write(value.`attachPublicKey`, buf)
            FfiConverterOptionalUInt.write(value.`autoDeleteSpamAndTrashDays`, buf)
            FfiConverterBoolean.write(value.`autoSaveContacts`, buf)
            FfiConverterOptionalBoolean.write(value.`blockSenderConfirmation`, buf)
            FfiConverterTypeComposerMode.write(value.`composerMode`, buf)
            FfiConverterBoolean.write(value.`confirmLink`, buf)
            FfiConverterUInt.write(value.`delaySendSeconds`, buf)
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterTypeMimeType.write(value.`draftMimeType`, buf)
            FfiConverterBoolean.write(value.`enableFolderColor`, buf)
            FfiConverterOptionalString.write(value.`fontFace`, buf)
            FfiConverterBoolean.write(value.`hideRemoteImages`, buf)
            FfiConverterBoolean.write(value.`hideEmbeddedImages`, buf)
            FfiConverterBoolean.write(value.`hideSenderImages`, buf)
            FfiConverterUInt.write(value.`imageProxy`, buf)
            FfiConverterBoolean.write(value.`inheritParentFolderColor`, buf)
            FfiConverterTypeMessageButtons.write(value.`messageButtons`, buf)
            FfiConverterOptionalTypeMobileSettings.write(value.`mobileSettings`, buf)
            FfiConverterOptionalTypeNextMessageOnMove.write(value.`nextMessageOnMove`, buf)
            FfiConverterUInt.write(value.`numMessagePerPage`, buf)
            FfiConverterTypePgpScheme.write(value.`pgpScheme`, buf)
            FfiConverterTypePmSignature.write(value.`pmSignature`, buf)
            FfiConverterBoolean.write(value.`pmSignatureReferralLink`, buf)
            FfiConverterBoolean.write(value.`promptPin`, buf)
            FfiConverterTypeMimeType.write(value.`receiveMimeType`, buf)
            FfiConverterTypeComposerDirection.write(value.`rightToLeft`, buf)
            FfiConverterBoolean.write(value.`shortcuts`, buf)
            FfiConverterTypeShowImages.write(value.`showImages`, buf)
            FfiConverterTypeMimeType.write(value.`showMimeType`, buf)
            FfiConverterTypeShowMoved.write(value.`showMoved`, buf)
            FfiConverterBoolean.write(value.`sign`, buf)
            FfiConverterString.write(value.`signature`, buf)
            FfiConverterOptionalTypeSpamAction.write(value.`spamAction`, buf)
            FfiConverterBoolean.write(value.`stickyLabels`, buf)
            FfiConverterBoolean.write(value.`submissionAccess`, buf)
            FfiConverterTypeSwipeAction.write(value.`swipeLeft`, buf)
            FfiConverterTypeSwipeAction.write(value.`swipeRight`, buf)
            FfiConverterString.write(value.`theme`, buf)
            FfiConverterTypeViewLayout.write(value.`viewLayout`, buf)
            FfiConverterTypeViewMode.write(value.`viewMode`, buf)
    }
}



data class Message (
    var `id`: Id, 
    var `conversationId`: Id, 
    var `addressId`: Id, 
    var `attachmentsMetadata`: List<AttachmentMetadata>, 
    var `bccList`: List<MessageRecipient>, 
    var `ccList`: List<MessageRecipient>, 
    var `location`: ExclusiveLocation?, 
    var `expirationTime`: UnixTimestamp, 
    var `flags`: MessageFlags, 
    var `isForwarded`: kotlin.Boolean, 
    var `isReplied`: kotlin.Boolean, 
    var `isRepliedAll`: kotlin.Boolean, 
    var `numAttachments`: kotlin.UInt, 
    var `displayOrder`: kotlin.ULong, 
    var `sender`: MessageSender, 
    var `size`: kotlin.ULong, 
    var `snoozedUntil`: UnixTimestamp?, 
    var `displaySnoozeReminder`: kotlin.Boolean, 
    var `subject`: kotlin.String, 
    var `time`: UnixTimestamp, 
    var `toList`: List<MessageRecipient>, 
    var `unread`: kotlin.Boolean, 
    var `customLabels`: List<InlineCustomLabel>, 
    var `starred`: kotlin.Boolean, 
    var `avatar`: AvatarInformation, 
    var `isDraft`: kotlin.Boolean, 
    var `isScheduled`: kotlin.Boolean, 
    var `canReply`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessage: FfiConverterRustBuffer<Message> {
    override fun read(buf: ByteBuffer): Message {
        return Message(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeId.read(buf),
            FfiConverterTypeId.read(buf),
            FfiConverterSequenceTypeAttachmentMetadata.read(buf),
            FfiConverterSequenceTypeMessageRecipient.read(buf),
            FfiConverterSequenceTypeMessageRecipient.read(buf),
            FfiConverterOptionalTypeExclusiveLocation.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeMessageFlags.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeMessageSender.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalTypeUnixTimestamp.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterSequenceTypeMessageRecipient.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceTypeInlineCustomLabel.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeAvatarInformation.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Message) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterTypeId.allocationSize(value.`conversationId`) +
            FfiConverterTypeId.allocationSize(value.`addressId`) +
            FfiConverterSequenceTypeAttachmentMetadata.allocationSize(value.`attachmentsMetadata`) +
            FfiConverterSequenceTypeMessageRecipient.allocationSize(value.`bccList`) +
            FfiConverterSequenceTypeMessageRecipient.allocationSize(value.`ccList`) +
            FfiConverterOptionalTypeExclusiveLocation.allocationSize(value.`location`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`expirationTime`) +
            FfiConverterTypeMessageFlags.allocationSize(value.`flags`) +
            FfiConverterBoolean.allocationSize(value.`isForwarded`) +
            FfiConverterBoolean.allocationSize(value.`isReplied`) +
            FfiConverterBoolean.allocationSize(value.`isRepliedAll`) +
            FfiConverterUInt.allocationSize(value.`numAttachments`) +
            FfiConverterULong.allocationSize(value.`displayOrder`) +
            FfiConverterTypeMessageSender.allocationSize(value.`sender`) +
            FfiConverterULong.allocationSize(value.`size`) +
            FfiConverterOptionalTypeUnixTimestamp.allocationSize(value.`snoozedUntil`) +
            FfiConverterBoolean.allocationSize(value.`displaySnoozeReminder`) +
            FfiConverterString.allocationSize(value.`subject`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`time`) +
            FfiConverterSequenceTypeMessageRecipient.allocationSize(value.`toList`) +
            FfiConverterBoolean.allocationSize(value.`unread`) +
            FfiConverterSequenceTypeInlineCustomLabel.allocationSize(value.`customLabels`) +
            FfiConverterBoolean.allocationSize(value.`starred`) +
            FfiConverterTypeAvatarInformation.allocationSize(value.`avatar`) +
            FfiConverterBoolean.allocationSize(value.`isDraft`) +
            FfiConverterBoolean.allocationSize(value.`isScheduled`) +
            FfiConverterBoolean.allocationSize(value.`canReply`)
    )

    override fun write(value: Message, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterTypeId.write(value.`conversationId`, buf)
            FfiConverterTypeId.write(value.`addressId`, buf)
            FfiConverterSequenceTypeAttachmentMetadata.write(value.`attachmentsMetadata`, buf)
            FfiConverterSequenceTypeMessageRecipient.write(value.`bccList`, buf)
            FfiConverterSequenceTypeMessageRecipient.write(value.`ccList`, buf)
            FfiConverterOptionalTypeExclusiveLocation.write(value.`location`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`expirationTime`, buf)
            FfiConverterTypeMessageFlags.write(value.`flags`, buf)
            FfiConverterBoolean.write(value.`isForwarded`, buf)
            FfiConverterBoolean.write(value.`isReplied`, buf)
            FfiConverterBoolean.write(value.`isRepliedAll`, buf)
            FfiConverterUInt.write(value.`numAttachments`, buf)
            FfiConverterULong.write(value.`displayOrder`, buf)
            FfiConverterTypeMessageSender.write(value.`sender`, buf)
            FfiConverterULong.write(value.`size`, buf)
            FfiConverterOptionalTypeUnixTimestamp.write(value.`snoozedUntil`, buf)
            FfiConverterBoolean.write(value.`displaySnoozeReminder`, buf)
            FfiConverterString.write(value.`subject`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`time`, buf)
            FfiConverterSequenceTypeMessageRecipient.write(value.`toList`, buf)
            FfiConverterBoolean.write(value.`unread`, buf)
            FfiConverterSequenceTypeInlineCustomLabel.write(value.`customLabels`, buf)
            FfiConverterBoolean.write(value.`starred`, buf)
            FfiConverterTypeAvatarInformation.write(value.`avatar`, buf)
            FfiConverterBoolean.write(value.`isDraft`, buf)
            FfiConverterBoolean.write(value.`isScheduled`, buf)
            FfiConverterBoolean.write(value.`canReply`, buf)
    }
}



/**
 * Message action sheet grouped by categories for UI display.
 */
data class MessageActionSheet (
    /**
     * Actions for replying (Reply, ReplyAll, Forward)
     */
    var `replyActions`: List<MessageAction>, 
    /**
     * Core message actions (Mark Read/Unread, Star/Unstar, etc.)
     */
    var `messageActions`: List<MessageAction>, 
    /**
     * Movement-related actions (Archive, Trash, Move, etc.)
     */
    var `moveActions`: List<MessageAction>, 
    /**
     * General utility actions (Print, Save PDF, View Headers, etc.)
     */
    var `generalActions`: List<MessageAction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageActionSheet: FfiConverterRustBuffer<MessageActionSheet> {
    override fun read(buf: ByteBuffer): MessageActionSheet {
        return MessageActionSheet(
            FfiConverterSequenceTypeMessageAction.read(buf),
            FfiConverterSequenceTypeMessageAction.read(buf),
            FfiConverterSequenceTypeMessageAction.read(buf),
            FfiConverterSequenceTypeMessageAction.read(buf),
        )
    }

    override fun allocationSize(value: MessageActionSheet) = (
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`replyActions`) +
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`messageActions`) +
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`moveActions`) +
            FfiConverterSequenceTypeMessageAction.allocationSize(value.`generalActions`)
    )

    override fun write(value: MessageActionSheet, buf: ByteBuffer) {
            FfiConverterSequenceTypeMessageAction.write(value.`replyActions`, buf)
            FfiConverterSequenceTypeMessageAction.write(value.`messageActions`, buf)
            FfiConverterSequenceTypeMessageAction.write(value.`moveActions`, buf)
            FfiConverterSequenceTypeMessageAction.write(value.`generalActions`, buf)
    }
}



data class MessageFlags (
    var `value`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageFlags: FfiConverterRustBuffer<MessageFlags> {
    override fun read(buf: ByteBuffer): MessageFlags {
        return MessageFlags(
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: MessageFlags) = (
            FfiConverterULong.allocationSize(value.`value`)
    )

    override fun write(value: MessageFlags, buf: ByteBuffer) {
            FfiConverterULong.write(value.`value`, buf)
    }
}



data class MessageRecipient (
    var `address`: kotlin.String, 
    var `isProton`: kotlin.Boolean, 
    var `name`: kotlin.String, 
    var `group`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageRecipient: FfiConverterRustBuffer<MessageRecipient> {
    override fun read(buf: ByteBuffer): MessageRecipient {
        return MessageRecipient(
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: MessageRecipient) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterBoolean.allocationSize(value.`isProton`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`group`)
    )

    override fun write(value: MessageRecipient, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterBoolean.write(value.`isProton`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`group`, buf)
    }
}



data class MessageReplyTo (
    var `address`: kotlin.String, 
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageReplyTo: FfiConverterRustBuffer<MessageReplyTo> {
    override fun read(buf: ByteBuffer): MessageReplyTo {
        return MessageReplyTo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MessageReplyTo) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: MessageReplyTo, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



data class MessageSender (
    var `address`: kotlin.String, 
    var `bimiSelector`: kotlin.String?, 
    var `displaySenderImage`: kotlin.Boolean, 
    var `isProton`: kotlin.Boolean, 
    var `isSimpleLogin`: kotlin.Boolean, 
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageSender: FfiConverterRustBuffer<MessageSender> {
    override fun read(buf: ByteBuffer): MessageSender {
        return MessageSender(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MessageSender) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterOptionalString.allocationSize(value.`bimiSelector`) +
            FfiConverterBoolean.allocationSize(value.`displaySenderImage`) +
            FfiConverterBoolean.allocationSize(value.`isProton`) +
            FfiConverterBoolean.allocationSize(value.`isSimpleLogin`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: MessageSender, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterOptionalString.write(value.`bimiSelector`, buf)
            FfiConverterBoolean.write(value.`displaySenderImage`, buf)
            FfiConverterBoolean.write(value.`isProton`, buf)
            FfiConverterBoolean.write(value.`isSimpleLogin`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



data class MobileSetting (
    var `actions`: List<MobileAction>, 
    var `isCustom`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMobileSetting: FfiConverterRustBuffer<MobileSetting> {
    override fun read(buf: ByteBuffer): MobileSetting {
        return MobileSetting(
            FfiConverterSequenceTypeMobileAction.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: MobileSetting) = (
            FfiConverterSequenceTypeMobileAction.allocationSize(value.`actions`) +
            FfiConverterBoolean.allocationSize(value.`isCustom`)
    )

    override fun write(value: MobileSetting, buf: ByteBuffer) {
            FfiConverterSequenceTypeMobileAction.write(value.`actions`, buf)
            FfiConverterBoolean.write(value.`isCustom`, buf)
    }
}



data class MobileSettings (
    var `conversationToolbar`: MobileSetting, 
    var `listToolbar`: MobileSetting, 
    var `messageToolbar`: MobileSetting
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMobileSettings: FfiConverterRustBuffer<MobileSettings> {
    override fun read(buf: ByteBuffer): MobileSettings {
        return MobileSettings(
            FfiConverterTypeMobileSetting.read(buf),
            FfiConverterTypeMobileSetting.read(buf),
            FfiConverterTypeMobileSetting.read(buf),
        )
    }

    override fun allocationSize(value: MobileSettings) = (
            FfiConverterTypeMobileSetting.allocationSize(value.`conversationToolbar`) +
            FfiConverterTypeMobileSetting.allocationSize(value.`listToolbar`) +
            FfiConverterTypeMobileSetting.allocationSize(value.`messageToolbar`)
    )

    override fun write(value: MobileSettings, buf: ByteBuffer) {
            FfiConverterTypeMobileSetting.write(value.`conversationToolbar`, buf)
            FfiConverterTypeMobileSetting.write(value.`listToolbar`, buf)
            FfiConverterTypeMobileSetting.write(value.`messageToolbar`, buf)
    }
}



data class MobileSignature (
    var `body`: kotlin.String, 
    var `status`: MobileSignatureStatus
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMobileSignature: FfiConverterRustBuffer<MobileSignature> {
    override fun read(buf: ByteBuffer): MobileSignature {
        return MobileSignature(
            FfiConverterString.read(buf),
            FfiConverterTypeMobileSignatureStatus.read(buf),
        )
    }

    override fun allocationSize(value: MobileSignature) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterTypeMobileSignatureStatus.allocationSize(value.`status`)
    )

    override fun write(value: MobileSignature, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterTypeMobileSignatureStatus.write(value.`status`, buf)
    }
}



/**
 * This struct represents a system folder that can be used as an action.

 */
data class MovableSystemFolderAction (
    var `localId`: Id, 
    var `name`: MovableSystemFolder
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMovableSystemFolderAction: FfiConverterRustBuffer<MovableSystemFolderAction> {
    override fun read(buf: ByteBuffer): MovableSystemFolderAction {
        return MovableSystemFolderAction(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeMovableSystemFolder.read(buf),
        )
    }

    override fun allocationSize(value: MovableSystemFolderAction) = (
            FfiConverterTypeId.allocationSize(value.`localId`) +
            FfiConverterTypeMovableSystemFolder.allocationSize(value.`name`)
    )

    override fun write(value: MovableSystemFolderAction, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`localId`, buf)
            FfiConverterTypeMovableSystemFolder.write(value.`name`, buf)
    }
}



/**
 * Subscription details
 */
data class NewSubscription (
    var `cycle`: kotlin.UByte, 
    var `currency`: kotlin.String?, 
    var `currencyId`: kotlin.Int?, 
    var `plans`: Map<kotlin.String, kotlin.Int>?, 
    var `planIds`: List<kotlin.Int>?, 
    var `codes`: List<kotlin.String>?, 
    var `couponCode`: kotlin.String?, 
    var `giftCode`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewSubscription: FfiConverterRustBuffer<NewSubscription> {
    override fun read(buf: ByteBuffer): NewSubscription {
        return NewSubscription(
            FfiConverterUByte.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalMapStringInt.read(buf),
            FfiConverterOptionalSequenceInt.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NewSubscription) = (
            FfiConverterUByte.allocationSize(value.`cycle`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterOptionalInt.allocationSize(value.`currencyId`) +
            FfiConverterOptionalMapStringInt.allocationSize(value.`plans`) +
            FfiConverterOptionalSequenceInt.allocationSize(value.`planIds`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`codes`) +
            FfiConverterOptionalString.allocationSize(value.`couponCode`) +
            FfiConverterOptionalString.allocationSize(value.`giftCode`)
    )

    override fun write(value: NewSubscription, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`cycle`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterOptionalInt.write(value.`currencyId`, buf)
            FfiConverterOptionalMapStringInt.write(value.`plans`, buf)
            FfiConverterOptionalSequenceInt.write(value.`planIds`, buf)
            FfiConverterOptionalSequenceString.write(value.`codes`, buf)
            FfiConverterOptionalString.write(value.`couponCode`, buf)
            FfiConverterOptionalString.write(value.`giftCode`, buf)
    }
}



/**
 * New subscription values
 */
data class NewSubscriptionValues (
    var `amount`: kotlin.ULong?, 
    var `payments`: List<kotlin.String>?, 
    var `paymentToken`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewSubscriptionValues: FfiConverterRustBuffer<NewSubscriptionValues> {
    override fun read(buf: ByteBuffer): NewSubscriptionValues {
        return NewSubscriptionValues(
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NewSubscriptionValues) = (
            FfiConverterOptionalULong.allocationSize(value.`amount`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`payments`) +
            FfiConverterOptionalString.allocationSize(value.`paymentToken`)
    )

    override fun write(value: NewSubscriptionValues, buf: ByteBuffer) {
            FfiConverterOptionalULong.write(value.`amount`, buf)
            FfiConverterOptionalSequenceString.write(value.`payments`, buf)
            FfiConverterOptionalString.write(value.`paymentToken`, buf)
    }
}



data class NotificationSender (
    var `name`: kotlin.String, 
    var `address`: kotlin.String, 
    var `group`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNotificationSender: FfiConverterRustBuffer<NotificationSender> {
    override fun read(buf: ByteBuffer): NotificationSender {
        return NotificationSender(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: NotificationSender) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterString.allocationSize(value.`group`)
    )

    override fun write(value: NotificationSender, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`address`, buf)
            FfiConverterString.write(value.`group`, buf)
    }
}



data class OpenDraft (
    var `draft`: Draft, 
    var `syncStatus`: DraftSyncStatus
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`draft`,
        this.`syncStatus`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOpenDraft: FfiConverterRustBuffer<OpenDraft> {
    override fun read(buf: ByteBuffer): OpenDraft {
        return OpenDraft(
            FfiConverterTypeDraft.read(buf),
            FfiConverterTypeDraftSyncStatus.read(buf),
        )
    }

    override fun allocationSize(value: OpenDraft) = (
            FfiConverterTypeDraft.allocationSize(value.`draft`) +
            FfiConverterTypeDraftSyncStatus.allocationSize(value.`syncStatus`)
    )

    override fun write(value: OpenDraft, buf: ByteBuffer) {
            FfiConverterTypeDraft.write(value.`draft`, buf)
            FfiConverterTypeDraftSyncStatus.write(value.`syncStatus`, buf)
    }
}



/**
 * Search options for pagination
 */
data class PaginatorSearchOptions (
    /**
     * Keywords to use in search.
     */
    var `keywords`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaginatorSearchOptions: FfiConverterRustBuffer<PaginatorSearchOptions> {
    override fun read(buf: ByteBuffer): PaginatorSearchOptions {
        return PaginatorSearchOptions(
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PaginatorSearchOptions) = (
            FfiConverterOptionalString.allocationSize(value.`keywords`)
    )

    override fun write(value: PaginatorSearchOptions, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`keywords`, buf)
    }
}



/**
 * It's possible to have a birthday without a year, month or day.
 */
data class PartialDate (
    var `year`: kotlin.UShort?, 
    var `month`: kotlin.UByte?, 
    var `day`: kotlin.UByte?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePartialDate: FfiConverterRustBuffer<PartialDate> {
    override fun read(buf: ByteBuffer): PartialDate {
        return PartialDate(
            FfiConverterOptionalUShort.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterOptionalUByte.read(buf),
        )
    }

    override fun allocationSize(value: PartialDate) = (
            FfiConverterOptionalUShort.allocationSize(value.`year`) +
            FfiConverterOptionalUByte.allocationSize(value.`month`) +
            FfiConverterOptionalUByte.allocationSize(value.`day`)
    )

    override fun write(value: PartialDate, buf: ByteBuffer) {
            FfiConverterOptionalUShort.write(value.`year`, buf)
            FfiConverterOptionalUByte.write(value.`month`, buf)
            FfiConverterOptionalUByte.write(value.`day`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Password (
    /**
     * TODO: Document this field.
     */
    var `mode`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `expirationTime`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePassword: FfiConverterRustBuffer<Password> {
    override fun read(buf: ByteBuffer): Password {
        return Password(
            FfiConverterUInt.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: Password) = (
            FfiConverterUInt.allocationSize(value.`mode`) +
            FfiConverterOptionalULong.allocationSize(value.`expirationTime`)
    )

    override fun write(value: Password, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`mode`, buf)
            FfiConverterOptionalULong.write(value.`expirationTime`, buf)
    }
}



data class PaymentMethod (
    var `id`: kotlin.String, 
    var `paymentType`: kotlin.String, 
    var `autopay`: kotlin.Boolean, 
    var `external`: kotlin.Boolean, 
    var `order`: kotlin.Int, 
    var `details`: PaymentMethodDetails
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethod: FfiConverterRustBuffer<PaymentMethod> {
    override fun read(buf: ByteBuffer): PaymentMethod {
        return PaymentMethod(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterInt.read(buf),
            FfiConverterTypePaymentMethodDetails.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethod) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`paymentType`) +
            FfiConverterBoolean.allocationSize(value.`autopay`) +
            FfiConverterBoolean.allocationSize(value.`external`) +
            FfiConverterInt.allocationSize(value.`order`) +
            FfiConverterTypePaymentMethodDetails.allocationSize(value.`details`)
    )

    override fun write(value: PaymentMethod, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`paymentType`, buf)
            FfiConverterBoolean.write(value.`autopay`, buf)
            FfiConverterBoolean.write(value.`external`, buf)
            FfiConverterInt.write(value.`order`, buf)
            FfiConverterTypePaymentMethodDetails.write(value.`details`, buf)
    }
}



data class PaymentMethodCardDetails (
    var `last4`: kotlin.String, 
    var `brand`: kotlin.String, 
    var `expMonth`: kotlin.String, 
    var `expYear`: kotlin.String, 
    var `name`: kotlin.String?, 
    var `country`: kotlin.String?, 
    var `zip`: kotlin.String?, 
    var `threeDsSupport`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethodCardDetails: FfiConverterRustBuffer<PaymentMethodCardDetails> {
    override fun read(buf: ByteBuffer): PaymentMethodCardDetails {
        return PaymentMethodCardDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethodCardDetails) = (
            FfiConverterString.allocationSize(value.`last4`) +
            FfiConverterString.allocationSize(value.`brand`) +
            FfiConverterString.allocationSize(value.`expMonth`) +
            FfiConverterString.allocationSize(value.`expYear`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`country`) +
            FfiConverterOptionalString.allocationSize(value.`zip`) +
            FfiConverterBoolean.allocationSize(value.`threeDsSupport`)
    )

    override fun write(value: PaymentMethodCardDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`last4`, buf)
            FfiConverterString.write(value.`brand`, buf)
            FfiConverterString.write(value.`expMonth`, buf)
            FfiConverterString.write(value.`expYear`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`country`, buf)
            FfiConverterOptionalString.write(value.`zip`, buf)
            FfiConverterBoolean.write(value.`threeDsSupport`, buf)
    }
}



data class PaymentMethodDirectDebitDetails (
    var `accountName`: kotlin.String, 
    var `country`: kotlin.String, 
    var `last4`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethodDirectDebitDetails: FfiConverterRustBuffer<PaymentMethodDirectDebitDetails> {
    override fun read(buf: ByteBuffer): PaymentMethodDirectDebitDetails {
        return PaymentMethodDirectDebitDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethodDirectDebitDetails) = (
            FfiConverterString.allocationSize(value.`accountName`) +
            FfiConverterString.allocationSize(value.`country`) +
            FfiConverterString.allocationSize(value.`last4`)
    )

    override fun write(value: PaymentMethodDirectDebitDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`accountName`, buf)
            FfiConverterString.write(value.`country`, buf)
            FfiConverterString.write(value.`last4`, buf)
    }
}



data class PaymentMethodPaypalDetails (
    var `billingAgreementId`: kotlin.String, 
    var `payerId`: kotlin.String?, 
    var `payer`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethodPaypalDetails: FfiConverterRustBuffer<PaymentMethodPaypalDetails> {
    override fun read(buf: ByteBuffer): PaymentMethodPaypalDetails {
        return PaymentMethodPaypalDetails(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethodPaypalDetails) = (
            FfiConverterString.allocationSize(value.`billingAgreementId`) +
            FfiConverterOptionalString.allocationSize(value.`payerId`) +
            FfiConverterString.allocationSize(value.`payer`)
    )

    override fun write(value: PaymentMethodPaypalDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`billingAgreementId`, buf)
            FfiConverterOptionalString.write(value.`payerId`, buf)
            FfiConverterString.write(value.`payer`, buf)
    }
}



data class PaymentMethods (
    var `bitcoin`: PaymentVendor, 
    var `card`: PaymentVendor, 
    var `inApp`: PaymentVendor, 
    var `paypal`: PaymentVendor
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethods: FfiConverterRustBuffer<PaymentMethods> {
    override fun read(buf: ByteBuffer): PaymentMethods {
        return PaymentMethods(
            FfiConverterTypePaymentVendor.read(buf),
            FfiConverterTypePaymentVendor.read(buf),
            FfiConverterTypePaymentVendor.read(buf),
            FfiConverterTypePaymentVendor.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethods) = (
            FfiConverterTypePaymentVendor.allocationSize(value.`bitcoin`) +
            FfiConverterTypePaymentVendor.allocationSize(value.`card`) +
            FfiConverterTypePaymentVendor.allocationSize(value.`inApp`) +
            FfiConverterTypePaymentVendor.allocationSize(value.`paypal`)
    )

    override fun write(value: PaymentMethods, buf: ByteBuffer) {
            FfiConverterTypePaymentVendor.write(value.`bitcoin`, buf)
            FfiConverterTypePaymentVendor.write(value.`card`, buf)
            FfiConverterTypePaymentVendor.write(value.`inApp`, buf)
            FfiConverterTypePaymentVendor.write(value.`paypal`, buf)
    }
}



/**
 * A payment token.
 */
data class PaymentToken (
    var `token`: kotlin.String, 
    var `status`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentToken: FfiConverterRustBuffer<PaymentToken> {
    override fun read(buf: ByteBuffer): PaymentToken {
        return PaymentToken(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PaymentToken) = (
            FfiConverterString.allocationSize(value.`token`) +
            FfiConverterULong.allocationSize(value.`status`)
    )

    override fun write(value: PaymentToken, buf: ByteBuffer) {
            FfiConverterString.write(value.`token`, buf)
            FfiConverterULong.write(value.`status`, buf)
    }
}



data class PaymentVendor (
    /**
     * Whether the vendor is enabled/disabled for this user & location.
     */
    var `state`: PaymentVendorState, 
    /**
     * Reason when a vendor is disabled.
     */
    var `reason`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentVendor: FfiConverterRustBuffer<PaymentVendor> {
    override fun read(buf: ByteBuffer): PaymentVendor {
        return PaymentVendor(
            FfiConverterTypePaymentVendorState.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentVendor) = (
            FfiConverterTypePaymentVendorState.allocationSize(value.`state`) +
            FfiConverterOptionalString.allocationSize(value.`reason`)
    )

    override fun write(value: PaymentVendor, buf: ByteBuffer) {
            FfiConverterTypePaymentVendorState.write(value.`state`, buf)
            FfiConverterOptionalString.write(value.`reason`, buf)
    }
}



/**
 * Payment plans available to the user.
 */
data class PaymentsPlans (
    /**
     * The list of plans available to the user.
     */
    var `plans`: List<Plan>, 
    /**
     * What cycle to display by default
     */
    var `defaultCycle`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentsPlans: FfiConverterRustBuffer<PaymentsPlans> {
    override fun read(buf: ByteBuffer): PaymentsPlans {
        return PaymentsPlans(
            FfiConverterSequenceTypePlan.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: PaymentsPlans) = (
            FfiConverterSequenceTypePlan.allocationSize(value.`plans`) +
            FfiConverterUByte.allocationSize(value.`defaultCycle`)
    )

    override fun write(value: PaymentsPlans, buf: ByteBuffer) {
            FfiConverterSequenceTypePlan.write(value.`plans`, buf)
            FfiConverterUByte.write(value.`defaultCycle`, buf)
    }
}



data class PaymentsStatus (
    /**
     * Geolocation for this request.
     */
    var `location`: Location, 
    /**
     * Status of supported vendors.
     */
    var `paymentMethods`: PaymentMethods
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentsStatus: FfiConverterRustBuffer<PaymentsStatus> {
    override fun read(buf: ByteBuffer): PaymentsStatus {
        return PaymentsStatus(
            FfiConverterTypeLocation.read(buf),
            FfiConverterTypePaymentMethods.read(buf),
        )
    }

    override fun allocationSize(value: PaymentsStatus) = (
            FfiConverterTypeLocation.allocationSize(value.`location`) +
            FfiConverterTypePaymentMethods.allocationSize(value.`paymentMethods`)
    )

    override fun write(value: PaymentsStatus, buf: ByteBuffer) {
            FfiConverterTypeLocation.write(value.`location`, buf)
            FfiConverterTypePaymentMethods.write(value.`paymentMethods`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Phone (
    /**
     * TODO: Document this field.
     */
    var `notify`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `reset`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `status`: kotlin.UByte, 
    /**
     * TODO: Document this field.
     */
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePhone: FfiConverterRustBuffer<Phone> {
    override fun read(buf: ByteBuffer): Phone {
        return Phone(
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Phone) = (
            FfiConverterUByte.allocationSize(value.`notify`) +
            FfiConverterUByte.allocationSize(value.`reset`) +
            FfiConverterUByte.allocationSize(value.`status`) +
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: Phone, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`notify`, buf)
            FfiConverterUByte.write(value.`reset`, buf)
            FfiConverterUByte.write(value.`status`, buf)
            FfiConverterString.write(value.`value`, buf)
    }
}



/**
 * Represents a single payment plan from the Proton API.
 */
data class Plan (
    var `id`: kotlin.String, 
    var `description`: kotlin.String, 
    var `name`: kotlin.String?, 
    var `title`: kotlin.String, 
    var `state`: kotlin.UByte, 
    var `type`: PlanType, 
    var `features`: kotlin.UByte, 
    var `services`: kotlin.UByte, 
    var `offers`: List<kotlin.String>, 
    var `layout`: kotlin.String, 
    var `instances`: List<PlanInstance>, 
    var `entitlements`: List<PlanEntitlement>, 
    var `decorations`: List<PlanDecoration>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlan: FfiConverterRustBuffer<Plan> {
    override fun read(buf: ByteBuffer): Plan {
        return Plan(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterTypePlanType.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceTypePlanInstance.read(buf),
            FfiConverterSequenceTypePlanEntitlement.read(buf),
            FfiConverterSequenceTypePlanDecoration.read(buf),
        )
    }

    override fun allocationSize(value: Plan) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`title`) +
            FfiConverterUByte.allocationSize(value.`state`) +
            FfiConverterTypePlanType.allocationSize(value.`type`) +
            FfiConverterUByte.allocationSize(value.`features`) +
            FfiConverterUByte.allocationSize(value.`services`) +
            FfiConverterSequenceString.allocationSize(value.`offers`) +
            FfiConverterString.allocationSize(value.`layout`) +
            FfiConverterSequenceTypePlanInstance.allocationSize(value.`instances`) +
            FfiConverterSequenceTypePlanEntitlement.allocationSize(value.`entitlements`) +
            FfiConverterSequenceTypePlanDecoration.allocationSize(value.`decorations`)
    )

    override fun write(value: Plan, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterString.write(value.`title`, buf)
            FfiConverterUByte.write(value.`state`, buf)
            FfiConverterTypePlanType.write(value.`type`, buf)
            FfiConverterUByte.write(value.`features`, buf)
            FfiConverterUByte.write(value.`services`, buf)
            FfiConverterSequenceString.write(value.`offers`, buf)
            FfiConverterString.write(value.`layout`, buf)
            FfiConverterSequenceTypePlanInstance.write(value.`instances`, buf)
            FfiConverterSequenceTypePlanEntitlement.write(value.`entitlements`, buf)
            FfiConverterSequenceTypePlanDecoration.write(value.`decorations`, buf)
    }
}



/**
 * Represents a plan instance.
 */
data class PlanInstance (
    var `cycle`: kotlin.UByte, 
    var `description`: kotlin.String, 
    var `periodEnd`: kotlin.ULong, 
    var `price`: List<PlanPrice>, 
    var `vendors`: Map<PlanVendorName, PlanVendor>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanInstance: FfiConverterRustBuffer<PlanInstance> {
    override fun read(buf: ByteBuffer): PlanInstance {
        return PlanInstance(
            FfiConverterUByte.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceTypePlanPrice.read(buf),
            FfiConverterMapTypePlanVendorNameTypePlanVendor.read(buf),
        )
    }

    override fun allocationSize(value: PlanInstance) = (
            FfiConverterUByte.allocationSize(value.`cycle`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterULong.allocationSize(value.`periodEnd`) +
            FfiConverterSequenceTypePlanPrice.allocationSize(value.`price`) +
            FfiConverterMapTypePlanVendorNameTypePlanVendor.allocationSize(value.`vendors`)
    )

    override fun write(value: PlanInstance, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`cycle`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterULong.write(value.`periodEnd`, buf)
            FfiConverterSequenceTypePlanPrice.write(value.`price`, buf)
            FfiConverterMapTypePlanVendorNameTypePlanVendor.write(value.`vendors`, buf)
    }
}



/**
 * Represents a plan price.
 */
data class PlanPrice (
    var `id`: kotlin.String, 
    var `currency`: kotlin.String, 
    var `current`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanPrice: FfiConverterRustBuffer<PlanPrice> {
    override fun read(buf: ByteBuffer): PlanPrice {
        return PlanPrice(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PlanPrice) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterULong.allocationSize(value.`current`)
    )

    override fun write(value: PlanPrice, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterULong.write(value.`current`, buf)
    }
}



data class PlanSpecificDimensions (
    var `selectedPlan`: kotlin.String, 
    var `selectedCycle`: kotlin.String, 
    var `upsellIsPromotional`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanSpecificDimensions: FfiConverterRustBuffer<PlanSpecificDimensions> {
    override fun read(buf: ByteBuffer): PlanSpecificDimensions {
        return PlanSpecificDimensions(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: PlanSpecificDimensions) = (
            FfiConverterString.allocationSize(value.`selectedPlan`) +
            FfiConverterString.allocationSize(value.`selectedCycle`) +
            FfiConverterBoolean.allocationSize(value.`upsellIsPromotional`)
    )

    override fun write(value: PlanSpecificDimensions, buf: ByteBuffer) {
            FfiConverterString.write(value.`selectedPlan`, buf)
            FfiConverterString.write(value.`selectedCycle`, buf)
            FfiConverterBoolean.write(value.`upsellIsPromotional`, buf)
    }
}



/**
 * Represents data for a plan vendor.
 */
data class PlanVendor (
    var `productId`: kotlin.String, 
    var `customerId`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanVendor: FfiConverterRustBuffer<PlanVendor> {
    override fun read(buf: ByteBuffer): PlanVendor {
        return PlanVendor(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PlanVendor) = (
            FfiConverterString.allocationSize(value.`productId`) +
            FfiConverterOptionalString.allocationSize(value.`customerId`)
    )

    override fun write(value: PlanVendor, buf: ByteBuffer) {
            FfiConverterString.write(value.`productId`, buf)
            FfiConverterOptionalString.write(value.`customerId`, buf)
    }
}



data class PmSignature (
    var `value`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePmSignature: FfiConverterRustBuffer<PmSignature> {
    override fun read(buf: ByteBuffer): PmSignature {
        return PmSignature(
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: PmSignature) = (
            FfiConverterUByte.allocationSize(value.`value`)
    )

    override fun write(value: PmSignature, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`value`, buf)
    }
}



data class PrivacyInfo (
    var `trackers`: TrackerInfoWithStatus, 
    var `utmLinks`: StrippedUtmInfo?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrivacyInfo: FfiConverterRustBuffer<PrivacyInfo> {
    override fun read(buf: ByteBuffer): PrivacyInfo {
        return PrivacyInfo(
            FfiConverterTypeTrackerInfoWithStatus.read(buf),
            FfiConverterOptionalTypeStrippedUTMInfo.read(buf),
        )
    }

    override fun allocationSize(value: PrivacyInfo) = (
            FfiConverterTypeTrackerInfoWithStatus.allocationSize(value.`trackers`) +
            FfiConverterOptionalTypeStrippedUTMInfo.allocationSize(value.`utmLinks`)
    )

    override fun write(value: PrivacyInfo, buf: ByteBuffer) {
            FfiConverterTypeTrackerInfoWithStatus.write(value.`trackers`, buf)
            FfiConverterOptionalTypeStrippedUTMInfo.write(value.`utmLinks`, buf)
    }
}



data class PrivacyLock (
    var `icon`: PrivacyLockIcon, 
    var `color`: PrivacyLockColor, 
    var `tooltip`: PrivacyLockTooltip
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrivacyLock: FfiConverterRustBuffer<PrivacyLock> {
    override fun read(buf: ByteBuffer): PrivacyLock {
        return PrivacyLock(
            FfiConverterTypePrivacyLockIcon.read(buf),
            FfiConverterTypePrivacyLockColor.read(buf),
            FfiConverterTypePrivacyLockTooltip.read(buf),
        )
    }

    override fun allocationSize(value: PrivacyLock) = (
            FfiConverterTypePrivacyLockIcon.allocationSize(value.`icon`) +
            FfiConverterTypePrivacyLockColor.allocationSize(value.`color`) +
            FfiConverterTypePrivacyLockTooltip.allocationSize(value.`tooltip`)
    )

    override fun write(value: PrivacyLock, buf: ByteBuffer) {
            FfiConverterTypePrivacyLockIcon.write(value.`icon`, buf)
            FfiConverterTypePrivacyLockColor.write(value.`color`, buf)
            FfiConverterTypePrivacyLockTooltip.write(value.`tooltip`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class ProductUsedSpace (
    /**
     * TODO: Document this field.
     */
    var `calendar`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `contact`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `drive`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `mail`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `pass`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeProductUsedSpace: FfiConverterRustBuffer<ProductUsedSpace> {
    override fun read(buf: ByteBuffer): ProductUsedSpace {
        return ProductUsedSpace(
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: ProductUsedSpace) = (
            FfiConverterLong.allocationSize(value.`calendar`) +
            FfiConverterLong.allocationSize(value.`contact`) +
            FfiConverterLong.allocationSize(value.`drive`) +
            FfiConverterLong.allocationSize(value.`mail`) +
            FfiConverterLong.allocationSize(value.`pass`)
    )

    override fun write(value: ProductUsedSpace, buf: ByteBuffer) {
            FfiConverterLong.write(value.`calendar`, buf)
            FfiConverterLong.write(value.`contact`, buf)
            FfiConverterLong.write(value.`drive`, buf)
            FfiConverterLong.write(value.`mail`, buf)
            FfiConverterLong.write(value.`pass`, buf)
    }
}



data class Query (
    var `key`: kotlin.String, 
    var `val`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeQuery: FfiConverterRustBuffer<Query> {
    override fun read(buf: ByteBuffer): Query {
        return Query(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: Query) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterOptionalString.allocationSize(value.`val`)
    )

    override fun write(value: Query, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterOptionalString.write(value.`val`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class Referral (
    /**
     * TODO: Document this field.
     */
    var `eligible`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `link`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReferral: FfiConverterRustBuffer<Referral> {
    override fun read(buf: ByteBuffer): Referral {
        return Referral(
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Referral) = (
            FfiConverterBoolean.allocationSize(value.`eligible`) +
            FfiConverterString.allocationSize(value.`link`)
    )

    override fun write(value: Referral, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`eligible`, buf)
            FfiConverterString.write(value.`link`, buf)
    }
}



data class RegisteredDevice (
    var `deviceToken`: kotlin.String, 
    var `environment`: DeviceEnvironment, 
    var `pingNotificationStatus`: kotlin.Int?, 
    var `pushNotificationStatus`: kotlin.Int?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRegisteredDevice: FfiConverterRustBuffer<RegisteredDevice> {
    override fun read(buf: ByteBuffer): RegisteredDevice {
        return RegisteredDevice(
            FfiConverterString.read(buf),
            FfiConverterTypeDeviceEnvironment.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
        )
    }

    override fun allocationSize(value: RegisteredDevice) = (
            FfiConverterString.allocationSize(value.`deviceToken`) +
            FfiConverterTypeDeviceEnvironment.allocationSize(value.`environment`) +
            FfiConverterOptionalInt.allocationSize(value.`pingNotificationStatus`) +
            FfiConverterOptionalInt.allocationSize(value.`pushNotificationStatus`)
    )

    override fun write(value: RegisteredDevice, buf: ByteBuffer) {
            FfiConverterString.write(value.`deviceToken`, buf)
            FfiConverterTypeDeviceEnvironment.write(value.`environment`, buf)
            FfiConverterOptionalInt.write(value.`pingNotificationStatus`, buf)
            FfiConverterOptionalInt.write(value.`pushNotificationStatus`, buf)
    }
}



/**
 * Remote ID
 *
 * This data type should be used as a last resort.
 * If possible, use [`Id`] instead.
 *
 * This struct is a simple wrapper around [`String`] and
 * is used to formalise all IDs used by our API.

 */
data class RemoteId (
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRemoteId: FfiConverterRustBuffer<RemoteId> {
    override fun read(buf: ByteBuffer): RemoteId {
        return RemoteId(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RemoteId) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: RemoteId, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



data class RsvpAttendee (
    var `name`: kotlin.String?, 
    var `email`: kotlin.String, 
    var `status`: RsvpAttendeeStatus
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpAttendee: FfiConverterRustBuffer<RsvpAttendee> {
    override fun read(buf: ByteBuffer): RsvpAttendee {
        return RsvpAttendee(
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeRsvpAttendeeStatus.read(buf),
        )
    }

    override fun allocationSize(value: RsvpAttendee) = (
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterTypeRsvpAttendeeStatus.allocationSize(value.`status`)
    )

    override fun write(value: RsvpAttendee, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterTypeRsvpAttendeeStatus.write(value.`status`, buf)
    }
}



data class RsvpCalendar (
    var `id`: kotlin.String, 
    var `name`: kotlin.String, 
    /**
     * Calendar's color, as a CSS hex-string (e.g. `#aabbcc`)
     */
    var `color`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpCalendar: FfiConverterRustBuffer<RsvpCalendar> {
    override fun read(buf: ByteBuffer): RsvpCalendar {
        return RsvpCalendar(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RsvpCalendar) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`color`)
    )

    override fun write(value: RsvpCalendar, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`color`, buf)
    }
}



data class RsvpEvent (
    var `id`: kotlin.String?, 
    var `summary`: kotlin.String?, 
    var `location`: kotlin.String?, 
    var `description`: kotlin.String?, 
    var `recurrence`: kotlin.String?, 
    var `startsAt`: UnixTimestamp, 
    var `endsAt`: UnixTimestamp, 
    var `occurrence`: RsvpOccurrence, 
    var `organizer`: RsvpOrganizer, 
    var `attendees`: List<RsvpAttendee>, 
    var `userAttendeeIdx`: kotlin.UInt?, 
    var `calendar`: RsvpCalendar?, 
    var `state`: RsvpState
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpEvent: FfiConverterRustBuffer<RsvpEvent> {
    override fun read(buf: ByteBuffer): RsvpEvent {
        return RsvpEvent(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterTypeRsvpOccurrence.read(buf),
            FfiConverterTypeRsvpOrganizer.read(buf),
            FfiConverterSequenceTypeRsvpAttendee.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterOptionalTypeRsvpCalendar.read(buf),
            FfiConverterTypeRsvpState.read(buf),
        )
    }

    override fun allocationSize(value: RsvpEvent) = (
            FfiConverterOptionalString.allocationSize(value.`id`) +
            FfiConverterOptionalString.allocationSize(value.`summary`) +
            FfiConverterOptionalString.allocationSize(value.`location`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalString.allocationSize(value.`recurrence`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`startsAt`) +
            FfiConverterTypeUnixTimestamp.allocationSize(value.`endsAt`) +
            FfiConverterTypeRsvpOccurrence.allocationSize(value.`occurrence`) +
            FfiConverterTypeRsvpOrganizer.allocationSize(value.`organizer`) +
            FfiConverterSequenceTypeRsvpAttendee.allocationSize(value.`attendees`) +
            FfiConverterOptionalUInt.allocationSize(value.`userAttendeeIdx`) +
            FfiConverterOptionalTypeRsvpCalendar.allocationSize(value.`calendar`) +
            FfiConverterTypeRsvpState.allocationSize(value.`state`)
    )

    override fun write(value: RsvpEvent, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`id`, buf)
            FfiConverterOptionalString.write(value.`summary`, buf)
            FfiConverterOptionalString.write(value.`location`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalString.write(value.`recurrence`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`startsAt`, buf)
            FfiConverterTypeUnixTimestamp.write(value.`endsAt`, buf)
            FfiConverterTypeRsvpOccurrence.write(value.`occurrence`, buf)
            FfiConverterTypeRsvpOrganizer.write(value.`organizer`, buf)
            FfiConverterSequenceTypeRsvpAttendee.write(value.`attendees`, buf)
            FfiConverterOptionalUInt.write(value.`userAttendeeIdx`, buf)
            FfiConverterOptionalTypeRsvpCalendar.write(value.`calendar`, buf)
            FfiConverterTypeRsvpState.write(value.`state`, buf)
    }
}



data class RsvpOrganizer (
    var `name`: kotlin.String?, 
    var `email`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpOrganizer: FfiConverterRustBuffer<RsvpOrganizer> {
    override fun read(buf: ByteBuffer): RsvpOrganizer {
        return RsvpOrganizer(
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RsvpOrganizer) = (
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`email`)
    )

    override fun write(value: RsvpOrganizer, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterString.write(value.`email`, buf)
    }
}



/**
 * Represents the second factor status of an account.
 */
data class SecondFactorStatus (
    /**
     * Whether a TOTP second factor can be used.
     */
    var `totp`: kotlin.Boolean, 
    /**
     * Whether a FIDO2 second factor can be used.
     */
    var `fido`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSecondFactorStatus: FfiConverterRustBuffer<SecondFactorStatus> {
    override fun read(buf: ByteBuffer): SecondFactorStatus {
        return SecondFactorStatus(
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SecondFactorStatus) = (
            FfiConverterBoolean.allocationSize(value.`totp`) +
            FfiConverterBoolean.allocationSize(value.`fido`)
    )

    override fun write(value: SecondFactorStatus, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`totp`, buf)
            FfiConverterBoolean.write(value.`fido`, buf)
    }
}



/**
 * Represents the second password status of an account.
 *
 * TODO: Add other additional password types,
 * e.g.  the password that proton pass allows users to set.
 */
data class SecondPasswordStatus (
    /**
     * Whether a mailbox password has been set.
     */
    var `mailboxPassword`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSecondPasswordStatus: FfiConverterRustBuffer<SecondPasswordStatus> {
    override fun read(buf: ByteBuffer): SecondPasswordStatus {
        return SecondPasswordStatus(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SecondPasswordStatus) = (
            FfiConverterBoolean.allocationSize(value.`mailboxPassword`)
    )

    override fun write(value: SecondPasswordStatus, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`mailboxPassword`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class SettingsFlags (
    /**
     * TODO: Document this field.
     */
    var `welcomed`: kotlin.Boolean, 
    /**
     * `EasyDeviceMigration` (QR Login) opt out. The user can choose to disable the feature.
     */
    var `edmOptOut`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSettingsFlags: FfiConverterRustBuffer<SettingsFlags> {
    override fun read(buf: ByteBuffer): SettingsFlags {
        return SettingsFlags(
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SettingsFlags) = (
            FfiConverterBoolean.allocationSize(value.`welcomed`) +
            FfiConverterBoolean.allocationSize(value.`edmOptOut`)
    )

    override fun write(value: SettingsFlags, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`welcomed`, buf)
            FfiConverterBoolean.write(value.`edmOptOut`, buf)
    }
}



data class SettingsWatcher (
    var `settings`: MailSettings, 
    var `watchHandle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`settings`,
        this.`watchHandle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSettingsWatcher: FfiConverterRustBuffer<SettingsWatcher> {
    override fun read(buf: ByteBuffer): SettingsWatcher {
        return SettingsWatcher(
            FfiConverterTypeMailSettings.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: SettingsWatcher) = (
            FfiConverterTypeMailSettings.allocationSize(value.`settings`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`watchHandle`)
    )

    override fun write(value: SettingsWatcher, buf: ByteBuffer) {
            FfiConverterTypeMailSettings.write(value.`settings`, buf)
            FfiConverterTypeWatchHandle.write(value.`watchHandle`, buf)
    }
}



/**
 * Contextual representation of a `Label` when it is opened for display.
 */
data class SidebarCustomFolder (
    /**
     * The local ID of the record, i.e. the ID assigned by the client
     * application. This is a restricted-scope unique identifier for the record
     * within the set of all records of this type, and is important for
     * relating local records. It has no relationship to the centrally-stored
     * API ID, and never leaves the local system.
     */
    var `id`: Id, 
    /**
     * Id of the parent `Folder` of this `Folder` if any.
     */
    var `parentId`: Id?, 
    /**
     * List of the Labels contained in this Folder
     */
    var `children`: List<SidebarCustomFolder>, 
    /**
     * Color to display this `Folder` with.
     */
    var `color`: LabelColor?, 
    /**
     * Description of this `Folder`.
     */
    var `description`: LabelDescription, 
    /**
     * TODO: Document this field.
     */
    var `display`: kotlin.Boolean, 
    /**
     * Is this `Folder` expanded?
     */
    var `expanded`: kotlin.Boolean, 
    /**
     * Name of this `Folder`.
     */
    var `name`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `notify`: kotlin.Boolean, 
    /**
     * Order to display all the `Folders`.
     */
    var `displayOrder`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `path`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `sticky`: kotlin.Boolean, 
    /**
     * Total number of `Messages` in this `Folder`.
     */
    var `total`: kotlin.ULong, 
    /**
     * Numer of unread `Messages` in this `FOlder`.
     */
    var `unread`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarCustomFolder: FfiConverterRustBuffer<SidebarCustomFolder> {
    override fun read(buf: ByteBuffer): SidebarCustomFolder {
        return SidebarCustomFolder(
            FfiConverterTypeId.read(buf),
            FfiConverterOptionalTypeId.read(buf),
            FfiConverterSequenceTypeSidebarCustomFolder.read(buf),
            FfiConverterOptionalTypeLabelColor.read(buf),
            FfiConverterTypeLabelDescription.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: SidebarCustomFolder) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterOptionalTypeId.allocationSize(value.`parentId`) +
            FfiConverterSequenceTypeSidebarCustomFolder.allocationSize(value.`children`) +
            FfiConverterOptionalTypeLabelColor.allocationSize(value.`color`) +
            FfiConverterTypeLabelDescription.allocationSize(value.`description`) +
            FfiConverterBoolean.allocationSize(value.`display`) +
            FfiConverterBoolean.allocationSize(value.`expanded`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterBoolean.allocationSize(value.`notify`) +
            FfiConverterUInt.allocationSize(value.`displayOrder`) +
            FfiConverterOptionalString.allocationSize(value.`path`) +
            FfiConverterBoolean.allocationSize(value.`sticky`) +
            FfiConverterULong.allocationSize(value.`total`) +
            FfiConverterULong.allocationSize(value.`unread`)
    )

    override fun write(value: SidebarCustomFolder, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterOptionalTypeId.write(value.`parentId`, buf)
            FfiConverterSequenceTypeSidebarCustomFolder.write(value.`children`, buf)
            FfiConverterOptionalTypeLabelColor.write(value.`color`, buf)
            FfiConverterTypeLabelDescription.write(value.`description`, buf)
            FfiConverterBoolean.write(value.`display`, buf)
            FfiConverterBoolean.write(value.`expanded`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterBoolean.write(value.`notify`, buf)
            FfiConverterUInt.write(value.`displayOrder`, buf)
            FfiConverterOptionalString.write(value.`path`, buf)
            FfiConverterBoolean.write(value.`sticky`, buf)
            FfiConverterULong.write(value.`total`, buf)
            FfiConverterULong.write(value.`unread`, buf)
    }
}



/**
 * Represent a `Label` defined by End User
 */
data class SidebarCustomLabel (
    /**
     * Local id of the Label.
     */
    var `id`: Id, 
    /**
     * The color of the Label.
     */
    var `color`: LabelColor, 
    /**
     * Description of this Label.
     */
    var `description`: LabelDescription, 
    /**
     * TODO: Document this field.
     */
    var `display`: kotlin.Boolean, 
    /**
     * The name of this Label.
     */
    var `name`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `notify`: kotlin.Boolean, 
    /**
     * Order to display relative to other `CustomLabel`.
     */
    var `displayOrder`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `sticky`: kotlin.Boolean, 
    /**
     * Total count of the message in this Label.
     */
    var `total`: kotlin.ULong, 
    /**
     * Count of unread message in this Label.
     */
    var `unread`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarCustomLabel: FfiConverterRustBuffer<SidebarCustomLabel> {
    override fun read(buf: ByteBuffer): SidebarCustomLabel {
        return SidebarCustomLabel(
            FfiConverterTypeId.read(buf),
            FfiConverterTypeLabelColor.read(buf),
            FfiConverterTypeLabelDescription.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: SidebarCustomLabel) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterTypeLabelColor.allocationSize(value.`color`) +
            FfiConverterTypeLabelDescription.allocationSize(value.`description`) +
            FfiConverterBoolean.allocationSize(value.`display`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterBoolean.allocationSize(value.`notify`) +
            FfiConverterUInt.allocationSize(value.`displayOrder`) +
            FfiConverterBoolean.allocationSize(value.`sticky`) +
            FfiConverterULong.allocationSize(value.`total`) +
            FfiConverterULong.allocationSize(value.`unread`)
    )

    override fun write(value: SidebarCustomLabel, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterTypeLabelColor.write(value.`color`, buf)
            FfiConverterTypeLabelDescription.write(value.`description`, buf)
            FfiConverterBoolean.write(value.`display`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterBoolean.write(value.`notify`, buf)
            FfiConverterUInt.write(value.`displayOrder`, buf)
            FfiConverterBoolean.write(value.`sticky`, buf)
            FfiConverterULong.write(value.`total`, buf)
            FfiConverterULong.write(value.`unread`, buf)
    }
}



/**
 * Representation of a `Label` defined by the system
 */
data class SidebarSystemLabel (
    /**
     * Local id of the Label.
     */
    var `id`: Id, 
    /**
     * TODO: Document this field.
     */
    var `display`: kotlin.Boolean, 
    /**
     * Description of this Label.
     */
    var `description`: LabelDescription, 
    /**
     * The name of this Label.
     */
    var `name`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `notify`: kotlin.Boolean, 
    /**
     * Order to display relative to other `CustomLabel`.
     */
    var `displayOrder`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `sticky`: kotlin.Boolean, 
    /**
     * Total count of the message in this Label.
     */
    var `total`: kotlin.ULong, 
    /**
     * Count of unread message in this Label.
     */
    var `unread`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarSystemLabel: FfiConverterRustBuffer<SidebarSystemLabel> {
    override fun read(buf: ByteBuffer): SidebarSystemLabel {
        return SidebarSystemLabel(
            FfiConverterTypeId.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeLabelDescription.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: SidebarSystemLabel) = (
            FfiConverterTypeId.allocationSize(value.`id`) +
            FfiConverterBoolean.allocationSize(value.`display`) +
            FfiConverterTypeLabelDescription.allocationSize(value.`description`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterBoolean.allocationSize(value.`notify`) +
            FfiConverterUInt.allocationSize(value.`displayOrder`) +
            FfiConverterBoolean.allocationSize(value.`sticky`) +
            FfiConverterULong.allocationSize(value.`total`) +
            FfiConverterULong.allocationSize(value.`unread`)
    )

    override fun write(value: SidebarSystemLabel, buf: ByteBuffer) {
            FfiConverterTypeId.write(value.`id`, buf)
            FfiConverterBoolean.write(value.`display`, buf)
            FfiConverterTypeLabelDescription.write(value.`description`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterBoolean.write(value.`notify`, buf)
            FfiConverterUInt.write(value.`displayOrder`, buf)
            FfiConverterBoolean.write(value.`sticky`, buf)
            FfiConverterULong.write(value.`total`, buf)
            FfiConverterULong.write(value.`unread`, buf)
    }
}



data class SingleRecipientEntry (
    var `name`: kotlin.String?, 
    var `email`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSingleRecipientEntry: FfiConverterRustBuffer<SingleRecipientEntry> {
    override fun read(buf: ByteBuffer): SingleRecipientEntry {
        return SingleRecipientEntry(
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SingleRecipientEntry) = (
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`email`)
    )

    override fun write(value: SingleRecipientEntry, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterString.write(value.`email`, buf)
    }
}



data class SnoozeActions (
    var `options`: List<SnoozeTime>, 
    var `showUnsnooze`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSnoozeActions: FfiConverterRustBuffer<SnoozeActions> {
    override fun read(buf: ByteBuffer): SnoozeActions {
        return SnoozeActions(
            FfiConverterSequenceTypeSnoozeTime.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SnoozeActions) = (
            FfiConverterSequenceTypeSnoozeTime.allocationSize(value.`options`) +
            FfiConverterBoolean.allocationSize(value.`showUnsnooze`)
    )

    override fun write(value: SnoozeActions, buf: ByteBuffer) {
            FfiConverterSequenceTypeSnoozeTime.write(value.`options`, buf)
            FfiConverterBoolean.write(value.`showUnsnooze`, buf)
    }
}



data class StrippedUtmInfo (
    var `links`: List<UtmLink>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStrippedUTMInfo: FfiConverterRustBuffer<StrippedUtmInfo> {
    override fun read(buf: ByteBuffer): StrippedUtmInfo {
        return StrippedUtmInfo(
            FfiConverterSequenceTypeUTMLink.read(buf),
        )
    }

    override fun allocationSize(value: StrippedUtmInfo) = (
            FfiConverterSequenceTypeUTMLink.allocationSize(value.`links`)
    )

    override fun write(value: StrippedUtmInfo, buf: ByteBuffer) {
            FfiConverterSequenceTypeUTMLink.write(value.`links`, buf)
    }
}



data class Subscription (
    var `id`: kotlin.String?, 
    var `name`: kotlin.String?, 
    var `title`: kotlin.String, 
    var `description`: kotlin.String, 
    var `cycle`: kotlin.UByte?, 
    var `cycleDescription`: kotlin.String?, 
    var `currency`: kotlin.String?, 
    var `offer`: kotlin.String?, 
    var `amount`: kotlin.ULong?, 
    var `renewAmount`: kotlin.ULong?, 
    var `discount`: kotlin.Long?, 
    var `renewDiscount`: kotlin.Long?, 
    var `periodStart`: kotlin.ULong?, 
    var `periodEnd`: kotlin.ULong?, 
    var `createTime`: kotlin.ULong?, 
    var `couponCode`: kotlin.String?, 
    var `renew`: kotlin.UByte?, 
    var `external`: kotlin.UByte?, 
    var `entitlements`: List<PlanEntitlement>, 
    var `decorations`: List<PlanDecoration>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSubscription: FfiConverterRustBuffer<Subscription> {
    override fun read(buf: ByteBuffer): Subscription {
        return Subscription(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterSequenceTypePlanEntitlement.read(buf),
            FfiConverterSequenceTypePlanDecoration.read(buf),
        )
    }

    override fun allocationSize(value: Subscription) = (
            FfiConverterOptionalString.allocationSize(value.`id`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`title`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterOptionalUByte.allocationSize(value.`cycle`) +
            FfiConverterOptionalString.allocationSize(value.`cycleDescription`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterOptionalString.allocationSize(value.`offer`) +
            FfiConverterOptionalULong.allocationSize(value.`amount`) +
            FfiConverterOptionalULong.allocationSize(value.`renewAmount`) +
            FfiConverterOptionalLong.allocationSize(value.`discount`) +
            FfiConverterOptionalLong.allocationSize(value.`renewDiscount`) +
            FfiConverterOptionalULong.allocationSize(value.`periodStart`) +
            FfiConverterOptionalULong.allocationSize(value.`periodEnd`) +
            FfiConverterOptionalULong.allocationSize(value.`createTime`) +
            FfiConverterOptionalString.allocationSize(value.`couponCode`) +
            FfiConverterOptionalUByte.allocationSize(value.`renew`) +
            FfiConverterOptionalUByte.allocationSize(value.`external`) +
            FfiConverterSequenceTypePlanEntitlement.allocationSize(value.`entitlements`) +
            FfiConverterSequenceTypePlanDecoration.allocationSize(value.`decorations`)
    )

    override fun write(value: Subscription, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`id`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterString.write(value.`title`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterOptionalUByte.write(value.`cycle`, buf)
            FfiConverterOptionalString.write(value.`cycleDescription`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterOptionalString.write(value.`offer`, buf)
            FfiConverterOptionalULong.write(value.`amount`, buf)
            FfiConverterOptionalULong.write(value.`renewAmount`, buf)
            FfiConverterOptionalLong.write(value.`discount`, buf)
            FfiConverterOptionalLong.write(value.`renewDiscount`, buf)
            FfiConverterOptionalULong.write(value.`periodStart`, buf)
            FfiConverterOptionalULong.write(value.`periodEnd`, buf)
            FfiConverterOptionalULong.write(value.`createTime`, buf)
            FfiConverterOptionalString.write(value.`couponCode`, buf)
            FfiConverterOptionalUByte.write(value.`renew`, buf)
            FfiConverterOptionalUByte.write(value.`external`, buf)
            FfiConverterSequenceTypePlanEntitlement.write(value.`entitlements`, buf)
            FfiConverterSequenceTypePlanDecoration.write(value.`decorations`, buf)
    }
}



/**
 * Current subscriptions.
 */
data class Subscriptions (
    var `current`: List<Subscription>, 
    var `upcoming`: List<Subscription>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSubscriptions: FfiConverterRustBuffer<Subscriptions> {
    override fun read(buf: ByteBuffer): Subscriptions {
        return Subscriptions(
            FfiConverterSequenceTypeSubscription.read(buf),
            FfiConverterSequenceTypeSubscription.read(buf),
        )
    }

    override fun allocationSize(value: Subscriptions) = (
            FfiConverterSequenceTypeSubscription.allocationSize(value.`current`) +
            FfiConverterSequenceTypeSubscription.allocationSize(value.`upcoming`)
    )

    override fun write(value: Subscriptions, buf: ByteBuffer) {
            FfiConverterSequenceTypeSubscription.write(value.`current`, buf)
            FfiConverterSequenceTypeSubscription.write(value.`upcoming`, buf)
    }
}



/**
 * Current settings related to the color scheme.
 * It affects on which CSS style is used in the HTML body of the message
 */
data class ThemeOpts (
    /**
     * What is the current UI color scheme, provided by the application.

     */
    var `currentTheme`: MailTheme, 
    /**
     * While using the dark mode, some bodies of messages might be hard to read.
     * User has an option to override the theme inside of the message (without changing the overall theme).
     *
     * Default: No override provided

     */
    var `themeOverride`: MailTheme? = null, 
    /**
     * Whether the device supports `@media (prefers-color-scheme: dark) {}` or not.
     *
     * Default: True - only Android 9 does not support it (so far)

     */
    var `supportsDarkModeViaMediaQuery`: kotlin.Boolean = true
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeThemeOpts: FfiConverterRustBuffer<ThemeOpts> {
    override fun read(buf: ByteBuffer): ThemeOpts {
        return ThemeOpts(
            FfiConverterTypeMailTheme.read(buf),
            FfiConverterOptionalTypeMailTheme.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ThemeOpts) = (
            FfiConverterTypeMailTheme.allocationSize(value.`currentTheme`) +
            FfiConverterOptionalTypeMailTheme.allocationSize(value.`themeOverride`) +
            FfiConverterBoolean.allocationSize(value.`supportsDarkModeViaMediaQuery`)
    )

    override fun write(value: ThemeOpts, buf: ByteBuffer) {
            FfiConverterTypeMailTheme.write(value.`currentTheme`, buf)
            FfiConverterOptionalTypeMailTheme.write(value.`themeOverride`, buf)
            FfiConverterBoolean.write(value.`supportsDarkModeViaMediaQuery`, buf)
    }
}



data class TrackerDomain (
    var `name`: kotlin.String, 
    var `urls`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTrackerDomain: FfiConverterRustBuffer<TrackerDomain> {
    override fun read(buf: ByteBuffer): TrackerDomain {
        return TrackerDomain(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: TrackerDomain) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterSequenceString.allocationSize(value.`urls`)
    )

    override fun write(value: TrackerDomain, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterSequenceString.write(value.`urls`, buf)
    }
}



data class TrackerInfo (
    var `trackers`: List<TrackerDomain>, 
    var `lastCheckedAt`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTrackerInfo: FfiConverterRustBuffer<TrackerInfo> {
    override fun read(buf: ByteBuffer): TrackerInfo {
        return TrackerInfo(
            FfiConverterSequenceTypeTrackerDomain.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: TrackerInfo) = (
            FfiConverterSequenceTypeTrackerDomain.allocationSize(value.`trackers`) +
            FfiConverterULong.allocationSize(value.`lastCheckedAt`)
    )

    override fun write(value: TrackerInfo, buf: ByteBuffer) {
            FfiConverterSequenceTypeTrackerDomain.write(value.`trackers`, buf)
            FfiConverterULong.write(value.`lastCheckedAt`, buf)
    }
}



data class TransformOpts (
    /**
     * Whether should show block quotes or not. Default: true
     */
    var `showBlockQuote`: kotlin.Boolean = true, 
    /**
     * Whether should hide remote images or not. Default: defined in mail settings
     */
    var `hideRemoteImages`: kotlin.Boolean? = null, 
    /**
     * Whether should hide embedded images or not. Default: defined in mail settings
     */
    var `hideEmbeddedImages`: kotlin.Boolean? = null, 
    /**
     * Current settings related to the color scheme.
     * It affects on which CSS style is used in the HTML body of the message
     *
     * Default: None
     * It assumes that the device supports `@media` queries. In that case
     * passing theme would be irrelevant.

     */
    var `theme`: ThemeOpts? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransformOpts: FfiConverterRustBuffer<TransformOpts> {
    override fun read(buf: ByteBuffer): TransformOpts {
        return TransformOpts(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalTypeThemeOpts.read(buf),
        )
    }

    override fun allocationSize(value: TransformOpts) = (
            FfiConverterBoolean.allocationSize(value.`showBlockQuote`) +
            FfiConverterOptionalBoolean.allocationSize(value.`hideRemoteImages`) +
            FfiConverterOptionalBoolean.allocationSize(value.`hideEmbeddedImages`) +
            FfiConverterOptionalTypeThemeOpts.allocationSize(value.`theme`)
    )

    override fun write(value: TransformOpts, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`showBlockQuote`, buf)
            FfiConverterOptionalBoolean.write(value.`hideRemoteImages`, buf)
            FfiConverterOptionalBoolean.write(value.`hideEmbeddedImages`, buf)
            FfiConverterOptionalTypeThemeOpts.write(value.`theme`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class TwoFa (
    /**
     * TODO: Document this field.
     */
    var `allowed`: TfaStatus, 
    /**
     * TODO: Document this field.
     */
    var `enabled`: TfaStatus, 
    /**
     * TODO: Document this field.
     */
    var `expirationTime`: kotlin.ULong?, 
    /**
     * TODO: Document this field.
     */
    var `registeredKeys`: List<FidoKey>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTwoFa: FfiConverterRustBuffer<TwoFa> {
    override fun read(buf: ByteBuffer): TwoFa {
        return TwoFa(
            FfiConverterTypeTfaStatus.read(buf),
            FfiConverterTypeTfaStatus.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterSequenceTypeFidoKey.read(buf),
        )
    }

    override fun allocationSize(value: TwoFa) = (
            FfiConverterTypeTfaStatus.allocationSize(value.`allowed`) +
            FfiConverterTypeTfaStatus.allocationSize(value.`enabled`) +
            FfiConverterOptionalULong.allocationSize(value.`expirationTime`) +
            FfiConverterSequenceTypeFidoKey.allocationSize(value.`registeredKeys`)
    )

    override fun write(value: TwoFa, buf: ByteBuffer) {
            FfiConverterTypeTfaStatus.write(value.`allowed`, buf)
            FfiConverterTypeTfaStatus.write(value.`enabled`, buf)
            FfiConverterOptionalULong.write(value.`expirationTime`, buf)
            FfiConverterSequenceTypeFidoKey.write(value.`registeredKeys`, buf)
    }
}



data class UtmLink (
    var `originalUrl`: kotlin.String, 
    var `cleanedUrl`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUTMLink: FfiConverterRustBuffer<UtmLink> {
    override fun read(buf: ByteBuffer): UtmLink {
        return UtmLink(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: UtmLink) = (
            FfiConverterString.allocationSize(value.`originalUrl`) +
            FfiConverterString.allocationSize(value.`cleanedUrl`)
    )

    override fun write(value: UtmLink, buf: ByteBuffer) {
            FfiConverterString.write(value.`originalUrl`, buf)
            FfiConverterString.write(value.`cleanedUrl`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class User (
    /**
     * TODO: Document this field.
     */
    var `createTime`: UnixTimestamp, 
    /**
     * TODO: Document this field.
     */
    var `credit`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `currency`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `delinquent`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `displayName`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `email`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `flags`: Flags, 
    /**
     * TODO: Document this field.
     */
    var `maxSpace`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `maxUpload`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `mnemonicStatus`: UserMnemonicStatus, 
    /**
     * TODO: Document this field.
     */
    var `private`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `name`: kotlin.String?, 
    /**
     * TODO: Document this field.
     */
    var `productUsedSpace`: ProductUsedSpace, 
    /**
     * TODO: Document this field.
     */
    var `role`: Role, 
    /**
     * TODO: Document this field.
     */
    var `services`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `subscribed`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `toMigrate`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `usedSpace`: kotlin.Long, 
    /**
     * TODO: Document this field.
     */
    var `userType`: UserType
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUser: FfiConverterRustBuffer<User> {
    override fun read(buf: ByteBuffer): User {
        return User(
            FfiConverterTypeUnixTimestamp.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeFlags.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterTypeUserMnemonicStatus.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeProductUsedSpace.read(buf),
            FfiConverterTypeRole.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterTypeUserType.read(buf),
        )
    }

    override fun allocationSize(value: User) = (
            FfiConverterTypeUnixTimestamp.allocationSize(value.`createTime`) +
            FfiConverterLong.allocationSize(value.`credit`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterUInt.allocationSize(value.`delinquent`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterString.allocationSize(value.`email`) +
            FfiConverterTypeFlags.allocationSize(value.`flags`) +
            FfiConverterLong.allocationSize(value.`maxSpace`) +
            FfiConverterLong.allocationSize(value.`maxUpload`) +
            FfiConverterTypeUserMnemonicStatus.allocationSize(value.`mnemonicStatus`) +
            FfiConverterBoolean.allocationSize(value.`private`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterTypeProductUsedSpace.allocationSize(value.`productUsedSpace`) +
            FfiConverterTypeRole.allocationSize(value.`role`) +
            FfiConverterUInt.allocationSize(value.`services`) +
            FfiConverterUInt.allocationSize(value.`subscribed`) +
            FfiConverterBoolean.allocationSize(value.`toMigrate`) +
            FfiConverterLong.allocationSize(value.`usedSpace`) +
            FfiConverterTypeUserType.allocationSize(value.`userType`)
    )

    override fun write(value: User, buf: ByteBuffer) {
            FfiConverterTypeUnixTimestamp.write(value.`createTime`, buf)
            FfiConverterLong.write(value.`credit`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterUInt.write(value.`delinquent`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterString.write(value.`email`, buf)
            FfiConverterTypeFlags.write(value.`flags`, buf)
            FfiConverterLong.write(value.`maxSpace`, buf)
            FfiConverterLong.write(value.`maxUpload`, buf)
            FfiConverterTypeUserMnemonicStatus.write(value.`mnemonicStatus`, buf)
            FfiConverterBoolean.write(value.`private`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterTypeProductUsedSpace.write(value.`productUsedSpace`, buf)
            FfiConverterTypeRole.write(value.`role`, buf)
            FfiConverterUInt.write(value.`services`, buf)
            FfiConverterUInt.write(value.`subscribed`, buf)
            FfiConverterBoolean.write(value.`toMigrate`, buf)
            FfiConverterLong.write(value.`usedSpace`, buf)
            FfiConverterTypeUserType.write(value.`userType`, buf)
    }
}



/**
 * TODO: Document this struct.
 */
data class UserSettings (
    /**
     * TODO: Document this field.
     */
    var `crashReports`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `dateFormat`: DateFormat, 
    /**
     * TODO: Document this field.
     */
    var `density`: Density, 
    /**
     * TODO: Document this field.
     */
    var `deviceRecovery`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `earlyAccess`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `email`: Email, 
    /**
     * TODO: Document this field.
     */
    var `flags`: SettingsFlags, 
    /**
     * TODO: Document this field.
     */
    var `hideSidePanel`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `highSecurity`: HighSecurity, 
    /**
     * TODO: Document this field.
     */
    var `invoiceText`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `locale`: kotlin.String, 
    /**
     * TODO: Document this field.
     */
    var `logAuth`: LogAuth, 
    /**
     * TODO: Document this field.
     */
    var `news`: kotlin.UInt, 
    /**
     * TODO: Document this field.
     */
    var `password`: Password, 
    /**
     * TODO: Document this field.
     */
    var `phone`: Phone, 
    /**
     * TODO: Document this field.
     */
    var `referral`: Referral?, 
    /**
     * TODO: Document this field.
     */
    var `sessionAccountRecovery`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `telemetry`: kotlin.Boolean, 
    /**
     * TODO: Document this field.
     */
    var `timeFormat`: TimeFormat, 
    /**
     * TODO: Document this field.
     */
    var `twoFactorAuth`: TwoFa, 
    /**
     * TODO: Document this field.
     */
    var `weekStart`: WeekStart, 
    /**
     * TODO: Document this field.
     */
    var `welcome`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserSettings: FfiConverterRustBuffer<UserSettings> {
    override fun read(buf: ByteBuffer): UserSettings {
        return UserSettings(
            FfiConverterBoolean.read(buf),
            FfiConverterTypeDateFormat.read(buf),
            FfiConverterTypeDensity.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeEmail.read(buf),
            FfiConverterTypeSettingsFlags.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeHighSecurity.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeLogAuth.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypePassword.read(buf),
            FfiConverterTypePhone.read(buf),
            FfiConverterOptionalTypeReferral.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeTimeFormat.read(buf),
            FfiConverterTypeTwoFa.read(buf),
            FfiConverterTypeWeekStart.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: UserSettings) = (
            FfiConverterBoolean.allocationSize(value.`crashReports`) +
            FfiConverterTypeDateFormat.allocationSize(value.`dateFormat`) +
            FfiConverterTypeDensity.allocationSize(value.`density`) +
            FfiConverterBoolean.allocationSize(value.`deviceRecovery`) +
            FfiConverterBoolean.allocationSize(value.`earlyAccess`) +
            FfiConverterTypeEmail.allocationSize(value.`email`) +
            FfiConverterTypeSettingsFlags.allocationSize(value.`flags`) +
            FfiConverterBoolean.allocationSize(value.`hideSidePanel`) +
            FfiConverterTypeHighSecurity.allocationSize(value.`highSecurity`) +
            FfiConverterString.allocationSize(value.`invoiceText`) +
            FfiConverterString.allocationSize(value.`locale`) +
            FfiConverterTypeLogAuth.allocationSize(value.`logAuth`) +
            FfiConverterUInt.allocationSize(value.`news`) +
            FfiConverterTypePassword.allocationSize(value.`password`) +
            FfiConverterTypePhone.allocationSize(value.`phone`) +
            FfiConverterOptionalTypeReferral.allocationSize(value.`referral`) +
            FfiConverterBoolean.allocationSize(value.`sessionAccountRecovery`) +
            FfiConverterBoolean.allocationSize(value.`telemetry`) +
            FfiConverterTypeTimeFormat.allocationSize(value.`timeFormat`) +
            FfiConverterTypeTwoFa.allocationSize(value.`twoFactorAuth`) +
            FfiConverterTypeWeekStart.allocationSize(value.`weekStart`) +
            FfiConverterBoolean.allocationSize(value.`welcome`)
    )

    override fun write(value: UserSettings, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`crashReports`, buf)
            FfiConverterTypeDateFormat.write(value.`dateFormat`, buf)
            FfiConverterTypeDensity.write(value.`density`, buf)
            FfiConverterBoolean.write(value.`deviceRecovery`, buf)
            FfiConverterBoolean.write(value.`earlyAccess`, buf)
            FfiConverterTypeEmail.write(value.`email`, buf)
            FfiConverterTypeSettingsFlags.write(value.`flags`, buf)
            FfiConverterBoolean.write(value.`hideSidePanel`, buf)
            FfiConverterTypeHighSecurity.write(value.`highSecurity`, buf)
            FfiConverterString.write(value.`invoiceText`, buf)
            FfiConverterString.write(value.`locale`, buf)
            FfiConverterTypeLogAuth.write(value.`logAuth`, buf)
            FfiConverterUInt.write(value.`news`, buf)
            FfiConverterTypePassword.write(value.`password`, buf)
            FfiConverterTypePhone.write(value.`phone`, buf)
            FfiConverterOptionalTypeReferral.write(value.`referral`, buf)
            FfiConverterBoolean.write(value.`sessionAccountRecovery`, buf)
            FfiConverterBoolean.write(value.`telemetry`, buf)
            FfiConverterTypeTimeFormat.write(value.`timeFormat`, buf)
            FfiConverterTypeTwoFa.write(value.`twoFactorAuth`, buf)
            FfiConverterTypeWeekStart.write(value.`weekStart`, buf)
            FfiConverterBoolean.write(value.`welcome`, buf)
    }
}



data class VCardUrl (
    var `url`: VCardUrlValue, 
    var `urlType`: List<VcardPropType>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVCardUrl: FfiConverterRustBuffer<VCardUrl> {
    override fun read(buf: ByteBuffer): VCardUrl {
        return VCardUrl(
            FfiConverterTypeVCardUrlValue.read(buf),
            FfiConverterSequenceTypeVcardPropType.read(buf),
        )
    }

    override fun allocationSize(value: VCardUrl) = (
            FfiConverterTypeVCardUrlValue.allocationSize(value.`url`) +
            FfiConverterSequenceTypeVcardPropType.allocationSize(value.`urlType`)
    )

    override fun write(value: VCardUrl, buf: ByteBuffer) {
            FfiConverterTypeVCardUrlValue.write(value.`url`, buf)
            FfiConverterSequenceTypeVcardPropType.write(value.`urlType`, buf)
    }
}



data class WatchedAccounts (
    var `accounts`: List<StoredAccount>, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`accounts`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedAccounts: FfiConverterRustBuffer<WatchedAccounts> {
    override fun read(buf: ByteBuffer): WatchedAccounts {
        return WatchedAccounts(
            FfiConverterSequenceTypeStoredAccount.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedAccounts) = (
            FfiConverterSequenceTypeStoredAccount.allocationSize(value.`accounts`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedAccounts, buf: ByteBuffer) {
            FfiConverterSequenceTypeStoredAccount.write(value.`accounts`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedContactList (
    var `contactList`: List<GroupedContacts>, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`contactList`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedContactList: FfiConverterRustBuffer<WatchedContactList> {
    override fun read(buf: ByteBuffer): WatchedContactList {
        return WatchedContactList(
            FfiConverterSequenceTypeGroupedContacts.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedContactList) = (
            FfiConverterSequenceTypeGroupedContacts.allocationSize(value.`contactList`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedContactList, buf: ByteBuffer) {
            FfiConverterSequenceTypeGroupedContacts.write(value.`contactList`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedConversation (
    var `conversation`: Conversation, 
    var `messages`: List<Message>, 
    var `focusedMessageId`: Id?, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`conversation`,
        this.`messages`,
        this.`focusedMessageId`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedConversation: FfiConverterRustBuffer<WatchedConversation> {
    override fun read(buf: ByteBuffer): WatchedConversation {
        return WatchedConversation(
            FfiConverterTypeConversation.read(buf),
            FfiConverterSequenceTypeMessage.read(buf),
            FfiConverterOptionalTypeId.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedConversation) = (
            FfiConverterTypeConversation.allocationSize(value.`conversation`) +
            FfiConverterSequenceTypeMessage.allocationSize(value.`messages`) +
            FfiConverterOptionalTypeId.allocationSize(value.`focusedMessageId`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedConversation, buf: ByteBuffer) {
            FfiConverterTypeConversation.write(value.`conversation`, buf)
            FfiConverterSequenceTypeMessage.write(value.`messages`, buf)
            FfiConverterOptionalTypeId.write(value.`focusedMessageId`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedConversations (
    var `conversations`: List<Conversation>, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`conversations`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedConversations: FfiConverterRustBuffer<WatchedConversations> {
    override fun read(buf: ByteBuffer): WatchedConversations {
        return WatchedConversations(
            FfiConverterSequenceTypeConversation.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedConversations) = (
            FfiConverterSequenceTypeConversation.allocationSize(value.`conversations`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedConversations, buf: ByteBuffer) {
            FfiConverterSequenceTypeConversation.write(value.`conversations`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedFeatureFlags (
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedFeatureFlags: FfiConverterRustBuffer<WatchedFeatureFlags> {
    override fun read(buf: ByteBuffer): WatchedFeatureFlags {
        return WatchedFeatureFlags(
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedFeatureFlags) = (
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedFeatureFlags, buf: ByteBuffer) {
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedMessage (
    var `message`: Message, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`message`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedMessage: FfiConverterRustBuffer<WatchedMessage> {
    override fun read(buf: ByteBuffer): WatchedMessage {
        return WatchedMessage(
            FfiConverterTypeMessage.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedMessage) = (
            FfiConverterTypeMessage.allocationSize(value.`message`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedMessage, buf: ByteBuffer) {
            FfiConverterTypeMessage.write(value.`message`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}



data class WatchedSessions (
    var `sessions`: List<StoredSession>, 
    var `handle`: WatchHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`sessions`,
        this.`handle`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchedSessions: FfiConverterRustBuffer<WatchedSessions> {
    override fun read(buf: ByteBuffer): WatchedSessions {
        return WatchedSessions(
            FfiConverterSequenceTypeStoredSession.read(buf),
            FfiConverterTypeWatchHandle.read(buf),
        )
    }

    override fun allocationSize(value: WatchedSessions) = (
            FfiConverterSequenceTypeStoredSession.allocationSize(value.`sessions`) +
            FfiConverterTypeWatchHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WatchedSessions, buf: ByteBuffer) {
            FfiConverterSequenceTypeStoredSession.write(value.`sessions`, buf)
            FfiConverterTypeWatchHandle.write(value.`handle`, buf)
    }
}




enum class AccountRecoveryScreenId {
    
    GRACE_PERIOD_INFO,
    CANCEL_RESET_PASSWORD,
    PASSWORD_CHANGE_INFO,
    RECOVERY_CANCELLED_INFO,
    RECOVERY_EXPIRED_INFO;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAccountRecoveryScreenId: FfiConverterRustBuffer<AccountRecoveryScreenId> {
    override fun read(buf: ByteBuffer) = try {
        AccountRecoveryScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AccountRecoveryScreenId) = 4UL

    override fun write(value: AccountRecoveryScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ActionError {
    
    data class Reason(
        val v1: ActionErrorReason) : ActionError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : ActionError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeActionError : FfiConverterRustBuffer<ActionError>{
    override fun read(buf: ByteBuffer): ActionError {
        return when(buf.getInt()) {
            1 -> ActionError.Reason(
                FfiConverterTypeActionErrorReason.read(buf),
                )
            2 -> ActionError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ActionError) = when(value) {
        is ActionError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionErrorReason.allocationSize(value.v1)
            )
        }
        is ActionError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ActionError, buf: ByteBuffer) {
        when(value) {
            is ActionError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeActionErrorReason.write(value.v1, buf)
                Unit
            }
            is ActionError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason for error occurrence within ActionQueue
 *
 * This enum is used to represent the specific reason for an error that occurred
 * in order to provide only the necessary information to the user.
 */

enum class ActionErrorReason {
    
    UNKNOWN_LABEL,
    UNKNOWN_MESSAGE,
    UNKNOWN_CONTENT_ID;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeActionErrorReason: FfiConverterRustBuffer<ActionErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        ActionErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ActionErrorReason) = 4UL

    override fun write(value: ActionErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Errors which occur when adding a recipients which are part of a group.
 */
sealed class AddGroupRecipientError {
    
    /**
     * No errors occurred
     */
    object Ok : AddGroupRecipientError()
    
    
    /**
     * The current addresses already exist in the recipient list.
     */
    data class Duplicate(
        val v1: List<kotlin.String>) : AddGroupRecipientError() {
        companion object
    }
    
    /**
     * Failed to queue save action for draft.
     */
    data class SaveFailed(
        val v1: DraftSaveError) : AddGroupRecipientError() {
        companion object
    }
    
    /**
     * Empty group name
     */
    object EmptyGroupName : AddGroupRecipientError()
    
    
    /**
     * Another error occurred
     */
    object Other : AddGroupRecipientError()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddGroupRecipientError : FfiConverterRustBuffer<AddGroupRecipientError>{
    override fun read(buf: ByteBuffer): AddGroupRecipientError {
        return when(buf.getInt()) {
            1 -> AddGroupRecipientError.Ok
            2 -> AddGroupRecipientError.Duplicate(
                FfiConverterSequenceString.read(buf),
                )
            3 -> AddGroupRecipientError.SaveFailed(
                FfiConverterTypeDraftSaveError.read(buf),
                )
            4 -> AddGroupRecipientError.EmptyGroupName
            5 -> AddGroupRecipientError.Other
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AddGroupRecipientError) = when(value) {
        is AddGroupRecipientError.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AddGroupRecipientError.Duplicate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is AddGroupRecipientError.SaveFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveError.allocationSize(value.v1)
            )
        }
        is AddGroupRecipientError.EmptyGroupName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AddGroupRecipientError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AddGroupRecipientError, buf: ByteBuffer) {
        when(value) {
            is AddGroupRecipientError.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AddGroupRecipientError.Duplicate -> {
                buf.putInt(2)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is AddGroupRecipientError.SaveFailed -> {
                buf.putInt(3)
                FfiConverterTypeDraftSaveError.write(value.v1, buf)
                Unit
            }
            is AddGroupRecipientError.EmptyGroupName -> {
                buf.putInt(4)
                Unit
            }
            is AddGroupRecipientError.Other -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Errors which occur when adding a single recipient
 */
sealed class AddSingleRecipientError {
    
    /**
     * No errors occurred
     */
    object Ok : AddSingleRecipientError()
    
    
    /**
     * The current address already exists in the recipient list.
     */
    object Duplicate : AddSingleRecipientError()
    
    
    /**
     * Failed to queue save action for draft.
     */
    data class SaveFailed(
        val v1: DraftSaveError) : AddSingleRecipientError() {
        companion object
    }
    
    /**
     * Another error occurred
     */
    object Other : AddSingleRecipientError()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddSingleRecipientError : FfiConverterRustBuffer<AddSingleRecipientError>{
    override fun read(buf: ByteBuffer): AddSingleRecipientError {
        return when(buf.getInt()) {
            1 -> AddSingleRecipientError.Ok
            2 -> AddSingleRecipientError.Duplicate
            3 -> AddSingleRecipientError.SaveFailed(
                FfiConverterTypeDraftSaveError.read(buf),
                )
            4 -> AddSingleRecipientError.Other
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AddSingleRecipientError) = when(value) {
        is AddSingleRecipientError.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AddSingleRecipientError.Duplicate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AddSingleRecipientError.SaveFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveError.allocationSize(value.v1)
            )
        }
        is AddSingleRecipientError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AddSingleRecipientError, buf: ByteBuffer) {
        when(value) {
            is AddSingleRecipientError.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AddSingleRecipientError.Duplicate -> {
                buf.putInt(2)
                Unit
            }
            is AddSingleRecipientError.SaveFailed -> {
                buf.putInt(3)
                FfiConverterTypeDraftSaveError.write(value.v1, buf)
                Unit
            }
            is AddSingleRecipientError.Other -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class AddressStatus(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this field.
     */
    DISABLED(0u),
    /**
     * TODO: Document this field.
     */
    ENABLED(1u),
    /**
     * TODO: Document this field.
     */
    DELETING(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressStatus: FfiConverterRustBuffer<AddressStatus> {
    override fun read(buf: ByteBuffer) = try {
        AddressStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AddressStatus) = 4UL

    override fun write(value: AddressStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * TODO: Document this enum.
 */

enum class AddressType(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    ORIGINAL(1u),
    /**
     * TODO: Document this variant.
     */
    ALIAS(2u),
    /**
     * TODO: Document this variant.
     */
    CUSTOM(3u),
    /**
     * TODO: Document this variant.
     */
    PREMIUM(4u),
    /**
     * TODO: Document this variant.
     */
    EXTERNAL(5u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressType: FfiConverterRustBuffer<AddressType> {
    override fun read(buf: ByteBuffer) = try {
        AddressType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AddressType) = 4UL

    override fun write(value: AddressType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class AllAvailableConversationActionsForActionSheetResult {
    
    data class Ok(
        val v1: ConversationActionSheet) : AllAvailableConversationActionsForActionSheetResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableConversationActionsForActionSheetResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableConversationActionsForActionSheetResult : FfiConverterRustBuffer<AllAvailableConversationActionsForActionSheetResult>{
    override fun read(buf: ByteBuffer): AllAvailableConversationActionsForActionSheetResult {
        return when(buf.getInt()) {
            1 -> AllAvailableConversationActionsForActionSheetResult.Ok(
                FfiConverterTypeConversationActionSheet.read(buf),
                )
            2 -> AllAvailableConversationActionsForActionSheetResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableConversationActionsForActionSheetResult) = when(value) {
        is AllAvailableConversationActionsForActionSheetResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConversationActionSheet.allocationSize(value.v1)
            )
        }
        is AllAvailableConversationActionsForActionSheetResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableConversationActionsForActionSheetResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableConversationActionsForActionSheetResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeConversationActionSheet.write(value.v1, buf)
                Unit
            }
            is AllAvailableConversationActionsForActionSheetResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AllAvailableConversationActionsForConversationResult {
    
    data class Ok(
        val v1: AllConversationActions) : AllAvailableConversationActionsForConversationResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableConversationActionsForConversationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableConversationActionsForConversationResult : FfiConverterRustBuffer<AllAvailableConversationActionsForConversationResult>{
    override fun read(buf: ByteBuffer): AllAvailableConversationActionsForConversationResult {
        return when(buf.getInt()) {
            1 -> AllAvailableConversationActionsForConversationResult.Ok(
                FfiConverterTypeAllConversationActions.read(buf),
                )
            2 -> AllAvailableConversationActionsForConversationResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableConversationActionsForConversationResult) = when(value) {
        is AllAvailableConversationActionsForConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAllConversationActions.allocationSize(value.v1)
            )
        }
        is AllAvailableConversationActionsForConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableConversationActionsForConversationResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableConversationActionsForConversationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAllConversationActions.write(value.v1, buf)
                Unit
            }
            is AllAvailableConversationActionsForConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AllAvailableListActionsForConversationsResult {
    
    data class Ok(
        val v1: AllListActions) : AllAvailableListActionsForConversationsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableListActionsForConversationsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableListActionsForConversationsResult : FfiConverterRustBuffer<AllAvailableListActionsForConversationsResult>{
    override fun read(buf: ByteBuffer): AllAvailableListActionsForConversationsResult {
        return when(buf.getInt()) {
            1 -> AllAvailableListActionsForConversationsResult.Ok(
                FfiConverterTypeAllListActions.read(buf),
                )
            2 -> AllAvailableListActionsForConversationsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableListActionsForConversationsResult) = when(value) {
        is AllAvailableListActionsForConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAllListActions.allocationSize(value.v1)
            )
        }
        is AllAvailableListActionsForConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableListActionsForConversationsResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableListActionsForConversationsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAllListActions.write(value.v1, buf)
                Unit
            }
            is AllAvailableListActionsForConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AllAvailableListActionsForMessagesResult {
    
    data class Ok(
        val v1: AllListActions) : AllAvailableListActionsForMessagesResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableListActionsForMessagesResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableListActionsForMessagesResult : FfiConverterRustBuffer<AllAvailableListActionsForMessagesResult>{
    override fun read(buf: ByteBuffer): AllAvailableListActionsForMessagesResult {
        return when(buf.getInt()) {
            1 -> AllAvailableListActionsForMessagesResult.Ok(
                FfiConverterTypeAllListActions.read(buf),
                )
            2 -> AllAvailableListActionsForMessagesResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableListActionsForMessagesResult) = when(value) {
        is AllAvailableListActionsForMessagesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAllListActions.allocationSize(value.v1)
            )
        }
        is AllAvailableListActionsForMessagesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableListActionsForMessagesResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableListActionsForMessagesResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAllListActions.write(value.v1, buf)
                Unit
            }
            is AllAvailableListActionsForMessagesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AllAvailableMessageActionsForActionSheetResult {
    
    data class Ok(
        val v1: MessageActionSheet) : AllAvailableMessageActionsForActionSheetResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableMessageActionsForActionSheetResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableMessageActionsForActionSheetResult : FfiConverterRustBuffer<AllAvailableMessageActionsForActionSheetResult>{
    override fun read(buf: ByteBuffer): AllAvailableMessageActionsForActionSheetResult {
        return when(buf.getInt()) {
            1 -> AllAvailableMessageActionsForActionSheetResult.Ok(
                FfiConverterTypeMessageActionSheet.read(buf),
                )
            2 -> AllAvailableMessageActionsForActionSheetResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableMessageActionsForActionSheetResult) = when(value) {
        is AllAvailableMessageActionsForActionSheetResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageActionSheet.allocationSize(value.v1)
            )
        }
        is AllAvailableMessageActionsForActionSheetResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableMessageActionsForActionSheetResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableMessageActionsForActionSheetResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMessageActionSheet.write(value.v1, buf)
                Unit
            }
            is AllAvailableMessageActionsForActionSheetResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AllAvailableMessageActionsForMessageResult {
    
    data class Ok(
        val v1: AllMessageActions) : AllAvailableMessageActionsForMessageResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AllAvailableMessageActionsForMessageResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAllAvailableMessageActionsForMessageResult : FfiConverterRustBuffer<AllAvailableMessageActionsForMessageResult>{
    override fun read(buf: ByteBuffer): AllAvailableMessageActionsForMessageResult {
        return when(buf.getInt()) {
            1 -> AllAvailableMessageActionsForMessageResult.Ok(
                FfiConverterTypeAllMessageActions.read(buf),
                )
            2 -> AllAvailableMessageActionsForMessageResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllAvailableMessageActionsForMessageResult) = when(value) {
        is AllAvailableMessageActionsForMessageResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAllMessageActions.allocationSize(value.v1)
            )
        }
        is AllAvailableMessageActionsForMessageResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AllAvailableMessageActionsForMessageResult, buf: ByteBuffer) {
        when(value) {
            is AllAvailableMessageActionsForMessageResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAllMessageActions.write(value.v1, buf)
                Unit
            }
            is AllAvailableMessageActionsForMessageResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class AlmostAllMail(val value: kotlin.UByte) {
    
    ALL_MAIL(0u),
    ALMOST_ALL_MAIL(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAlmostAllMail: FfiConverterRustBuffer<AlmostAllMail> {
    override fun read(buf: ByteBuffer) = try {
        AlmostAllMail.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AlmostAllMail) = 4UL

    override fun write(value: AlmostAllMail, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * An environment identifier.
 *
 * This enum represents the different environments that can be used by the
 * API client. The environments are used to determine the base URL for the
 * API requests and the TLS pins to use.
 */
sealed class ApiEnvId {
    
    /**
     * The production API environment.
     *
     * This environment represents the production Proton API, used by default.
     * Clients configured with this environment will connect to `https://<app>.proton.me/`,
     * with the exact domain depending on the app version.
     */
    object Prod : ApiEnvId()
    
    
    /**
     * The standard atlas environment.
     *
     * Clients configured with this environment will connect to `https://proton.black/api`.
     */
    object Atlas : ApiEnvId()
    
    
    /**
     * A named atlas environment.
     *
     * Clients configured with this environment will connect to `https://<name>.proton.black/api`.
     */
    data class Scientist(
        val v1: kotlin.String) : ApiEnvId() {
        companion object
    }
    
    /**
     * A specific environment specified by its URL.
     *
     * Clients configured with this environment will connect to the specified URL,
     * which must be a valid URL with a scheme, host, and if necessary, a port.
     *
     * This is useful for testing but MUST NOT be used in production.
     * Ideally, this would be protected by compile-time feature flags.
     *
     * TODO: Protect this with a compile-time feature flag.
     */
    data class Custom(
        val v1: kotlin.String) : ApiEnvId() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeApiEnvId : FfiConverterRustBuffer<ApiEnvId>{
    override fun read(buf: ByteBuffer): ApiEnvId {
        return when(buf.getInt()) {
            1 -> ApiEnvId.Prod
            2 -> ApiEnvId.Atlas
            3 -> ApiEnvId.Scientist(
                FfiConverterString.read(buf),
                )
            4 -> ApiEnvId.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ApiEnvId) = when(value) {
        is ApiEnvId.Prod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ApiEnvId.Atlas -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ApiEnvId.Scientist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ApiEnvId.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ApiEnvId, buf: ByteBuffer) {
        when(value) {
            is ApiEnvId.Prod -> {
                buf.putInt(1)
                Unit
            }
            is ApiEnvId.Atlas -> {
                buf.putInt(2)
                Unit
            }
            is ApiEnvId.Scientist -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ApiEnvId.Custom -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Representation of available themes for the app.

 */

enum class AppAppearance(val value: kotlin.UByte) {
    
    SYSTEM(0u),
    DARK_MODE(1u),
    LIGHT_MODE(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAppAppearance: FfiConverterRustBuffer<AppAppearance> {
    override fun read(buf: ByteBuffer) = try {
        AppAppearance.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AppAppearance) = 4UL

    override fun write(value: AppAppearance, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Supported additional protection for accessing app.

 */

enum class AppProtection(val value: kotlin.UByte) {
    
    NONE(0u),
    BIOMETRICS(1u),
    PIN(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAppProtection: FfiConverterRustBuffer<AppProtection> {
    override fun read(buf: ByteBuffer) = try {
        AppProtection.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AppProtection) = 4UL

    override fun write(value: AppProtection, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Contains information of what exactly has to happen when user swipes item (conversation, message)
 * right or left.
 *
 * This is different than [`SwipeAction`] as it contains extra information like label Remote ID.

 */
sealed class AssignedSwipeAction {
    
    object NoAction : AssignedSwipeAction()
    
    
    data class MoveTo(
        val v1: SwipeActionMoveToTarget) : AssignedSwipeAction() {
        companion object
    }
    
    object LabelAs : AssignedSwipeAction()
    
    
    object ToggleStar : AssignedSwipeAction()
    
    
    object ToggleRead : AssignedSwipeAction()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssignedSwipeAction : FfiConverterRustBuffer<AssignedSwipeAction>{
    override fun read(buf: ByteBuffer): AssignedSwipeAction {
        return when(buf.getInt()) {
            1 -> AssignedSwipeAction.NoAction
            2 -> AssignedSwipeAction.MoveTo(
                FfiConverterTypeSwipeActionMoveToTarget.read(buf),
                )
            3 -> AssignedSwipeAction.LabelAs
            4 -> AssignedSwipeAction.ToggleStar
            5 -> AssignedSwipeAction.ToggleRead
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AssignedSwipeAction) = when(value) {
        is AssignedSwipeAction.NoAction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AssignedSwipeAction.MoveTo -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSwipeActionMoveToTarget.allocationSize(value.v1)
            )
        }
        is AssignedSwipeAction.LabelAs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AssignedSwipeAction.ToggleStar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AssignedSwipeAction.ToggleRead -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AssignedSwipeAction, buf: ByteBuffer) {
        when(value) {
            is AssignedSwipeAction.NoAction -> {
                buf.putInt(1)
                Unit
            }
            is AssignedSwipeAction.MoveTo -> {
                buf.putInt(2)
                FfiConverterTypeSwipeActionMoveToTarget.write(value.v1, buf)
                Unit
            }
            is AssignedSwipeAction.LabelAs -> {
                buf.putInt(3)
                Unit
            }
            is AssignedSwipeAction.ToggleStar -> {
                buf.putInt(4)
                Unit
            }
            is AssignedSwipeAction.ToggleRead -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AssignedSwipeActionsResult {
    
    data class Ok(
        val v1: AssignedSwipeActions) : AssignedSwipeActionsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AssignedSwipeActionsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssignedSwipeActionsResult : FfiConverterRustBuffer<AssignedSwipeActionsResult>{
    override fun read(buf: ByteBuffer): AssignedSwipeActionsResult {
        return when(buf.getInt()) {
            1 -> AssignedSwipeActionsResult.Ok(
                FfiConverterTypeAssignedSwipeActions.read(buf),
                )
            2 -> AssignedSwipeActionsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AssignedSwipeActionsResult) = when(value) {
        is AssignedSwipeActionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAssignedSwipeActions.allocationSize(value.v1)
            )
        }
        is AssignedSwipeActionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AssignedSwipeActionsResult, buf: ByteBuffer) {
        when(value) {
            is AssignedSwipeActionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAssignedSwipeActions.write(value.v1, buf)
                Unit
            }
            is AssignedSwipeActionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentDataError {
    
    object ProxyFailed : AttachmentDataError()
    
    
    data class Other(
        val v1: ProtonError) : AttachmentDataError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentDataError : FfiConverterRustBuffer<AttachmentDataError>{
    override fun read(buf: ByteBuffer): AttachmentDataError {
        return when(buf.getInt()) {
            1 -> AttachmentDataError.ProxyFailed
            2 -> AttachmentDataError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentDataError) = when(value) {
        is AttachmentDataError.ProxyFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AttachmentDataError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentDataError, buf: ByteBuffer) {
        when(value) {
            is AttachmentDataError.ProxyFailed -> {
                buf.putInt(1)
                Unit
            }
            is AttachmentDataError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentDataResult {
    
    data class Ok(
        val v1: AttachmentData) : AttachmentDataResult() {
        companion object
    }
    
    data class Error(
        val v1: AttachmentDataError) : AttachmentDataResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentDataResult : FfiConverterRustBuffer<AttachmentDataResult>{
    override fun read(buf: ByteBuffer): AttachmentDataResult {
        return when(buf.getInt()) {
            1 -> AttachmentDataResult.Ok(
                FfiConverterTypeAttachmentData.read(buf),
                )
            2 -> AttachmentDataResult.Error(
                FfiConverterTypeAttachmentDataError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentDataResult) = when(value) {
        is AttachmentDataResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAttachmentData.allocationSize(value.v1)
            )
        }
        is AttachmentDataResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAttachmentDataError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentDataResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentDataResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAttachmentData.write(value.v1, buf)
                Unit
            }
            is AttachmentDataResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeAttachmentDataError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListAddInlineResult {
    
    data class Ok(
        val v1: kotlin.String) : AttachmentListAddInlineResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListAddInlineResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListAddInlineResult : FfiConverterRustBuffer<AttachmentListAddInlineResult>{
    override fun read(buf: ByteBuffer): AttachmentListAddInlineResult {
        return when(buf.getInt()) {
            1 -> AttachmentListAddInlineResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> AttachmentListAddInlineResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListAddInlineResult) = when(value) {
        is AttachmentListAddInlineResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is AttachmentListAddInlineResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListAddInlineResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListAddInlineResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AttachmentListAddInlineResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListAddResult {
    
    object Ok : AttachmentListAddResult()
    
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListAddResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListAddResult : FfiConverterRustBuffer<AttachmentListAddResult>{
    override fun read(buf: ByteBuffer): AttachmentListAddResult {
        return when(buf.getInt()) {
            1 -> AttachmentListAddResult.Ok
            2 -> AttachmentListAddResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListAddResult) = when(value) {
        is AttachmentListAddResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AttachmentListAddResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListAddResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListAddResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AttachmentListAddResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListAttachmentsResult {
    
    data class Ok(
        val v1: List<DraftAttachment>) : AttachmentListAttachmentsResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListAttachmentsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListAttachmentsResult : FfiConverterRustBuffer<AttachmentListAttachmentsResult>{
    override fun read(buf: ByteBuffer): AttachmentListAttachmentsResult {
        return when(buf.getInt()) {
            1 -> AttachmentListAttachmentsResult.Ok(
                FfiConverterSequenceTypeDraftAttachment.read(buf),
                )
            2 -> AttachmentListAttachmentsResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListAttachmentsResult) = when(value) {
        is AttachmentListAttachmentsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeDraftAttachment.allocationSize(value.v1)
            )
        }
        is AttachmentListAttachmentsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListAttachmentsResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListAttachmentsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeDraftAttachment.write(value.v1, buf)
                Unit
            }
            is AttachmentListAttachmentsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListRemoveResult {
    
    object Ok : AttachmentListRemoveResult()
    
    
    data class Error(
        val v1: ProtonError) : AttachmentListRemoveResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListRemoveResult : FfiConverterRustBuffer<AttachmentListRemoveResult>{
    override fun read(buf: ByteBuffer): AttachmentListRemoveResult {
        return when(buf.getInt()) {
            1 -> AttachmentListRemoveResult.Ok
            2 -> AttachmentListRemoveResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListRemoveResult) = when(value) {
        is AttachmentListRemoveResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AttachmentListRemoveResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListRemoveResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListRemoveResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AttachmentListRemoveResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListRemoveWithCidResult {
    
    object Ok : AttachmentListRemoveWithCidResult()
    
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListRemoveWithCidResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListRemoveWithCidResult : FfiConverterRustBuffer<AttachmentListRemoveWithCidResult>{
    override fun read(buf: ByteBuffer): AttachmentListRemoveWithCidResult {
        return when(buf.getInt()) {
            1 -> AttachmentListRemoveWithCidResult.Ok
            2 -> AttachmentListRemoveWithCidResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListRemoveWithCidResult) = when(value) {
        is AttachmentListRemoveWithCidResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AttachmentListRemoveWithCidResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListRemoveWithCidResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListRemoveWithCidResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AttachmentListRemoveWithCidResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListRetryResult {
    
    object Ok : AttachmentListRetryResult()
    
    
    data class Error(
        val v1: DraftAttachmentRetryError) : AttachmentListRetryResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListRetryResult : FfiConverterRustBuffer<AttachmentListRetryResult>{
    override fun read(buf: ByteBuffer): AttachmentListRetryResult {
        return when(buf.getInt()) {
            1 -> AttachmentListRetryResult.Ok
            2 -> AttachmentListRetryResult.Error(
                FfiConverterTypeDraftAttachmentRetryError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListRetryResult) = when(value) {
        is AttachmentListRetryResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AttachmentListRetryResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentRetryError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListRetryResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListRetryResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is AttachmentListRetryResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentRetryError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListWatcherResult: Disposable  {
    
    data class Ok(
        val v1: DraftAttachmentWatcher) : AttachmentListWatcherResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListWatcherResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AttachmentListWatcherResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AttachmentListWatcherResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListWatcherResult : FfiConverterRustBuffer<AttachmentListWatcherResult>{
    override fun read(buf: ByteBuffer): AttachmentListWatcherResult {
        return when(buf.getInt()) {
            1 -> AttachmentListWatcherResult.Ok(
                FfiConverterTypeDraftAttachmentWatcher.read(buf),
                )
            2 -> AttachmentListWatcherResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListWatcherResult) = when(value) {
        is AttachmentListWatcherResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentWatcher.allocationSize(value.v1)
            )
        }
        is AttachmentListWatcherResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListWatcherResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListWatcherResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentWatcher.write(value.v1, buf)
                Unit
            }
            is AttachmentListWatcherResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AttachmentListWatcherStreamResult: Disposable  {
    
    data class Ok(
        val v1: DraftAttachmentListUpdateStream) : AttachmentListWatcherStreamResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftAttachmentUploadError) : AttachmentListWatcherStreamResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AttachmentListWatcherStreamResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AttachmentListWatcherStreamResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAttachmentListWatcherStreamResult : FfiConverterRustBuffer<AttachmentListWatcherStreamResult>{
    override fun read(buf: ByteBuffer): AttachmentListWatcherStreamResult {
        return when(buf.getInt()) {
            1 -> AttachmentListWatcherStreamResult.Ok(
                FfiConverterTypeDraftAttachmentListUpdateStream.read(buf),
                )
            2 -> AttachmentListWatcherStreamResult.Error(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AttachmentListWatcherStreamResult) = when(value) {
        is AttachmentListWatcherStreamResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentListUpdateStream.allocationSize(value.v1)
            )
        }
        is AttachmentListWatcherStreamResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AttachmentListWatcherStreamResult, buf: ByteBuffer) {
        when(value) {
            is AttachmentListWatcherStreamResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentListUpdateStream.write(value.v1, buf)
                Unit
            }
            is AttachmentListWatcherStreamResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class AutoDeleteState {
    
    AUTO_DELETE_UPSELL,
    AUTO_DELETE_DISABLED,
    AUTO_DELETE_ENABLED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAutoDeleteState: FfiConverterRustBuffer<AutoDeleteState> {
    override fun read(buf: ByteBuffer) = try {
        AutoDeleteState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AutoDeleteState) = 4UL

    override fun write(value: AutoDeleteState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * How much time till app in the background will require
 * authentication when going to foreground.

 */
sealed class AutoLock {
    
    object Always : AutoLock()
    
    
    data class Minutes(
        val v1: kotlin.UByte) : AutoLock() {
        companion object
    }
    
    object Never : AutoLock()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAutoLock : FfiConverterRustBuffer<AutoLock>{
    override fun read(buf: ByteBuffer): AutoLock {
        return when(buf.getInt()) {
            1 -> AutoLock.Always
            2 -> AutoLock.Minutes(
                FfiConverterUByte.read(buf),
                )
            3 -> AutoLock.Never
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AutoLock) = when(value) {
        is AutoLock.Always -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AutoLock.Minutes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.v1)
            )
        }
        is AutoLock.Never -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AutoLock, buf: ByteBuffer) {
        when(value) {
            is AutoLock.Always -> {
                buf.putInt(1)
                Unit
            }
            is AutoLock.Minutes -> {
                buf.putInt(2)
                FfiConverterUByte.write(value.v1, buf)
                Unit
            }
            is AutoLock.Never -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AvailableLabelAsActionsForConversationsResult {
    
    data class Ok(
        val v1: List<LabelAsAction>) : AvailableLabelAsActionsForConversationsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AvailableLabelAsActionsForConversationsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvailableLabelAsActionsForConversationsResult : FfiConverterRustBuffer<AvailableLabelAsActionsForConversationsResult>{
    override fun read(buf: ByteBuffer): AvailableLabelAsActionsForConversationsResult {
        return when(buf.getInt()) {
            1 -> AvailableLabelAsActionsForConversationsResult.Ok(
                FfiConverterSequenceTypeLabelAsAction.read(buf),
                )
            2 -> AvailableLabelAsActionsForConversationsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AvailableLabelAsActionsForConversationsResult) = when(value) {
        is AvailableLabelAsActionsForConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeLabelAsAction.allocationSize(value.v1)
            )
        }
        is AvailableLabelAsActionsForConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AvailableLabelAsActionsForConversationsResult, buf: ByteBuffer) {
        when(value) {
            is AvailableLabelAsActionsForConversationsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeLabelAsAction.write(value.v1, buf)
                Unit
            }
            is AvailableLabelAsActionsForConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AvailableLabelAsActionsForMessagesResult {
    
    data class Ok(
        val v1: List<LabelAsAction>) : AvailableLabelAsActionsForMessagesResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AvailableLabelAsActionsForMessagesResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvailableLabelAsActionsForMessagesResult : FfiConverterRustBuffer<AvailableLabelAsActionsForMessagesResult>{
    override fun read(buf: ByteBuffer): AvailableLabelAsActionsForMessagesResult {
        return when(buf.getInt()) {
            1 -> AvailableLabelAsActionsForMessagesResult.Ok(
                FfiConverterSequenceTypeLabelAsAction.read(buf),
                )
            2 -> AvailableLabelAsActionsForMessagesResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AvailableLabelAsActionsForMessagesResult) = when(value) {
        is AvailableLabelAsActionsForMessagesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeLabelAsAction.allocationSize(value.v1)
            )
        }
        is AvailableLabelAsActionsForMessagesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AvailableLabelAsActionsForMessagesResult, buf: ByteBuffer) {
        when(value) {
            is AvailableLabelAsActionsForMessagesResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeLabelAsAction.write(value.v1, buf)
                Unit
            }
            is AvailableLabelAsActionsForMessagesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AvailableMoveToActionsForConversationsResult {
    
    data class Ok(
        val v1: List<MoveAction>) : AvailableMoveToActionsForConversationsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AvailableMoveToActionsForConversationsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvailableMoveToActionsForConversationsResult : FfiConverterRustBuffer<AvailableMoveToActionsForConversationsResult>{
    override fun read(buf: ByteBuffer): AvailableMoveToActionsForConversationsResult {
        return when(buf.getInt()) {
            1 -> AvailableMoveToActionsForConversationsResult.Ok(
                FfiConverterSequenceTypeMoveAction.read(buf),
                )
            2 -> AvailableMoveToActionsForConversationsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AvailableMoveToActionsForConversationsResult) = when(value) {
        is AvailableMoveToActionsForConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeMoveAction.allocationSize(value.v1)
            )
        }
        is AvailableMoveToActionsForConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AvailableMoveToActionsForConversationsResult, buf: ByteBuffer) {
        when(value) {
            is AvailableMoveToActionsForConversationsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeMoveAction.write(value.v1, buf)
                Unit
            }
            is AvailableMoveToActionsForConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AvailableMoveToActionsForMessagesResult {
    
    data class Ok(
        val v1: List<MoveAction>) : AvailableMoveToActionsForMessagesResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : AvailableMoveToActionsForMessagesResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvailableMoveToActionsForMessagesResult : FfiConverterRustBuffer<AvailableMoveToActionsForMessagesResult>{
    override fun read(buf: ByteBuffer): AvailableMoveToActionsForMessagesResult {
        return when(buf.getInt()) {
            1 -> AvailableMoveToActionsForMessagesResult.Ok(
                FfiConverterSequenceTypeMoveAction.read(buf),
                )
            2 -> AvailableMoveToActionsForMessagesResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AvailableMoveToActionsForMessagesResult) = when(value) {
        is AvailableMoveToActionsForMessagesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeMoveAction.allocationSize(value.v1)
            )
        }
        is AvailableMoveToActionsForMessagesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AvailableMoveToActionsForMessagesResult, buf: ByteBuffer) {
        when(value) {
            is AvailableMoveToActionsForMessagesResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeMoveAction.write(value.v1, buf)
                Unit
            }
            is AvailableMoveToActionsForMessagesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AvailableSnoozeActionsForConversationResult {
    
    data class Ok(
        val v1: SnoozeActions) : AvailableSnoozeActionsForConversationResult() {
        companion object
    }
    
    data class Error(
        val v1: SnoozeError) : AvailableSnoozeActionsForConversationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAvailableSnoozeActionsForConversationResult : FfiConverterRustBuffer<AvailableSnoozeActionsForConversationResult>{
    override fun read(buf: ByteBuffer): AvailableSnoozeActionsForConversationResult {
        return when(buf.getInt()) {
            1 -> AvailableSnoozeActionsForConversationResult.Ok(
                FfiConverterTypeSnoozeActions.read(buf),
                )
            2 -> AvailableSnoozeActionsForConversationResult.Error(
                FfiConverterTypeSnoozeError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AvailableSnoozeActionsForConversationResult) = when(value) {
        is AvailableSnoozeActionsForConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSnoozeActions.allocationSize(value.v1)
            )
        }
        is AvailableSnoozeActionsForConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSnoozeError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AvailableSnoozeActionsForConversationResult, buf: ByteBuffer) {
        when(value) {
            is AvailableSnoozeActionsForConversationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSnoozeActions.write(value.v1, buf)
                Unit
            }
            is AvailableSnoozeActionsForConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSnoozeError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class BackgroundExecutionStatus {
    
    object SkippedNoActiveContexts : BackgroundExecutionStatus()
    
    
    object Executed : BackgroundExecutionStatus()
    
    
    object AbortedInBackground : BackgroundExecutionStatus()
    
    
    object AbortedInForeground : BackgroundExecutionStatus()
    
    
    object TimedOut : BackgroundExecutionStatus()
    
    
    data class Failed(
        val v1: kotlin.String) : BackgroundExecutionStatus() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBackgroundExecutionStatus : FfiConverterRustBuffer<BackgroundExecutionStatus>{
    override fun read(buf: ByteBuffer): BackgroundExecutionStatus {
        return when(buf.getInt()) {
            1 -> BackgroundExecutionStatus.SkippedNoActiveContexts
            2 -> BackgroundExecutionStatus.Executed
            3 -> BackgroundExecutionStatus.AbortedInBackground
            4 -> BackgroundExecutionStatus.AbortedInForeground
            5 -> BackgroundExecutionStatus.TimedOut
            6 -> BackgroundExecutionStatus.Failed(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BackgroundExecutionStatus) = when(value) {
        is BackgroundExecutionStatus.SkippedNoActiveContexts -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackgroundExecutionStatus.Executed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackgroundExecutionStatus.AbortedInBackground -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackgroundExecutionStatus.AbortedInForeground -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackgroundExecutionStatus.TimedOut -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackgroundExecutionStatus.Failed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: BackgroundExecutionStatus, buf: ByteBuffer) {
        when(value) {
            is BackgroundExecutionStatus.SkippedNoActiveContexts -> {
                buf.putInt(1)
                Unit
            }
            is BackgroundExecutionStatus.Executed -> {
                buf.putInt(2)
                Unit
            }
            is BackgroundExecutionStatus.AbortedInBackground -> {
                buf.putInt(3)
                Unit
            }
            is BackgroundExecutionStatus.AbortedInForeground -> {
                buf.putInt(4)
                Unit
            }
            is BackgroundExecutionStatus.TimedOut -> {
                buf.putInt(5)
                Unit
            }
            is BackgroundExecutionStatus.Failed -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class BlackFridayWave {
    
    /**
     * 50% off
     */
    WAVE1,
    /**
     * 80% off
     */
    WAVE2;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeBlackFridayWave: FfiConverterRustBuffer<BlackFridayWave> {
    override fun read(buf: ByteBuffer) = try {
        BlackFridayWave.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BlackFridayWave) = 4UL

    override fun write(value: BlackFridayWave, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class BodyOutputResult {
    
    data class Ok(
        val v1: BodyOutput) : BodyOutputResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : BodyOutputResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBodyOutputResult : FfiConverterRustBuffer<BodyOutputResult>{
    override fun read(buf: ByteBuffer): BodyOutputResult {
        return when(buf.getInt()) {
            1 -> BodyOutputResult.Ok(
                FfiConverterTypeBodyOutput.read(buf),
                )
            2 -> BodyOutputResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BodyOutputResult) = when(value) {
        is BodyOutputResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBodyOutput.allocationSize(value.v1)
            )
        }
        is BodyOutputResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: BodyOutputResult, buf: ByteBuffer) {
        when(value) {
            is BodyOutputResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeBodyOutput.write(value.v1, buf)
                Unit
            }
            is BodyOutputResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class BulkMessageUnreadStatusResult {
    
    data class Ok(
        val v1: List<kotlin.Boolean>) : BulkMessageUnreadStatusResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : BulkMessageUnreadStatusResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBulkMessageUnreadStatusResult : FfiConverterRustBuffer<BulkMessageUnreadStatusResult>{
    override fun read(buf: ByteBuffer): BulkMessageUnreadStatusResult {
        return when(buf.getInt()) {
            1 -> BulkMessageUnreadStatusResult.Ok(
                FfiConverterSequenceBoolean.read(buf),
                )
            2 -> BulkMessageUnreadStatusResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BulkMessageUnreadStatusResult) = when(value) {
        is BulkMessageUnreadStatusResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceBoolean.allocationSize(value.v1)
            )
        }
        is BulkMessageUnreadStatusResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: BulkMessageUnreadStatusResult, buf: ByteBuffer) {
        when(value) {
            is BulkMessageUnreadStatusResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceBoolean.write(value.v1, buf)
                Unit
            }
            is BulkMessageUnreadStatusResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class CardType(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    CLEAR_TEXT(0u),
    /**
     * TODO: Document this variant.
     */
    ENCRYPTED(1u),
    /**
     * TODO: Document this variant.
     */
    SIGNED(2u),
    /**
     * TODO: Document this variant.
     */
    ENCRYPTED_AND_SIGNED(3u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeCardType: FfiConverterRustBuffer<CardType> {
    override fun read(buf: ByteBuffer) = try {
        CardType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: CardType) = 4UL

    override fun write(value: CardType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ChallengeLoaderGetResult {
    
    data class Ok(
        val v1: ChallengeLoaderResponse) : ChallengeLoaderGetResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : ChallengeLoaderGetResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeLoaderGetResult : FfiConverterRustBuffer<ChallengeLoaderGetResult>{
    override fun read(buf: ByteBuffer): ChallengeLoaderGetResult {
        return when(buf.getInt()) {
            1 -> ChallengeLoaderGetResult.Ok(
                FfiConverterTypeChallengeLoaderResponse.read(buf),
                )
            2 -> ChallengeLoaderGetResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ChallengeLoaderGetResult) = when(value) {
        is ChallengeLoaderGetResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeChallengeLoaderResponse.allocationSize(value.v1)
            )
        }
        is ChallengeLoaderGetResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ChallengeLoaderGetResult, buf: ByteBuffer) {
        when(value) {
            is ChallengeLoaderGetResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeChallengeLoaderResponse.write(value.v1, buf)
                Unit
            }
            is ChallengeLoaderGetResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ChallengeLoaderPostResult {
    
    data class Ok(
        val v1: ChallengeLoaderResponse) : ChallengeLoaderPostResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : ChallengeLoaderPostResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeLoaderPostResult : FfiConverterRustBuffer<ChallengeLoaderPostResult>{
    override fun read(buf: ByteBuffer): ChallengeLoaderPostResult {
        return when(buf.getInt()) {
            1 -> ChallengeLoaderPostResult.Ok(
                FfiConverterTypeChallengeLoaderResponse.read(buf),
                )
            2 -> ChallengeLoaderPostResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ChallengeLoaderPostResult) = when(value) {
        is ChallengeLoaderPostResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeChallengeLoaderResponse.allocationSize(value.v1)
            )
        }
        is ChallengeLoaderPostResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ChallengeLoaderPostResult, buf: ByteBuffer) {
        when(value) {
            is ChallengeLoaderPostResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeChallengeLoaderResponse.write(value.v1, buf)
                Unit
            }
            is ChallengeLoaderPostResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ChallengeLoaderPutResult {
    
    data class Ok(
        val v1: ChallengeLoaderResponse) : ChallengeLoaderPutResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : ChallengeLoaderPutResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeLoaderPutResult : FfiConverterRustBuffer<ChallengeLoaderPutResult>{
    override fun read(buf: ByteBuffer): ChallengeLoaderPutResult {
        return when(buf.getInt()) {
            1 -> ChallengeLoaderPutResult.Ok(
                FfiConverterTypeChallengeLoaderResponse.read(buf),
                )
            2 -> ChallengeLoaderPutResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ChallengeLoaderPutResult) = when(value) {
        is ChallengeLoaderPutResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeChallengeLoaderResponse.allocationSize(value.v1)
            )
        }
        is ChallengeLoaderPutResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ChallengeLoaderPutResult, buf: ByteBuffer) {
        when(value) {
            is ChallengeLoaderPutResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeChallengeLoaderResponse.write(value.v1, buf)
                Unit
            }
            is ChallengeLoaderPutResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * The response to a human verification challenge.
 */
sealed class ChallengeResponse {
    
    /**
     * The challenge was successfully completed.
     */
    data class Success(
        /**
         * The token to submit to the server.
         */
        val `token`: kotlin.String, 
        /**
         * The type of the token.
         */
        val `ttype`: kotlin.String) : ChallengeResponse() {
        companion object
    }
    
    /**
     * The challenge was not completed.
     */
    object Failure : ChallengeResponse()
    
    
    /**
     * The challenge was cancelled.
     */
    object Cancelled : ChallengeResponse()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChallengeResponse : FfiConverterRustBuffer<ChallengeResponse>{
    override fun read(buf: ByteBuffer): ChallengeResponse {
        return when(buf.getInt()) {
            1 -> ChallengeResponse.Success(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> ChallengeResponse.Failure
            3 -> ChallengeResponse.Cancelled
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ChallengeResponse) = when(value) {
        is ChallengeResponse.Success -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`token`)
                + FfiConverterString.allocationSize(value.`ttype`)
            )
        }
        is ChallengeResponse.Failure -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ChallengeResponse.Cancelled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ChallengeResponse, buf: ByteBuffer) {
        when(value) {
            is ChallengeResponse.Success -> {
                buf.putInt(1)
                FfiConverterString.write(value.`token`, buf)
                FfiConverterString.write(value.`ttype`, buf)
                Unit
            }
            is ChallengeResponse.Failure -> {
                buf.putInt(2)
                Unit
            }
            is ChallengeResponse.Cancelled -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Representation of Client type
 */

enum class ClientType {
    
    EMAIL;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeClientType: FfiConverterRustBuffer<ClientType> {
    override fun read(buf: ByteBuffer) = try {
        ClientType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ClientType) = 4UL

    override fun write(value: ClientType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ComposerDirection(val value: kotlin.UByte) {
    
    LEFT_TO_RIGHT(0u),
    RIGHT_TO_LEFT(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeComposerDirection: FfiConverterRustBuffer<ComposerDirection> {
    override fun read(buf: ByteBuffer) = try {
        ComposerDirection.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ComposerDirection) = 4UL

    override fun write(value: ComposerDirection, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ComposerMode(val value: kotlin.UByte) {
    
    NORMAL(0u),
    MAXIMIZED(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeComposerMode: FfiConverterRustBuffer<ComposerMode> {
    override fun read(buf: ByteBuffer) = try {
        ComposerMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ComposerMode) = 4UL

    override fun write(value: ComposerMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ComposerRecipient {
    
    data class Single(
        val v1: ComposerRecipientSingle) : ComposerRecipient() {
        companion object
    }
    
    data class Group(
        val v1: ComposerRecipientGroup) : ComposerRecipient() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipient : FfiConverterRustBuffer<ComposerRecipient>{
    override fun read(buf: ByteBuffer): ComposerRecipient {
        return when(buf.getInt()) {
            1 -> ComposerRecipient.Single(
                FfiConverterTypeComposerRecipientSingle.read(buf),
                )
            2 -> ComposerRecipient.Group(
                FfiConverterTypeComposerRecipientGroup.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ComposerRecipient) = when(value) {
        is ComposerRecipient.Single -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeComposerRecipientSingle.allocationSize(value.v1)
            )
        }
        is ComposerRecipient.Group -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeComposerRecipientGroup.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ComposerRecipient, buf: ByteBuffer) {
        when(value) {
            is ComposerRecipient.Single -> {
                buf.putInt(1)
                FfiConverterTypeComposerRecipientSingle.write(value.v1, buf)
                Unit
            }
            is ComposerRecipient.Group -> {
                buf.putInt(2)
                FfiConverterTypeComposerRecipientGroup.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Validation state of this recipient
 */
sealed class ComposerRecipientValidState {
    
    object Valid : ComposerRecipientValidState()
    
    
    data class Invalid(
        val v1: RecipientInvalidReason) : ComposerRecipientValidState() {
        companion object
    }
    
    object Validating : ComposerRecipientValidState()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeComposerRecipientValidState : FfiConverterRustBuffer<ComposerRecipientValidState>{
    override fun read(buf: ByteBuffer): ComposerRecipientValidState {
        return when(buf.getInt()) {
            1 -> ComposerRecipientValidState.Valid
            2 -> ComposerRecipientValidState.Invalid(
                FfiConverterTypeRecipientInvalidReason.read(buf),
                )
            3 -> ComposerRecipientValidState.Validating
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ComposerRecipientValidState) = when(value) {
        is ComposerRecipientValidState.Valid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ComposerRecipientValidState.Invalid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRecipientInvalidReason.allocationSize(value.v1)
            )
        }
        is ComposerRecipientValidState.Validating -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ComposerRecipientValidState, buf: ByteBuffer) {
        when(value) {
            is ComposerRecipientValidState.Valid -> {
                buf.putInt(1)
                Unit
            }
            is ComposerRecipientValidState.Invalid -> {
                buf.putInt(2)
                FfiConverterTypeRecipientInvalidReason.write(value.v1, buf)
                Unit
            }
            is ComposerRecipientValidState.Validating -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ConnectionStatus {
    
    /**
     * The application is online,
     */
    ONLINE,
    /**
     * The application is offline,
     */
    OFFLINE,
    /**
     * The application is online but the server is unreachable.
     */
    SERVER_UNREACHABLE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeConnectionStatus: FfiConverterRustBuffer<ConnectionStatus> {
    override fun read(buf: ByteBuffer) = try {
        ConnectionStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ConnectionStatus) = 4UL

    override fun write(value: ConnectionStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ContactDate {
    
    data class String(
        val v1: kotlin.String) : ContactDate() {
        companion object
    }
    
    data class Date(
        val v1: PartialDate) : ContactDate() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactDate : FfiConverterRustBuffer<ContactDate>{
    override fun read(buf: ByteBuffer): ContactDate {
        return when(buf.getInt()) {
            1 -> ContactDate.String(
                FfiConverterString.read(buf),
                )
            2 -> ContactDate.Date(
                FfiConverterTypePartialDate.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactDate) = when(value) {
        is ContactDate.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is ContactDate.Date -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePartialDate.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactDate, buf: ByteBuffer) {
        when(value) {
            is ContactDate.String -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ContactDate.Date -> {
                buf.putInt(2)
                FfiConverterTypePartialDate.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ContactField {
    
    data class Anniversary(
        val v1: ContactDate) : ContactField() {
        companion object
    }
    
    data class Birthday(
        val v1: ContactDate) : ContactField() {
        companion object
    }
    
    data class Gender(
        val v1: GenderKind) : ContactField() {
        companion object
    }
    
    data class Addresses(
        val v1: List<ContactDetailAddress>) : ContactField() {
        companion object
    }
    
    data class Emails(
        val v1: List<ContactDetailsEmail>) : ContactField() {
        companion object
    }
    
    data class Languages(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Logos(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Members(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Notes(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Organizations(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Telephones(
        val v1: List<ContactDetailsTelephones>) : ContactField() {
        companion object
    }
    
    data class Photos(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Roles(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class TimeZones(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Titles(
        val v1: List<kotlin.String>) : ContactField() {
        companion object
    }
    
    data class Urls(
        val v1: List<VCardUrl>) : ContactField() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactField : FfiConverterRustBuffer<ContactField>{
    override fun read(buf: ByteBuffer): ContactField {
        return when(buf.getInt()) {
            1 -> ContactField.Anniversary(
                FfiConverterTypeContactDate.read(buf),
                )
            2 -> ContactField.Birthday(
                FfiConverterTypeContactDate.read(buf),
                )
            3 -> ContactField.Gender(
                FfiConverterTypeGenderKind.read(buf),
                )
            4 -> ContactField.Addresses(
                FfiConverterSequenceTypeContactDetailAddress.read(buf),
                )
            5 -> ContactField.Emails(
                FfiConverterSequenceTypeContactDetailsEmail.read(buf),
                )
            6 -> ContactField.Languages(
                FfiConverterSequenceString.read(buf),
                )
            7 -> ContactField.Logos(
                FfiConverterSequenceString.read(buf),
                )
            8 -> ContactField.Members(
                FfiConverterSequenceString.read(buf),
                )
            9 -> ContactField.Notes(
                FfiConverterSequenceString.read(buf),
                )
            10 -> ContactField.Organizations(
                FfiConverterSequenceString.read(buf),
                )
            11 -> ContactField.Telephones(
                FfiConverterSequenceTypeContactDetailsTelephones.read(buf),
                )
            12 -> ContactField.Photos(
                FfiConverterSequenceString.read(buf),
                )
            13 -> ContactField.Roles(
                FfiConverterSequenceString.read(buf),
                )
            14 -> ContactField.TimeZones(
                FfiConverterSequenceString.read(buf),
                )
            15 -> ContactField.Titles(
                FfiConverterSequenceString.read(buf),
                )
            16 -> ContactField.Urls(
                FfiConverterSequenceTypeVCardUrl.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactField) = when(value) {
        is ContactField.Anniversary -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactDate.allocationSize(value.v1)
            )
        }
        is ContactField.Birthday -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactDate.allocationSize(value.v1)
            )
        }
        is ContactField.Gender -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeGenderKind.allocationSize(value.v1)
            )
        }
        is ContactField.Addresses -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeContactDetailAddress.allocationSize(value.v1)
            )
        }
        is ContactField.Emails -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeContactDetailsEmail.allocationSize(value.v1)
            )
        }
        is ContactField.Languages -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Logos -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Members -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Notes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Organizations -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Telephones -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeContactDetailsTelephones.allocationSize(value.v1)
            )
        }
        is ContactField.Photos -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Roles -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.TimeZones -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Titles -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ContactField.Urls -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeVCardUrl.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactField, buf: ByteBuffer) {
        when(value) {
            is ContactField.Anniversary -> {
                buf.putInt(1)
                FfiConverterTypeContactDate.write(value.v1, buf)
                Unit
            }
            is ContactField.Birthday -> {
                buf.putInt(2)
                FfiConverterTypeContactDate.write(value.v1, buf)
                Unit
            }
            is ContactField.Gender -> {
                buf.putInt(3)
                FfiConverterTypeGenderKind.write(value.v1, buf)
                Unit
            }
            is ContactField.Addresses -> {
                buf.putInt(4)
                FfiConverterSequenceTypeContactDetailAddress.write(value.v1, buf)
                Unit
            }
            is ContactField.Emails -> {
                buf.putInt(5)
                FfiConverterSequenceTypeContactDetailsEmail.write(value.v1, buf)
                Unit
            }
            is ContactField.Languages -> {
                buf.putInt(6)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Logos -> {
                buf.putInt(7)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Members -> {
                buf.putInt(8)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Notes -> {
                buf.putInt(9)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Organizations -> {
                buf.putInt(10)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Telephones -> {
                buf.putInt(11)
                FfiConverterSequenceTypeContactDetailsTelephones.write(value.v1, buf)
                Unit
            }
            is ContactField.Photos -> {
                buf.putInt(12)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Roles -> {
                buf.putInt(13)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.TimeZones -> {
                buf.putInt(14)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Titles -> {
                buf.putInt(15)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ContactField.Urls -> {
                buf.putInt(16)
                FfiConverterSequenceTypeVCardUrl.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ContactGroupByIdResult {
    
    data class Ok(
        val v1: ContactGroupItem) : ContactGroupByIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ContactGroupByIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactGroupByIdResult : FfiConverterRustBuffer<ContactGroupByIdResult>{
    override fun read(buf: ByteBuffer): ContactGroupByIdResult {
        return when(buf.getInt()) {
            1 -> ContactGroupByIdResult.Ok(
                FfiConverterTypeContactGroupItem.read(buf),
                )
            2 -> ContactGroupByIdResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactGroupByIdResult) = when(value) {
        is ContactGroupByIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactGroupItem.allocationSize(value.v1)
            )
        }
        is ContactGroupByIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactGroupByIdResult, buf: ByteBuffer) {
        when(value) {
            is ContactGroupByIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeContactGroupItem.write(value.v1, buf)
                Unit
            }
            is ContactGroupByIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * List of contacts is composed of contacts and groups.
 * This enum is used to represent the either one.
 */
sealed class ContactItemType {
    
    data class Contact(
        val v1: ContactItem) : ContactItemType() {
        companion object
    }
    
    data class Group(
        val v1: ContactGroupItem) : ContactItemType() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactItemType : FfiConverterRustBuffer<ContactItemType>{
    override fun read(buf: ByteBuffer): ContactItemType {
        return when(buf.getInt()) {
            1 -> ContactItemType.Contact(
                FfiConverterTypeContactItem.read(buf),
                )
            2 -> ContactItemType.Group(
                FfiConverterTypeContactGroupItem.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactItemType) = when(value) {
        is ContactItemType.Contact -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactItem.allocationSize(value.v1)
            )
        }
        is ContactItemType.Group -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactGroupItem.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactItemType, buf: ByteBuffer) {
        when(value) {
            is ContactItemType.Contact -> {
                buf.putInt(1)
                FfiConverterTypeContactItem.write(value.v1, buf)
                Unit
            }
            is ContactItemType.Group -> {
                buf.putInt(2)
                FfiConverterTypeContactGroupItem.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ContactListResult {
    
    data class Ok(
        val v1: List<GroupedContacts>) : ContactListResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ContactListResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactListResult : FfiConverterRustBuffer<ContactListResult>{
    override fun read(buf: ByteBuffer): ContactListResult {
        return when(buf.getInt()) {
            1 -> ContactListResult.Ok(
                FfiConverterSequenceTypeGroupedContacts.read(buf),
                )
            2 -> ContactListResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactListResult) = when(value) {
        is ContactListResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeGroupedContacts.allocationSize(value.v1)
            )
        }
        is ContactListResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactListResult, buf: ByteBuffer) {
        when(value) {
            is ContactListResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeGroupedContacts.write(value.v1, buf)
                Unit
            }
            is ContactListResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class ContactSendingPreferences(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    CUSTOM(0u),
    /**
     * TODO: Document this variant.
     */
    DEFAULT(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeContactSendingPreferences: FfiConverterRustBuffer<ContactSendingPreferences> {
    override fun read(buf: ByteBuffer) = try {
        ContactSendingPreferences.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ContactSendingPreferences) = 4UL

    override fun write(value: ContactSendingPreferences, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Kind of email suggestion
 * Note, variants of this enum are flat - that is, if one contact has assigned two emails,
 * it would be represented by two instances of [`ContactSuggestion`].

 */
sealed class ContactSuggestionKind {
    
    /**
     * Proton contact, stored in the local cache and shared between user devices
     */
    data class ContactItem(
        val v1: ContactEmailItem) : ContactSuggestionKind() {
        companion object
    }
    
    /**
     * A device, native contact, stored only locally on the current device.
     */
    data class DeviceContact(
        val v1: DeviceContactSuggestion) : ContactSuggestionKind() {
        companion object
    }
    
    /**
     * Proton contact group, that consists only other proton contacts, and never device contact.
     */
    data class ContactGroup(
        val v1: List<ContactEmailItem>) : ContactSuggestionKind() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactSuggestionKind : FfiConverterRustBuffer<ContactSuggestionKind>{
    override fun read(buf: ByteBuffer): ContactSuggestionKind {
        return when(buf.getInt()) {
            1 -> ContactSuggestionKind.ContactItem(
                FfiConverterTypeContactEmailItem.read(buf),
                )
            2 -> ContactSuggestionKind.DeviceContact(
                FfiConverterTypeDeviceContactSuggestion.read(buf),
                )
            3 -> ContactSuggestionKind.ContactGroup(
                FfiConverterSequenceTypeContactEmailItem.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactSuggestionKind) = when(value) {
        is ContactSuggestionKind.ContactItem -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactEmailItem.allocationSize(value.v1)
            )
        }
        is ContactSuggestionKind.DeviceContact -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDeviceContactSuggestion.allocationSize(value.v1)
            )
        }
        is ContactSuggestionKind.ContactGroup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeContactEmailItem.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactSuggestionKind, buf: ByteBuffer) {
        when(value) {
            is ContactSuggestionKind.ContactItem -> {
                buf.putInt(1)
                FfiConverterTypeContactEmailItem.write(value.v1, buf)
                Unit
            }
            is ContactSuggestionKind.DeviceContact -> {
                buf.putInt(2)
                FfiConverterTypeDeviceContactSuggestion.write(value.v1, buf)
                Unit
            }
            is ContactSuggestionKind.ContactGroup -> {
                buf.putInt(3)
                FfiConverterSequenceTypeContactEmailItem.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ContactSuggestionsResult: Disposable  {
    
    data class Ok(
        val v1: ContactSuggestions) : ContactSuggestionsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ContactSuggestionsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ContactSuggestionsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is ContactSuggestionsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContactSuggestionsResult : FfiConverterRustBuffer<ContactSuggestionsResult>{
    override fun read(buf: ByteBuffer): ContactSuggestionsResult {
        return when(buf.getInt()) {
            1 -> ContactSuggestionsResult.Ok(
                FfiConverterTypeContactSuggestions.read(buf),
                )
            2 -> ContactSuggestionsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ContactSuggestionsResult) = when(value) {
        is ContactSuggestionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactSuggestions.allocationSize(value.v1)
            )
        }
        is ContactSuggestionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ContactSuggestionsResult, buf: ByteBuffer) {
        when(value) {
            is ContactSuggestionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeContactSuggestions.write(value.v1, buf)
                Unit
            }
            is ContactSuggestionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Enumeration grouping all possible actions for Conversation Toolbar
 * Note: ConversationAction = ListAction, so this maps all list action variants
 */
sealed class ConversationAction {
    
    object LabelAs : ConversationAction()
    
    
    object MarkRead : ConversationAction()
    
    
    object MarkUnread : ConversationAction()
    
    
    object More : ConversationAction()
    
    
    object MoveTo : ConversationAction()
    
    
    data class MoveToSystemFolder(
        val v1: MovableSystemFolderAction) : ConversationAction() {
        companion object
    }
    
    data class NotSpam(
        val v1: MovableSystemFolderAction) : ConversationAction() {
        companion object
    }
    
    object PermanentDelete : ConversationAction()
    
    
    object Star : ConversationAction()
    
    
    object Unstar : ConversationAction()
    
    
    object Snooze : ConversationAction()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationAction : FfiConverterRustBuffer<ConversationAction>{
    override fun read(buf: ByteBuffer): ConversationAction {
        return when(buf.getInt()) {
            1 -> ConversationAction.LabelAs
            2 -> ConversationAction.MarkRead
            3 -> ConversationAction.MarkUnread
            4 -> ConversationAction.More
            5 -> ConversationAction.MoveTo
            6 -> ConversationAction.MoveToSystemFolder(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            7 -> ConversationAction.NotSpam(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            8 -> ConversationAction.PermanentDelete
            9 -> ConversationAction.Star
            10 -> ConversationAction.Unstar
            11 -> ConversationAction.Snooze
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationAction) = when(value) {
        is ConversationAction.LabelAs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.MarkRead -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.MarkUnread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.More -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.MoveTo -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.MoveToSystemFolder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is ConversationAction.NotSpam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is ConversationAction.PermanentDelete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.Star -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.Unstar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationAction.Snooze -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ConversationAction, buf: ByteBuffer) {
        when(value) {
            is ConversationAction.LabelAs -> {
                buf.putInt(1)
                Unit
            }
            is ConversationAction.MarkRead -> {
                buf.putInt(2)
                Unit
            }
            is ConversationAction.MarkUnread -> {
                buf.putInt(3)
                Unit
            }
            is ConversationAction.More -> {
                buf.putInt(4)
                Unit
            }
            is ConversationAction.MoveTo -> {
                buf.putInt(5)
                Unit
            }
            is ConversationAction.MoveToSystemFolder -> {
                buf.putInt(6)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is ConversationAction.NotSpam -> {
                buf.putInt(7)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is ConversationAction.PermanentDelete -> {
                buf.putInt(8)
                Unit
            }
            is ConversationAction.Star -> {
                buf.putInt(9)
                Unit
            }
            is ConversationAction.Unstar -> {
                buf.putInt(10)
                Unit
            }
            is ConversationAction.Snooze -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationResult {
    
    data class Ok(
        val v1: ConversationAndMessages?) : ConversationResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ConversationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationResult : FfiConverterRustBuffer<ConversationResult>{
    override fun read(buf: ByteBuffer): ConversationResult {
        return when(buf.getInt()) {
            1 -> ConversationResult.Ok(
                FfiConverterOptionalTypeConversationAndMessages.read(buf),
                )
            2 -> ConversationResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationResult) = when(value) {
        is ConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeConversationAndMessages.allocationSize(value.v1)
            )
        }
        is ConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationResult, buf: ByteBuffer) {
        when(value) {
            is ConversationResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeConversationAndMessages.write(value.v1, buf)
                Unit
            }
            is ConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerChangeFilterResult {
    
    object Ok : ConversationScrollerChangeFilterResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerChangeFilterResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerChangeFilterResult : FfiConverterRustBuffer<ConversationScrollerChangeFilterResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerChangeFilterResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerChangeFilterResult.Ok
            2 -> ConversationScrollerChangeFilterResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerChangeFilterResult) = when(value) {
        is ConversationScrollerChangeFilterResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerChangeFilterResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerChangeFilterResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerChangeFilterResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerChangeFilterResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerChangeIncludeResult {
    
    object Ok : ConversationScrollerChangeIncludeResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerChangeIncludeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerChangeIncludeResult : FfiConverterRustBuffer<ConversationScrollerChangeIncludeResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerChangeIncludeResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerChangeIncludeResult.Ok
            2 -> ConversationScrollerChangeIncludeResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerChangeIncludeResult) = when(value) {
        is ConversationScrollerChangeIncludeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerChangeIncludeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerChangeIncludeResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerChangeIncludeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerChangeIncludeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerCursorResult: Disposable  {
    
    data class Ok(
        val v1: MailConversationCursor) : ConversationScrollerCursorResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerCursorResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ConversationScrollerCursorResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is ConversationScrollerCursorResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerCursorResult : FfiConverterRustBuffer<ConversationScrollerCursorResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerCursorResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerCursorResult.Ok(
                FfiConverterTypeMailConversationCursor.read(buf),
                )
            2 -> ConversationScrollerCursorResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerCursorResult) = when(value) {
        is ConversationScrollerCursorResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailConversationCursor.allocationSize(value.v1)
            )
        }
        is ConversationScrollerCursorResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerCursorResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerCursorResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailConversationCursor.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerCursorResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerFetchMoreResult {
    
    object Ok : ConversationScrollerFetchMoreResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerFetchMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerFetchMoreResult : FfiConverterRustBuffer<ConversationScrollerFetchMoreResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerFetchMoreResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerFetchMoreResult.Ok
            2 -> ConversationScrollerFetchMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerFetchMoreResult) = when(value) {
        is ConversationScrollerFetchMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerFetchMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerFetchMoreResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerFetchMoreResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerFetchMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerFetchNewResult {
    
    object Ok : ConversationScrollerFetchNewResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerFetchNewResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerFetchNewResult : FfiConverterRustBuffer<ConversationScrollerFetchNewResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerFetchNewResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerFetchNewResult.Ok
            2 -> ConversationScrollerFetchNewResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerFetchNewResult) = when(value) {
        is ConversationScrollerFetchNewResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerFetchNewResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerFetchNewResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerFetchNewResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerFetchNewResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerForceRefreshResult {
    
    object Ok : ConversationScrollerForceRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerForceRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerForceRefreshResult : FfiConverterRustBuffer<ConversationScrollerForceRefreshResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerForceRefreshResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerForceRefreshResult.Ok
            2 -> ConversationScrollerForceRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerForceRefreshResult) = when(value) {
        is ConversationScrollerForceRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerForceRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerForceRefreshResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerForceRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerForceRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerGetItemsResult {
    
    object Ok : ConversationScrollerGetItemsResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerGetItemsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerGetItemsResult : FfiConverterRustBuffer<ConversationScrollerGetItemsResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerGetItemsResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerGetItemsResult.Ok
            2 -> ConversationScrollerGetItemsResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerGetItemsResult) = when(value) {
        is ConversationScrollerGetItemsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerGetItemsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerGetItemsResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerGetItemsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerGetItemsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerHasMoreResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : ConversationScrollerHasMoreResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerHasMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerHasMoreResult : FfiConverterRustBuffer<ConversationScrollerHasMoreResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerHasMoreResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerHasMoreResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> ConversationScrollerHasMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerHasMoreResult) = when(value) {
        is ConversationScrollerHasMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is ConversationScrollerHasMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerHasMoreResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerHasMoreResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerHasMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerListUpdate {
    
    /**
     * No update has occurred. It will be returned only for client-side requests.
     */
    data class None(
        val `scrollerId`: kotlin.String) : ConversationScrollerListUpdate() {
        companion object
    }
    
    /**
     * A new page of conversations needs to be appended to the end of the list.
     */
    data class Append(
        val `scrollerId`: kotlin.String, 
        val `items`: List<Conversation>) : ConversationScrollerListUpdate() {
        companion object
    }
    
    /**
     * A page of conversations needs to be replaced at the given index
     * replacing everything forwards with the new items.
     * Note: This replace includes the index while replacing
     *
     * # Examples
     *
     * [0, 1, 2, 3] -> ReplaceFrom { idx: 2, items: [5, 6, 7] } -> [0, 1, 5, 6, 7]
     * [0, 1, 2, 3, 4, 8, 9] -> ReplaceFrom { idx: 2, items: [5, 6, 7] } -> [0, 1, 5, 6, 7]
     * [0, 1, 2, 3] -> ReplaceFrom { idx: 0, items: [5, 6, 7] } -> [5, 6, 7]
     */
    data class ReplaceFrom(
        val `scrollerId`: kotlin.String, 
        val `idx`: kotlin.ULong, 
        val `items`: List<Conversation>) : ConversationScrollerListUpdate() {
        companion object
    }
    
    /**
     * A page of conversations needs to be replaced before the given index
     * replacing everything before the index with the new items.
     * Note: This replace excludes the index while replacing
     *
     * # Examples
     *
     * [0, 1, 2, 3] -> ReplaceBefore { idx: 2, items: [5, 6, 7] } -> [5, 6, 7, 3]
     * [0, 1, 2, 3, 4, 8, 9] -> ReplaceBefore { idx: 2, items: [5, 6, 7] } -> [5, 6, 7, 3, 4, 8, 9]
     * [0, 1, 2, 3] -> ReplaceBefore { idx: 0, items: [5, 6, 7] } -> [5, 6, 7, 0, 1, 2, 3]
     */
    data class ReplaceBefore(
        val `scrollerId`: kotlin.String, 
        val `idx`: kotlin.ULong, 
        val `items`: List<Conversation>) : ConversationScrollerListUpdate() {
        companion object
    }
    
    /**
     * A page of conversations needs to be replaced at the given index
     * replacing everything between the given index and the end with the new items.
     *
     * # Examples
     *
     * [0, 1, 2, 3] -> ReplaceRange { from: 1, to: 3, items: [5, 6, 7] } -> [0, 5, 6, 7]
     * [0, 1, 2, 3, 4, 8, 9] -> ReplaceRange { from: 1, to: 3, items: [5, 6, 7] } -> [0, 5, 6, 7, 4, 8, 9]
     * [0, 1, 2, 3] -> ReplaceRange { from: 0, to: 2, items: [5, 6, 7] } -> [5, 6, 7, 3]
     * [0, 1, 2, 3] -> ReplaceRange { from: 1, to: 1, items: [5, 6, 7] } -> [0, 5, 6, 7, 1, 2, 3]
     *
     * # Integration
     *
     * Rust: collected_items.splice(from..to, items)
     * Swift: collected_items.replaceSubrange(from..<to, with: items)
     * Kotlin: collected_items.subList(from, to).clear(); collected_items.addAll(from, items)
     */
    data class ReplaceRange(
        val `scrollerId`: kotlin.String, 
        val `from`: kotlin.ULong, 
        val `to`: kotlin.ULong, 
        val `items`: List<Conversation>) : ConversationScrollerListUpdate() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerListUpdate : FfiConverterRustBuffer<ConversationScrollerListUpdate>{
    override fun read(buf: ByteBuffer): ConversationScrollerListUpdate {
        return when(buf.getInt()) {
            1 -> ConversationScrollerListUpdate.None(
                FfiConverterString.read(buf),
                )
            2 -> ConversationScrollerListUpdate.Append(
                FfiConverterString.read(buf),
                FfiConverterSequenceTypeConversation.read(buf),
                )
            3 -> ConversationScrollerListUpdate.ReplaceFrom(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeConversation.read(buf),
                )
            4 -> ConversationScrollerListUpdate.ReplaceBefore(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeConversation.read(buf),
                )
            5 -> ConversationScrollerListUpdate.ReplaceRange(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeConversation.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerListUpdate) = when(value) {
        is ConversationScrollerListUpdate.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
            )
        }
        is ConversationScrollerListUpdate.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterSequenceTypeConversation.allocationSize(value.`items`)
            )
        }
        is ConversationScrollerListUpdate.ReplaceFrom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`idx`)
                + FfiConverterSequenceTypeConversation.allocationSize(value.`items`)
            )
        }
        is ConversationScrollerListUpdate.ReplaceBefore -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`idx`)
                + FfiConverterSequenceTypeConversation.allocationSize(value.`items`)
            )
        }
        is ConversationScrollerListUpdate.ReplaceRange -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`from`)
                + FfiConverterULong.allocationSize(value.`to`)
                + FfiConverterSequenceTypeConversation.allocationSize(value.`items`)
            )
        }
    }

    override fun write(value: ConversationScrollerListUpdate, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerListUpdate.None -> {
                buf.putInt(1)
                FfiConverterString.write(value.`scrollerId`, buf)
                Unit
            }
            is ConversationScrollerListUpdate.Append -> {
                buf.putInt(2)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterSequenceTypeConversation.write(value.`items`, buf)
                Unit
            }
            is ConversationScrollerListUpdate.ReplaceFrom -> {
                buf.putInt(3)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`idx`, buf)
                FfiConverterSequenceTypeConversation.write(value.`items`, buf)
                Unit
            }
            is ConversationScrollerListUpdate.ReplaceBefore -> {
                buf.putInt(4)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`idx`, buf)
                FfiConverterSequenceTypeConversation.write(value.`items`, buf)
                Unit
            }
            is ConversationScrollerListUpdate.ReplaceRange -> {
                buf.putInt(5)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`from`, buf)
                FfiConverterULong.write(value.`to`, buf)
                FfiConverterSequenceTypeConversation.write(value.`items`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerRefreshResult {
    
    object Ok : ConversationScrollerRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerRefreshResult : FfiConverterRustBuffer<ConversationScrollerRefreshResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerRefreshResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerRefreshResult.Ok
            2 -> ConversationScrollerRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerRefreshResult) = when(value) {
        is ConversationScrollerRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ConversationScrollerRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerRefreshResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is ConversationScrollerRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ConversationScrollerStatusUpdate {
    
    FETCH_NEW_START,
    FETCH_NEW_END;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerStatusUpdate: FfiConverterRustBuffer<ConversationScrollerStatusUpdate> {
    override fun read(buf: ByteBuffer) = try {
        ConversationScrollerStatusUpdate.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ConversationScrollerStatusUpdate) = 4UL

    override fun write(value: ConversationScrollerStatusUpdate, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ConversationScrollerSupportsIncludeFilterResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : ConversationScrollerSupportsIncludeFilterResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerSupportsIncludeFilterResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerSupportsIncludeFilterResult : FfiConverterRustBuffer<ConversationScrollerSupportsIncludeFilterResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerSupportsIncludeFilterResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerSupportsIncludeFilterResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> ConversationScrollerSupportsIncludeFilterResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerSupportsIncludeFilterResult) = when(value) {
        is ConversationScrollerSupportsIncludeFilterResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is ConversationScrollerSupportsIncludeFilterResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerSupportsIncludeFilterResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerSupportsIncludeFilterResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerSupportsIncludeFilterResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerTotalResult {
    
    data class Ok(
        val v1: kotlin.ULong) : ConversationScrollerTotalResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : ConversationScrollerTotalResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerTotalResult : FfiConverterRustBuffer<ConversationScrollerTotalResult>{
    override fun read(buf: ByteBuffer): ConversationScrollerTotalResult {
        return when(buf.getInt()) {
            1 -> ConversationScrollerTotalResult.Ok(
                FfiConverterULong.read(buf),
                )
            2 -> ConversationScrollerTotalResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerTotalResult) = when(value) {
        is ConversationScrollerTotalResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is ConversationScrollerTotalResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConversationScrollerTotalResult, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerTotalResult.Ok -> {
                buf.putInt(1)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerTotalResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ConversationScrollerUpdate {
    
    data class List(
        val v1: ConversationScrollerListUpdate) : ConversationScrollerUpdate() {
        companion object
    }
    
    data class Status(
        val v1: ConversationScrollerStatusUpdate) : ConversationScrollerUpdate() {
        companion object
    }
    
    data class Error(
        val `error`: MailScrollerError) : ConversationScrollerUpdate() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversationScrollerUpdate : FfiConverterRustBuffer<ConversationScrollerUpdate>{
    override fun read(buf: ByteBuffer): ConversationScrollerUpdate {
        return when(buf.getInt()) {
            1 -> ConversationScrollerUpdate.List(
                FfiConverterTypeConversationScrollerListUpdate.read(buf),
                )
            2 -> ConversationScrollerUpdate.Status(
                FfiConverterTypeConversationScrollerStatusUpdate.read(buf),
                )
            3 -> ConversationScrollerUpdate.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConversationScrollerUpdate) = when(value) {
        is ConversationScrollerUpdate.List -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConversationScrollerListUpdate.allocationSize(value.v1)
            )
        }
        is ConversationScrollerUpdate.Status -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConversationScrollerStatusUpdate.allocationSize(value.v1)
            )
        }
        is ConversationScrollerUpdate.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: ConversationScrollerUpdate, buf: ByteBuffer) {
        when(value) {
            is ConversationScrollerUpdate.List -> {
                buf.putInt(1)
                FfiConverterTypeConversationScrollerListUpdate.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerUpdate.Status -> {
                buf.putInt(2)
                FfiConverterTypeConversationScrollerStatusUpdate.write(value.v1, buf)
                Unit
            }
            is ConversationScrollerUpdate.Error -> {
                buf.putInt(3)
                FfiConverterTypeMailScrollerError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CreateMailSessionResult: Disposable  {
    
    data class Ok(
        val v1: MailSession) : CreateMailSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : CreateMailSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is CreateMailSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CreateMailSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCreateMailSessionResult : FfiConverterRustBuffer<CreateMailSessionResult>{
    override fun read(buf: ByteBuffer): CreateMailSessionResult {
        return when(buf.getInt()) {
            1 -> CreateMailSessionResult.Ok(
                FfiConverterTypeMailSession.read(buf),
                )
            2 -> CreateMailSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CreateMailSessionResult) = when(value) {
        is CreateMailSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailSession.allocationSize(value.v1)
            )
        }
        is CreateMailSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CreateMailSessionResult, buf: ByteBuffer) {
        when(value) {
            is CreateMailSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailSession.write(value.v1, buf)
                Unit
            }
            is CreateMailSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CustomSettingsMobileSignatureResult {
    
    data class Ok(
        val v1: MobileSignature) : CustomSettingsMobileSignatureResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : CustomSettingsMobileSignatureResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettingsMobileSignatureResult : FfiConverterRustBuffer<CustomSettingsMobileSignatureResult>{
    override fun read(buf: ByteBuffer): CustomSettingsMobileSignatureResult {
        return when(buf.getInt()) {
            1 -> CustomSettingsMobileSignatureResult.Ok(
                FfiConverterTypeMobileSignature.read(buf),
                )
            2 -> CustomSettingsMobileSignatureResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CustomSettingsMobileSignatureResult) = when(value) {
        is CustomSettingsMobileSignatureResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMobileSignature.allocationSize(value.v1)
            )
        }
        is CustomSettingsMobileSignatureResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CustomSettingsMobileSignatureResult, buf: ByteBuffer) {
        when(value) {
            is CustomSettingsMobileSignatureResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMobileSignature.write(value.v1, buf)
                Unit
            }
            is CustomSettingsMobileSignatureResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CustomSettingsSetMobileSignatureEnabledResult {
    
    object Ok : CustomSettingsSetMobileSignatureEnabledResult()
    
    
    data class Error(
        val v1: ProtonError) : CustomSettingsSetMobileSignatureEnabledResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettingsSetMobileSignatureEnabledResult : FfiConverterRustBuffer<CustomSettingsSetMobileSignatureEnabledResult>{
    override fun read(buf: ByteBuffer): CustomSettingsSetMobileSignatureEnabledResult {
        return when(buf.getInt()) {
            1 -> CustomSettingsSetMobileSignatureEnabledResult.Ok
            2 -> CustomSettingsSetMobileSignatureEnabledResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CustomSettingsSetMobileSignatureEnabledResult) = when(value) {
        is CustomSettingsSetMobileSignatureEnabledResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CustomSettingsSetMobileSignatureEnabledResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CustomSettingsSetMobileSignatureEnabledResult, buf: ByteBuffer) {
        when(value) {
            is CustomSettingsSetMobileSignatureEnabledResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is CustomSettingsSetMobileSignatureEnabledResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CustomSettingsSetMobileSignatureResult {
    
    object Ok : CustomSettingsSetMobileSignatureResult()
    
    
    data class Error(
        val v1: ProtonError) : CustomSettingsSetMobileSignatureResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettingsSetMobileSignatureResult : FfiConverterRustBuffer<CustomSettingsSetMobileSignatureResult>{
    override fun read(buf: ByteBuffer): CustomSettingsSetMobileSignatureResult {
        return when(buf.getInt()) {
            1 -> CustomSettingsSetMobileSignatureResult.Ok
            2 -> CustomSettingsSetMobileSignatureResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CustomSettingsSetMobileSignatureResult) = when(value) {
        is CustomSettingsSetMobileSignatureResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CustomSettingsSetMobileSignatureResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CustomSettingsSetMobileSignatureResult, buf: ByteBuffer) {
        when(value) {
            is CustomSettingsSetMobileSignatureResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is CustomSettingsSetMobileSignatureResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CustomSettingsSetSwipeToAdjacentConversationResult {
    
    object Ok : CustomSettingsSetSwipeToAdjacentConversationResult()
    
    
    data class Error(
        val v1: ProtonError) : CustomSettingsSetSwipeToAdjacentConversationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettingsSetSwipeToAdjacentConversationResult : FfiConverterRustBuffer<CustomSettingsSetSwipeToAdjacentConversationResult>{
    override fun read(buf: ByteBuffer): CustomSettingsSetSwipeToAdjacentConversationResult {
        return when(buf.getInt()) {
            1 -> CustomSettingsSetSwipeToAdjacentConversationResult.Ok
            2 -> CustomSettingsSetSwipeToAdjacentConversationResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CustomSettingsSetSwipeToAdjacentConversationResult) = when(value) {
        is CustomSettingsSetSwipeToAdjacentConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CustomSettingsSetSwipeToAdjacentConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CustomSettingsSetSwipeToAdjacentConversationResult, buf: ByteBuffer) {
        when(value) {
            is CustomSettingsSetSwipeToAdjacentConversationResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is CustomSettingsSetSwipeToAdjacentConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CustomSettingsSwipeToAdjacentConversationResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : CustomSettingsSwipeToAdjacentConversationResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : CustomSettingsSwipeToAdjacentConversationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCustomSettingsSwipeToAdjacentConversationResult : FfiConverterRustBuffer<CustomSettingsSwipeToAdjacentConversationResult>{
    override fun read(buf: ByteBuffer): CustomSettingsSwipeToAdjacentConversationResult {
        return when(buf.getInt()) {
            1 -> CustomSettingsSwipeToAdjacentConversationResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> CustomSettingsSwipeToAdjacentConversationResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CustomSettingsSwipeToAdjacentConversationResult) = when(value) {
        is CustomSettingsSwipeToAdjacentConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is CustomSettingsSwipeToAdjacentConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CustomSettingsSwipeToAdjacentConversationResult, buf: ByteBuffer) {
        when(value) {
            is CustomSettingsSwipeToAdjacentConversationResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is CustomSettingsSwipeToAdjacentConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class DateFormat(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    DEFAULT(0u),
    /**
     * TODO: Document this variant.
     */
    DD_MM_YYYY(1u),
    /**
     * TODO: Document this variant.
     */
    MM_DD_YYYY(2u),
    /**
     * TODO: Document this variant.
     */
    YYYY_MM_DD(3u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDateFormat: FfiConverterRustBuffer<DateFormat> {
    override fun read(buf: ByteBuffer) = try {
        DateFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DateFormat) = 4UL

    override fun write(value: DateFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class DaysSinceAccountCreation {
    
    ZERO,
    ONE_THROUGH_THREE,
    FOUR_THROUGH_TEN,
    ELEVEN_THROUGH_THIRTY,
    THIRTY_ONE_THROUGH_SIXTY,
    MORE_THAN_SIXTY,
    NOT_APPLICABLE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDaysSinceAccountCreation: FfiConverterRustBuffer<DaysSinceAccountCreation> {
    override fun read(buf: ByteBuffer) = try {
        DaysSinceAccountCreation.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DaysSinceAccountCreation) = 4UL

    override fun write(value: DaysSinceAccountCreation, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DecryptPushNotificationResult {
    
    data class Ok(
        val v1: DecryptedPushNotification) : DecryptPushNotificationResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : DecryptPushNotificationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptPushNotificationResult : FfiConverterRustBuffer<DecryptPushNotificationResult>{
    override fun read(buf: ByteBuffer): DecryptPushNotificationResult {
        return when(buf.getInt()) {
            1 -> DecryptPushNotificationResult.Ok(
                FfiConverterTypeDecryptedPushNotification.read(buf),
                )
            2 -> DecryptPushNotificationResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DecryptPushNotificationResult) = when(value) {
        is DecryptPushNotificationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedPushNotification.allocationSize(value.v1)
            )
        }
        is DecryptPushNotificationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DecryptPushNotificationResult, buf: ByteBuffer) {
        when(value) {
            is DecryptPushNotificationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDecryptedPushNotification.write(value.v1, buf)
                Unit
            }
            is DecryptPushNotificationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DecryptedEmailPushNotificationAction {
    
    object MessageCreated : DecryptedEmailPushNotificationAction()
    
    
    object MessageTouched : DecryptedEmailPushNotificationAction()
    
    
    data class Unexpected(
        val v1: kotlin.String) : DecryptedEmailPushNotificationAction() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedEmailPushNotificationAction : FfiConverterRustBuffer<DecryptedEmailPushNotificationAction>{
    override fun read(buf: ByteBuffer): DecryptedEmailPushNotificationAction {
        return when(buf.getInt()) {
            1 -> DecryptedEmailPushNotificationAction.MessageCreated
            2 -> DecryptedEmailPushNotificationAction.MessageTouched
            3 -> DecryptedEmailPushNotificationAction.Unexpected(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DecryptedEmailPushNotificationAction) = when(value) {
        is DecryptedEmailPushNotificationAction.MessageCreated -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DecryptedEmailPushNotificationAction.MessageTouched -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DecryptedEmailPushNotificationAction.Unexpected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DecryptedEmailPushNotificationAction, buf: ByteBuffer) {
        when(value) {
            is DecryptedEmailPushNotificationAction.MessageCreated -> {
                buf.putInt(1)
                Unit
            }
            is DecryptedEmailPushNotificationAction.MessageTouched -> {
                buf.putInt(2)
                Unit
            }
            is DecryptedEmailPushNotificationAction.Unexpected -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DecryptedPushNotification {
    
    data class Email(
        val v1: DecryptedEmailPushNotification) : DecryptedPushNotification() {
        companion object
    }
    
    data class OpenUrl(
        val v1: DecryptedOpenUrlPushNotification) : DecryptedPushNotification() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecryptedPushNotification : FfiConverterRustBuffer<DecryptedPushNotification>{
    override fun read(buf: ByteBuffer): DecryptedPushNotification {
        return when(buf.getInt()) {
            1 -> DecryptedPushNotification.Email(
                FfiConverterTypeDecryptedEmailPushNotification.read(buf),
                )
            2 -> DecryptedPushNotification.OpenUrl(
                FfiConverterTypeDecryptedOpenUrlPushNotification.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DecryptedPushNotification) = when(value) {
        is DecryptedPushNotification.Email -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedEmailPushNotification.allocationSize(value.v1)
            )
        }
        is DecryptedPushNotification.OpenUrl -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedOpenUrlPushNotification.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DecryptedPushNotification, buf: ByteBuffer) {
        when(value) {
            is DecryptedPushNotification.Email -> {
                buf.putInt(1)
                FfiConverterTypeDecryptedEmailPushNotification.write(value.v1, buf)
                Unit
            }
            is DecryptedPushNotification.OpenUrl -> {
                buf.putInt(2)
                FfiConverterTypeDecryptedOpenUrlPushNotification.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class Density(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    COMFORTABLE(0u),
    /**
     * TODO: Document this variant.
     */
    COMPACT(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDensity: FfiConverterRustBuffer<Density> {
    override fun read(buf: ByteBuffer) = try {
        Density.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Density) = 4UL

    override fun write(value: Density, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * In which environment are we going to register the device
 * for the push notification.

 */

enum class DeviceEnvironment {
    
    GOOGLE,
    APPLE_PROD,
    APPLE_BETA,
    APPLE_PROD_ET,
    APPLE_DEV_ET,
    APPLE_DEV;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDeviceEnvironment: FfiConverterRustBuffer<DeviceEnvironment> {
    override fun read(buf: ByteBuffer) = try {
        DeviceEnvironment.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DeviceEnvironment) = 4UL

    override fun write(value: DeviceEnvironment, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class Disposition(val value: kotlin.UByte) {
    
    ATTACHMENT(1u),
    INLINE(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDisposition: FfiConverterRustBuffer<Disposition> {
    override fun read(buf: ByteBuffer) = try {
        Disposition.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Disposition) = 4UL

    override fun write(value: Disposition, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class DraftAddressValidationError {
    
    SUBSCRIPTION_REQUIRED,
    DISABLED,
    CAN_NOT_SEND,
    CAN_NOT_RECEIVE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftAddressValidationError: FfiConverterRustBuffer<DraftAddressValidationError> {
    override fun read(buf: ByteBuffer) = try {
        DraftAddressValidationError.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftAddressValidationError) = 4UL

    override fun write(value: DraftAddressValidationError, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftAttachmentDispositionSwapError {
    
    data class Reason(
        val v1: DraftAttachmentDispositionSwapErrorReason) : DraftAttachmentDispositionSwapError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftAttachmentDispositionSwapError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentDispositionSwapError : FfiConverterRustBuffer<DraftAttachmentDispositionSwapError>{
    override fun read(buf: ByteBuffer): DraftAttachmentDispositionSwapError {
        return when(buf.getInt()) {
            1 -> DraftAttachmentDispositionSwapError.Reason(
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.read(buf),
                )
            2 -> DraftAttachmentDispositionSwapError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachmentDispositionSwapError) = when(value) {
        is DraftAttachmentDispositionSwapError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.allocationSize(value.v1)
            )
        }
        is DraftAttachmentDispositionSwapError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftAttachmentDispositionSwapError, buf: ByteBuffer) {
        when(value) {
            is DraftAttachmentDispositionSwapError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentDispositionSwapError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftAttachmentDispositionSwapErrorReason {
    
    INVALID_STATE,
    NOOP,
    ATTACHMENT_DOES_NOT_EXIST,
    ATTACHMENT_MESSAGE_DOES_NOT_EXIST,
    ATTACHMENT_MESSAGE_IS_NOT_A_DRAFT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentDispositionSwapErrorReason: FfiConverterRustBuffer<DraftAttachmentDispositionSwapErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftAttachmentDispositionSwapErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftAttachmentDispositionSwapErrorReason) = 4UL

    override fun write(value: DraftAttachmentDispositionSwapErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftAttachmentError {
    
    data class Upload(
        val v1: DraftAttachmentUploadError) : DraftAttachmentError() {
        companion object
    }
    
    data class DispositionSwap(
        val v1: DraftAttachmentDispositionSwapError) : DraftAttachmentError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentError : FfiConverterRustBuffer<DraftAttachmentError>{
    override fun read(buf: ByteBuffer): DraftAttachmentError {
        return when(buf.getInt()) {
            1 -> DraftAttachmentError.Upload(
                FfiConverterTypeDraftAttachmentUploadError.read(buf),
                )
            2 -> DraftAttachmentError.DispositionSwap(
                FfiConverterTypeDraftAttachmentDispositionSwapError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachmentError) = when(value) {
        is DraftAttachmentError.Upload -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadError.allocationSize(value.v1)
            )
        }
        is DraftAttachmentError.DispositionSwap -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentDispositionSwapError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftAttachmentError, buf: ByteBuffer) {
        when(value) {
            is DraftAttachmentError.Upload -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentUploadError.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentError.DispositionSwap -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentDispositionSwapError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftAttachmentRetryError {
    
    data class Upload(
        val v1: DraftAttachmentUploadErrorReason) : DraftAttachmentRetryError() {
        companion object
    }
    
    data class DispositionSwap(
        val v1: DraftAttachmentDispositionSwapErrorReason) : DraftAttachmentRetryError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftAttachmentRetryError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentRetryError : FfiConverterRustBuffer<DraftAttachmentRetryError>{
    override fun read(buf: ByteBuffer): DraftAttachmentRetryError {
        return when(buf.getInt()) {
            1 -> DraftAttachmentRetryError.Upload(
                FfiConverterTypeDraftAttachmentUploadErrorReason.read(buf),
                )
            2 -> DraftAttachmentRetryError.DispositionSwap(
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.read(buf),
                )
            3 -> DraftAttachmentRetryError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachmentRetryError) = when(value) {
        is DraftAttachmentRetryError.Upload -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadErrorReason.allocationSize(value.v1)
            )
        }
        is DraftAttachmentRetryError.DispositionSwap -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.allocationSize(value.v1)
            )
        }
        is DraftAttachmentRetryError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftAttachmentRetryError, buf: ByteBuffer) {
        when(value) {
            is DraftAttachmentRetryError.Upload -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentUploadErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentRetryError.DispositionSwap -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentRetryError.Other -> {
                buf.putInt(3)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * State of the attachment
 */
sealed class DraftAttachmentState {
    
    /**
     * Can't upload due to lack of network.
     */
    object Offline : DraftAttachmentState()
    
    
    /**
     * Attachment is uploading.
     */
    object Uploading : DraftAttachmentState()
    
    
    /**
     * Attachment has failed uploading
     */
    object Uploaded : DraftAttachmentState()
    
    
    /**
     * An error occurred during upload.
     */
    data class Error(
        val v1: DraftAttachmentError) : DraftAttachmentState() {
        companion object
    }
    
    /**
     * Attachment is awaiting upload
     */
    object Pending : DraftAttachmentState()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentState : FfiConverterRustBuffer<DraftAttachmentState>{
    override fun read(buf: ByteBuffer): DraftAttachmentState {
        return when(buf.getInt()) {
            1 -> DraftAttachmentState.Offline
            2 -> DraftAttachmentState.Uploading
            3 -> DraftAttachmentState.Uploaded
            4 -> DraftAttachmentState.Error(
                FfiConverterTypeDraftAttachmentError.read(buf),
                )
            5 -> DraftAttachmentState.Pending
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachmentState) = when(value) {
        is DraftAttachmentState.Offline -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftAttachmentState.Uploading -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftAttachmentState.Uploaded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftAttachmentState.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentError.allocationSize(value.v1)
            )
        }
        is DraftAttachmentState.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: DraftAttachmentState, buf: ByteBuffer) {
        when(value) {
            is DraftAttachmentState.Offline -> {
                buf.putInt(1)
                Unit
            }
            is DraftAttachmentState.Uploading -> {
                buf.putInt(2)
                Unit
            }
            is DraftAttachmentState.Uploaded -> {
                buf.putInt(3)
                Unit
            }
            is DraftAttachmentState.Error -> {
                buf.putInt(4)
                FfiConverterTypeDraftAttachmentError.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentState.Pending -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftAttachmentUploadError {
    
    data class Reason(
        val v1: DraftAttachmentUploadErrorReason) : DraftAttachmentUploadError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftAttachmentUploadError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentUploadError : FfiConverterRustBuffer<DraftAttachmentUploadError>{
    override fun read(buf: ByteBuffer): DraftAttachmentUploadError {
        return when(buf.getInt()) {
            1 -> DraftAttachmentUploadError.Reason(
                FfiConverterTypeDraftAttachmentUploadErrorReason.read(buf),
                )
            2 -> DraftAttachmentUploadError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachmentUploadError) = when(value) {
        is DraftAttachmentUploadError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadErrorReason.allocationSize(value.v1)
            )
        }
        is DraftAttachmentUploadError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftAttachmentUploadError, buf: ByteBuffer) {
        when(value) {
            is DraftAttachmentUploadError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftAttachmentUploadErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftAttachmentUploadError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftAttachmentUploadErrorReason {
    
    /**
     * This message no longer exists.
     */
    MESSAGE_DOES_NOT_EXIST,
    /**
     * Message does not exist on the server
     */
    MESSAGE_DOES_NOT_EXIST_ON_SERVER,
    /**
     * Failed to encrypt the attachment
     */
    CRYPTO,
    /**
     * Too Many Attachments
     */
    TOO_MANY_ATTACHMENTS,
    /**
     * Message was already sent.
     */
    MESSAGE_ALREADY_SENT,
    /**
     * Attachment is too large
     */
    ATTACHMENT_TOO_LARGE,
    /**
     * Upload Retry in invalid state
     */
    RETRY_INVALID_STATE,
    /**
     * Combined Attachment size is too large
     */
    TOTAL_ATTACHMENT_SIZE_TOO_LARGE,
    /**
     * Attachment upload timed out
     */
    TIMEOUT,
    STORAGE_QUOTA_EXCEEDED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftAttachmentUploadErrorReason: FfiConverterRustBuffer<DraftAttachmentUploadErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftAttachmentUploadErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftAttachmentUploadErrorReason) = 4UL

    override fun write(value: DraftAttachmentUploadErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftCancelScheduleSendError {
    
    data class Reason(
        val v1: DraftCancelScheduleSendErrorReason) : DraftCancelScheduleSendError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftCancelScheduleSendError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftCancelScheduleSendError : FfiConverterRustBuffer<DraftCancelScheduleSendError>{
    override fun read(buf: ByteBuffer): DraftCancelScheduleSendError {
        return when(buf.getInt()) {
            1 -> DraftCancelScheduleSendError.Reason(
                FfiConverterTypeDraftCancelScheduleSendErrorReason.read(buf),
                )
            2 -> DraftCancelScheduleSendError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftCancelScheduleSendError) = when(value) {
        is DraftCancelScheduleSendError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftCancelScheduleSendErrorReason.allocationSize(value.v1)
            )
        }
        is DraftCancelScheduleSendError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftCancelScheduleSendError, buf: ByteBuffer) {
        when(value) {
            is DraftCancelScheduleSendError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftCancelScheduleSendErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftCancelScheduleSendError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftCancelScheduleSendErrorReason {
    
    MESSAGE_DOES_NOT_EXIST,
    MESSAGE_NOT_SCHEDULED,
    MESSAGE_ALREADY_SENT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftCancelScheduleSendErrorReason: FfiConverterRustBuffer<DraftCancelScheduleSendErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftCancelScheduleSendErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftCancelScheduleSendErrorReason) = 4UL

    override fun write(value: DraftCancelScheduleSendErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftCancelScheduleSendResult {
    
    data class Ok(
        val v1: DraftCancelScheduledSendInfo) : DraftCancelScheduleSendResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftCancelScheduleSendError) : DraftCancelScheduleSendResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftCancelScheduleSendResult : FfiConverterRustBuffer<DraftCancelScheduleSendResult>{
    override fun read(buf: ByteBuffer): DraftCancelScheduleSendResult {
        return when(buf.getInt()) {
            1 -> DraftCancelScheduleSendResult.Ok(
                FfiConverterTypeDraftCancelScheduledSendInfo.read(buf),
                )
            2 -> DraftCancelScheduleSendResult.Error(
                FfiConverterTypeDraftCancelScheduleSendError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftCancelScheduleSendResult) = when(value) {
        is DraftCancelScheduleSendResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftCancelScheduledSendInfo.allocationSize(value.v1)
            )
        }
        is DraftCancelScheduleSendResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftCancelScheduleSendError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftCancelScheduleSendResult, buf: ByteBuffer) {
        when(value) {
            is DraftCancelScheduleSendResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftCancelScheduledSendInfo.write(value.v1, buf)
                Unit
            }
            is DraftCancelScheduleSendResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftCancelScheduleSendError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftChangeSenderAddressResult {
    
    object Ok : DraftChangeSenderAddressResult()
    
    
    data class Error(
        val v1: DraftSenderAddressChangeError) : DraftChangeSenderAddressResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftChangeSenderAddressResult : FfiConverterRustBuffer<DraftChangeSenderAddressResult>{
    override fun read(buf: ByteBuffer): DraftChangeSenderAddressResult {
        return when(buf.getInt()) {
            1 -> DraftChangeSenderAddressResult.Ok
            2 -> DraftChangeSenderAddressResult.Error(
                FfiConverterTypeDraftSenderAddressChangeError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftChangeSenderAddressResult) = when(value) {
        is DraftChangeSenderAddressResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftChangeSenderAddressResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSenderAddressChangeError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftChangeSenderAddressResult, buf: ByteBuffer) {
        when(value) {
            is DraftChangeSenderAddressResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is DraftChangeSenderAddressResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftSenderAddressChangeError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftComposerContentResult {
    
    data class Ok(
        val v1: ComposerContent) : DraftComposerContentResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftComposerContentResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftComposerContentResult : FfiConverterRustBuffer<DraftComposerContentResult>{
    override fun read(buf: ByteBuffer): DraftComposerContentResult {
        return when(buf.getInt()) {
            1 -> DraftComposerContentResult.Ok(
                FfiConverterTypeComposerContent.read(buf),
                )
            2 -> DraftComposerContentResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftComposerContentResult) = when(value) {
        is DraftComposerContentResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeComposerContent.allocationSize(value.v1)
            )
        }
        is DraftComposerContentResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftComposerContentResult, buf: ByteBuffer) {
        when(value) {
            is DraftComposerContentResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeComposerContent.write(value.v1, buf)
                Unit
            }
            is DraftComposerContentResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftCreateMode {
    
    object Empty : DraftCreateMode()
    
    
    data class Reply(
        val v1: Id) : DraftCreateMode() {
        companion object
    }
    
    data class ReplyAll(
        val v1: Id) : DraftCreateMode() {
        companion object
    }
    
    data class Forward(
        val v1: Id) : DraftCreateMode() {
        companion object
    }
    
    data class Mailto(
        val v1: kotlin.String) : DraftCreateMode() {
        companion object
    }
    
    object FromIosShareExtension : DraftCreateMode()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftCreateMode : FfiConverterRustBuffer<DraftCreateMode>{
    override fun read(buf: ByteBuffer): DraftCreateMode {
        return when(buf.getInt()) {
            1 -> DraftCreateMode.Empty
            2 -> DraftCreateMode.Reply(
                FfiConverterTypeId.read(buf),
                )
            3 -> DraftCreateMode.ReplyAll(
                FfiConverterTypeId.read(buf),
                )
            4 -> DraftCreateMode.Forward(
                FfiConverterTypeId.read(buf),
                )
            5 -> DraftCreateMode.Mailto(
                FfiConverterString.read(buf),
                )
            6 -> DraftCreateMode.FromIosShareExtension
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftCreateMode) = when(value) {
        is DraftCreateMode.Empty -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftCreateMode.Reply -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeId.allocationSize(value.v1)
            )
        }
        is DraftCreateMode.ReplyAll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeId.allocationSize(value.v1)
            )
        }
        is DraftCreateMode.Forward -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeId.allocationSize(value.v1)
            )
        }
        is DraftCreateMode.Mailto -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftCreateMode.FromIosShareExtension -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: DraftCreateMode, buf: ByteBuffer) {
        when(value) {
            is DraftCreateMode.Empty -> {
                buf.putInt(1)
                Unit
            }
            is DraftCreateMode.Reply -> {
                buf.putInt(2)
                FfiConverterTypeId.write(value.v1, buf)
                Unit
            }
            is DraftCreateMode.ReplyAll -> {
                buf.putInt(3)
                FfiConverterTypeId.write(value.v1, buf)
                Unit
            }
            is DraftCreateMode.Forward -> {
                buf.putInt(4)
                FfiConverterTypeId.write(value.v1, buf)
                Unit
            }
            is DraftCreateMode.Mailto -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftCreateMode.FromIosShareExtension -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftDiscardError {
    
    data class Reason(
        val v1: DraftDiscardErrorReason) : DraftDiscardError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftDiscardError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftDiscardError : FfiConverterRustBuffer<DraftDiscardError>{
    override fun read(buf: ByteBuffer): DraftDiscardError {
        return when(buf.getInt()) {
            1 -> DraftDiscardError.Reason(
                FfiConverterTypeDraftDiscardErrorReason.read(buf),
                )
            2 -> DraftDiscardError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftDiscardError) = when(value) {
        is DraftDiscardError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftDiscardErrorReason.allocationSize(value.v1)
            )
        }
        is DraftDiscardError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftDiscardError, buf: ByteBuffer) {
        when(value) {
            is DraftDiscardError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftDiscardErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftDiscardError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason when attempting to discard a draft.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * while saving or sending a draft in order to provide only the necessary
 * information to the user.
 */

enum class DraftDiscardErrorReason {
    
    /**
     * This message does not exist
     */
    MESSAGE_DOES_NOT_EXIST,
    /**
     * Deleting the draft failed
     */
    DELETE_FAILED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftDiscardErrorReason: FfiConverterRustBuffer<DraftDiscardErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftDiscardErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftDiscardErrorReason) = 4UL

    override fun write(value: DraftDiscardErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftExpirationError {
    
    data class Reason(
        val v1: DraftExpirationErrorReason) : DraftExpirationError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftExpirationError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftExpirationError : FfiConverterRustBuffer<DraftExpirationError>{
    override fun read(buf: ByteBuffer): DraftExpirationError {
        return when(buf.getInt()) {
            1 -> DraftExpirationError.Reason(
                FfiConverterTypeDraftExpirationErrorReason.read(buf),
                )
            2 -> DraftExpirationError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftExpirationError) = when(value) {
        is DraftExpirationError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftExpirationErrorReason.allocationSize(value.v1)
            )
        }
        is DraftExpirationError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftExpirationError, buf: ByteBuffer) {
        when(value) {
            is DraftExpirationError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftExpirationErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftExpirationError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftExpirationErrorReason {
    
    EXPIRATION_TIME_IN_THE_PAST,
    EXPIRATION_TIME_LESS_THAN15_MIN,
    EXPIRATION_TIME_EXCEEDS30_DAYS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftExpirationErrorReason: FfiConverterRustBuffer<DraftExpirationErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftExpirationErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftExpirationErrorReason) = 4UL

    override fun write(value: DraftExpirationErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftExpirationTime {
    
    object Never : DraftExpirationTime()
    
    
    object OneHour : DraftExpirationTime()
    
    
    object OneDay : DraftExpirationTime()
    
    
    object ThreeDays : DraftExpirationTime()
    
    
    data class Custom(
        val v1: UnixTimestamp) : DraftExpirationTime() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftExpirationTime : FfiConverterRustBuffer<DraftExpirationTime>{
    override fun read(buf: ByteBuffer): DraftExpirationTime {
        return when(buf.getInt()) {
            1 -> DraftExpirationTime.Never
            2 -> DraftExpirationTime.OneHour
            3 -> DraftExpirationTime.OneDay
            4 -> DraftExpirationTime.ThreeDays
            5 -> DraftExpirationTime.Custom(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftExpirationTime) = when(value) {
        is DraftExpirationTime.Never -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftExpirationTime.OneHour -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftExpirationTime.OneDay -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftExpirationTime.ThreeDays -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftExpirationTime.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftExpirationTime, buf: ByteBuffer) {
        when(value) {
            is DraftExpirationTime.Never -> {
                buf.putInt(1)
                Unit
            }
            is DraftExpirationTime.OneHour -> {
                buf.putInt(2)
                Unit
            }
            is DraftExpirationTime.OneDay -> {
                buf.putInt(3)
                Unit
            }
            is DraftExpirationTime.ThreeDays -> {
                buf.putInt(4)
                Unit
            }
            is DraftExpirationTime.Custom -> {
                buf.putInt(5)
                FfiConverterTypeUnixTimestamp.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftExpirationTimeResult {
    
    data class Ok(
        val v1: DraftExpirationTime) : DraftExpirationTimeResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftExpirationTimeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftExpirationTimeResult : FfiConverterRustBuffer<DraftExpirationTimeResult>{
    override fun read(buf: ByteBuffer): DraftExpirationTimeResult {
        return when(buf.getInt()) {
            1 -> DraftExpirationTimeResult.Ok(
                FfiConverterTypeDraftExpirationTime.read(buf),
                )
            2 -> DraftExpirationTimeResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftExpirationTimeResult) = when(value) {
        is DraftExpirationTimeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftExpirationTime.allocationSize(value.v1)
            )
        }
        is DraftExpirationTimeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftExpirationTimeResult, buf: ByteBuffer) {
        when(value) {
            is DraftExpirationTimeResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftExpirationTime.write(value.v1, buf)
                Unit
            }
            is DraftExpirationTimeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftGetPasswordResult {
    
    data class Ok(
        val v1: DraftPassword?) : DraftGetPasswordResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftGetPasswordResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftGetPasswordResult : FfiConverterRustBuffer<DraftGetPasswordResult>{
    override fun read(buf: ByteBuffer): DraftGetPasswordResult {
        return when(buf.getInt()) {
            1 -> DraftGetPasswordResult.Ok(
                FfiConverterOptionalTypeDraftPassword.read(buf),
                )
            2 -> DraftGetPasswordResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftGetPasswordResult) = when(value) {
        is DraftGetPasswordResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeDraftPassword.allocationSize(value.v1)
            )
        }
        is DraftGetPasswordResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftGetPasswordResult, buf: ByteBuffer) {
        when(value) {
            is DraftGetPasswordResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeDraftPassword.write(value.v1, buf)
                Unit
            }
            is DraftGetPasswordResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftIsPasswordProtectedResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : DraftIsPasswordProtectedResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftIsPasswordProtectedResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftIsPasswordProtectedResult : FfiConverterRustBuffer<DraftIsPasswordProtectedResult>{
    override fun read(buf: ByteBuffer): DraftIsPasswordProtectedResult {
        return when(buf.getInt()) {
            1 -> DraftIsPasswordProtectedResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> DraftIsPasswordProtectedResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftIsPasswordProtectedResult) = when(value) {
        is DraftIsPasswordProtectedResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is DraftIsPasswordProtectedResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftIsPasswordProtectedResult, buf: ByteBuffer) {
        when(value) {
            is DraftIsPasswordProtectedResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is DraftIsPasswordProtectedResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftListSenderAddressesResult {
    
    data class Ok(
        val v1: DraftSenderAddressList) : DraftListSenderAddressesResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftListSenderAddressesResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftListSenderAddressesResult : FfiConverterRustBuffer<DraftListSenderAddressesResult>{
    override fun read(buf: ByteBuffer): DraftListSenderAddressesResult {
        return when(buf.getInt()) {
            1 -> DraftListSenderAddressesResult.Ok(
                FfiConverterTypeDraftSenderAddressList.read(buf),
                )
            2 -> DraftListSenderAddressesResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftListSenderAddressesResult) = when(value) {
        is DraftListSenderAddressesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSenderAddressList.allocationSize(value.v1)
            )
        }
        is DraftListSenderAddressesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftListSenderAddressesResult, buf: ByteBuffer) {
        when(value) {
            is DraftListSenderAddressesResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftSenderAddressList.write(value.v1, buf)
                Unit
            }
            is DraftListSenderAddressesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftMessageIdResult {
    
    data class Ok(
        val v1: Id?) : DraftMessageIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftMessageIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftMessageIdResult : FfiConverterRustBuffer<DraftMessageIdResult>{
    override fun read(buf: ByteBuffer): DraftMessageIdResult {
        return when(buf.getInt()) {
            1 -> DraftMessageIdResult.Ok(
                FfiConverterOptionalTypeId.read(buf),
                )
            2 -> DraftMessageIdResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftMessageIdResult) = when(value) {
        is DraftMessageIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeId.allocationSize(value.v1)
            )
        }
        is DraftMessageIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftMessageIdResult, buf: ByteBuffer) {
        when(value) {
            is DraftMessageIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeId.write(value.v1, buf)
                Unit
            }
            is DraftMessageIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftOpenError {
    
    data class Reason(
        val v1: DraftOpenErrorReason) : DraftOpenError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftOpenError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftOpenError : FfiConverterRustBuffer<DraftOpenError>{
    override fun read(buf: ByteBuffer): DraftOpenError {
        return when(buf.getInt()) {
            1 -> DraftOpenError.Reason(
                FfiConverterTypeDraftOpenErrorReason.read(buf),
                )
            2 -> DraftOpenError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftOpenError) = when(value) {
        is DraftOpenError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftOpenErrorReason.allocationSize(value.v1)
            )
        }
        is DraftOpenError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftOpenError, buf: ByteBuffer) {
        when(value) {
            is DraftOpenError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftOpenErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftOpenError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason when opening a draft fails.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * while drafting a new message in order to provide only the necessary
 * information to the user.
 */

enum class DraftOpenErrorReason {
    
    /**
     * This message no longer exists.
     */
    MESSAGE_DOES_NOT_EXIST,
    /**
     * This message is not a draft
     */
    MESSAGE_IS_NOT_A_DRAFT,
    /**
     * Attempting to reply or forward to a draft
     */
    REPLY_OR_FORWARD_DRAFT,
    /**
     * Could not find the user's address
     */
    ADDRESS_NOT_FOUND,
    /**
     * Message body is missing
     */
    MESSAGE_BODY_MISSING;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftOpenErrorReason: FfiConverterRustBuffer<DraftOpenErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftOpenErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftOpenErrorReason) = 4UL

    override fun write(value: DraftOpenErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftPasswordError {
    
    data class Reason(
        val v1: DraftPasswordErrorReason) : DraftPasswordError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftPasswordError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftPasswordError : FfiConverterRustBuffer<DraftPasswordError>{
    override fun read(buf: ByteBuffer): DraftPasswordError {
        return when(buf.getInt()) {
            1 -> DraftPasswordError.Reason(
                FfiConverterTypeDraftPasswordErrorReason.read(buf),
                )
            2 -> DraftPasswordError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftPasswordError) = when(value) {
        is DraftPasswordError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftPasswordErrorReason.allocationSize(value.v1)
            )
        }
        is DraftPasswordError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftPasswordError, buf: ByteBuffer) {
        when(value) {
            is DraftPasswordError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftPasswordErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftPasswordError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftPasswordErrorReason {
    
    PASSWORD_TOO_SHORT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftPasswordErrorReason: FfiConverterRustBuffer<DraftPasswordErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftPasswordErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftPasswordErrorReason) = 4UL

    override fun write(value: DraftPasswordErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftSaveError {
    
    data class Reason(
        val v1: DraftSaveErrorReason) : DraftSaveError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftSaveError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSaveError : FfiConverterRustBuffer<DraftSaveError>{
    override fun read(buf: ByteBuffer): DraftSaveError {
        return when(buf.getInt()) {
            1 -> DraftSaveError.Reason(
                FfiConverterTypeDraftSaveErrorReason.read(buf),
                )
            2 -> DraftSaveError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSaveError) = when(value) {
        is DraftSaveError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSaveError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSaveError, buf: ByteBuffer) {
        when(value) {
            is DraftSaveError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftSaveErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSaveError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason when saving a draft
 */
sealed class DraftSaveErrorReason {
    
    /**
     * Address does not have a primary key
     */
    data class AddressDoesNotHavePrimaryKey(
        val v1: kotlin.String) : DraftSaveErrorReason() {
        companion object
    }
    
    /**
     * Recipient email is invalid
     */
    data class RecipientEmailInvalid(
        val v1: kotlin.String) : DraftSaveErrorReason() {
        companion object
    }
    
    /**
     * This Proton recipient does not exist.
     */
    data class ProtonRecipientDoesNotExist(
        val v1: kotlin.String) : DraftSaveErrorReason() {
        companion object
    }
    
    /**
     * This address is disabled and can't be used for sending
     */
    data class AddressDisabled(
        val v1: kotlin.String) : DraftSaveErrorReason() {
        companion object
    }
    
    /**
     * Message was already sent.
     */
    object MessageAlreadySent : DraftSaveErrorReason()
    
    
    /**
     * This message no longer exists.
     */
    object MessageDoesNotExist : DraftSaveErrorReason()
    
    
    /**
     * Message is not a draft
     */
    object MessageIsNotADraft : DraftSaveErrorReason()
    
    
    /**
     * Too Many Attachments
     */
    object TooManyAttachments : DraftSaveErrorReason()
    
    
    /**
     * The attachment size exceeds the upper limit
     */
    object AttachmentTooLarge : DraftSaveErrorReason()
    
    
    /**
     * The combined attachment size exceeds the upper limit
     */
    object TotalAttachmentSizeTooLarge : DraftSaveErrorReason()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSaveErrorReason : FfiConverterRustBuffer<DraftSaveErrorReason>{
    override fun read(buf: ByteBuffer): DraftSaveErrorReason {
        return when(buf.getInt()) {
            1 -> DraftSaveErrorReason.AddressDoesNotHavePrimaryKey(
                FfiConverterString.read(buf),
                )
            2 -> DraftSaveErrorReason.RecipientEmailInvalid(
                FfiConverterString.read(buf),
                )
            3 -> DraftSaveErrorReason.ProtonRecipientDoesNotExist(
                FfiConverterString.read(buf),
                )
            4 -> DraftSaveErrorReason.AddressDisabled(
                FfiConverterString.read(buf),
                )
            5 -> DraftSaveErrorReason.MessageAlreadySent
            6 -> DraftSaveErrorReason.MessageDoesNotExist
            7 -> DraftSaveErrorReason.MessageIsNotADraft
            8 -> DraftSaveErrorReason.TooManyAttachments
            9 -> DraftSaveErrorReason.AttachmentTooLarge
            10 -> DraftSaveErrorReason.TotalAttachmentSizeTooLarge
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSaveErrorReason) = when(value) {
        is DraftSaveErrorReason.AddressDoesNotHavePrimaryKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSaveErrorReason.RecipientEmailInvalid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSaveErrorReason.ProtonRecipientDoesNotExist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSaveErrorReason.AddressDisabled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSaveErrorReason.MessageAlreadySent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSaveErrorReason.MessageDoesNotExist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSaveErrorReason.MessageIsNotADraft -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSaveErrorReason.TooManyAttachments -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSaveErrorReason.AttachmentTooLarge -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSaveErrorReason.TotalAttachmentSizeTooLarge -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: DraftSaveErrorReason, buf: ByteBuffer) {
        when(value) {
            is DraftSaveErrorReason.AddressDoesNotHavePrimaryKey -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSaveErrorReason.RecipientEmailInvalid -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSaveErrorReason.ProtonRecipientDoesNotExist -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSaveErrorReason.AddressDisabled -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSaveErrorReason.MessageAlreadySent -> {
                buf.putInt(5)
                Unit
            }
            is DraftSaveErrorReason.MessageDoesNotExist -> {
                buf.putInt(6)
                Unit
            }
            is DraftSaveErrorReason.MessageIsNotADraft -> {
                buf.putInt(7)
                Unit
            }
            is DraftSaveErrorReason.TooManyAttachments -> {
                buf.putInt(8)
                Unit
            }
            is DraftSaveErrorReason.AttachmentTooLarge -> {
                buf.putInt(9)
                Unit
            }
            is DraftSaveErrorReason.TotalAttachmentSizeTooLarge -> {
                buf.putInt(10)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftScheduleSendOptionsResult {
    
    data class Ok(
        val v1: DraftScheduleSendOptions) : DraftScheduleSendOptionsResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftScheduleSendOptionsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftScheduleSendOptionsResult : FfiConverterRustBuffer<DraftScheduleSendOptionsResult>{
    override fun read(buf: ByteBuffer): DraftScheduleSendOptionsResult {
        return when(buf.getInt()) {
            1 -> DraftScheduleSendOptionsResult.Ok(
                FfiConverterTypeDraftScheduleSendOptions.read(buf),
                )
            2 -> DraftScheduleSendOptionsResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftScheduleSendOptionsResult) = when(value) {
        is DraftScheduleSendOptionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftScheduleSendOptions.allocationSize(value.v1)
            )
        }
        is DraftScheduleSendOptionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftScheduleSendOptionsResult, buf: ByteBuffer) {
        when(value) {
            is DraftScheduleSendOptionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftScheduleSendOptions.write(value.v1, buf)
                Unit
            }
            is DraftScheduleSendOptionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftSendError {
    
    data class Reason(
        val v1: DraftSendErrorReason) : DraftSendError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftSendError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendError : FfiConverterRustBuffer<DraftSendError>{
    override fun read(buf: ByteBuffer): DraftSendError {
        return when(buf.getInt()) {
            1 -> DraftSendError.Reason(
                FfiConverterTypeDraftSendErrorReason.read(buf),
                )
            2 -> DraftSendError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSendError) = when(value) {
        is DraftSendError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSendErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSendError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSendError, buf: ByteBuffer) {
        when(value) {
            is DraftSendError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftSendErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSendError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason when saving a draft
 */
sealed class DraftSendErrorReason {
    
    /**
     * Message has no recipients
     */
    object NoRecipients : DraftSendErrorReason()
    
    
    /**
     * Address does not have a primary key
     */
    data class AddressDoesNotHavePrimaryKey(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    
    /**
     * Recipient email is invalid
     */
    data class RecipientEmailInvalid(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    
    /**
     * This Proton recipient does not exist.
     */
    data class ProtonRecipientDoesNotExist(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    
    /**
     * This address is disabled and can't be used for sending
     */
    data class AddressDisabled(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    
    /**
     * Message was already sent.
     */
    object MessageAlreadySent : DraftSendErrorReason()
    
    
    /**
     * A packaging error occurred
     */
    data class PackageError(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    
    /**
     * This draft was already sent and can't be modified
     */
    object AlreadySent : DraftSendErrorReason()
    
    
    /**
     * This message no longer exists.
     */
    object MessageDoesNotExist : DraftSendErrorReason()
    
    
    /**
     * Message is not a draft
     */
    object MessageIsNotADraft : DraftSendErrorReason()
    
    
    /**
     * Message is missing attachment uploads
     */
    object MissingAttachmentUploads : DraftSendErrorReason()
    
    
    /**
     * Time at which the message was scheduled to send has already expired
     */
    object ScheduleSendExpired : DraftSendErrorReason()
    
    
    /**
     * The maximum number of scheduled send messages has been reached.
     */
    object ScheduleSendMessageLimitExceeded : DraftSendErrorReason()
    
    
    /**
     * Failed to decrypt external encryption password
     */
    object EoPasswordDecrypt : DraftSendErrorReason()
    
    
    /**
     * Expiration time is too soon
     */
    object ExpirationTimeTooSoon : DraftSendErrorReason()
    
    
    /**
     * Message + Attachment size too large
     */
    object MessageTooLarge : DraftSendErrorReason()
    
    
    /**
     * Bad server request - contains localized error string
     */
    data class BadRequest(
        val v1: kotlin.String) : DraftSendErrorReason() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendErrorReason : FfiConverterRustBuffer<DraftSendErrorReason>{
    override fun read(buf: ByteBuffer): DraftSendErrorReason {
        return when(buf.getInt()) {
            1 -> DraftSendErrorReason.NoRecipients
            2 -> DraftSendErrorReason.AddressDoesNotHavePrimaryKey(
                FfiConverterString.read(buf),
                )
            3 -> DraftSendErrorReason.RecipientEmailInvalid(
                FfiConverterString.read(buf),
                )
            4 -> DraftSendErrorReason.ProtonRecipientDoesNotExist(
                FfiConverterString.read(buf),
                )
            5 -> DraftSendErrorReason.AddressDisabled(
                FfiConverterString.read(buf),
                )
            6 -> DraftSendErrorReason.MessageAlreadySent
            7 -> DraftSendErrorReason.PackageError(
                FfiConverterString.read(buf),
                )
            8 -> DraftSendErrorReason.AlreadySent
            9 -> DraftSendErrorReason.MessageDoesNotExist
            10 -> DraftSendErrorReason.MessageIsNotADraft
            11 -> DraftSendErrorReason.MissingAttachmentUploads
            12 -> DraftSendErrorReason.ScheduleSendExpired
            13 -> DraftSendErrorReason.ScheduleSendMessageLimitExceeded
            14 -> DraftSendErrorReason.EoPasswordDecrypt
            15 -> DraftSendErrorReason.ExpirationTimeTooSoon
            16 -> DraftSendErrorReason.MessageTooLarge
            17 -> DraftSendErrorReason.BadRequest(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSendErrorReason) = when(value) {
        is DraftSendErrorReason.NoRecipients -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.AddressDoesNotHavePrimaryKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSendErrorReason.RecipientEmailInvalid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSendErrorReason.ProtonRecipientDoesNotExist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSendErrorReason.AddressDisabled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSendErrorReason.MessageAlreadySent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.PackageError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSendErrorReason.AlreadySent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.MessageDoesNotExist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.MessageIsNotADraft -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.MissingAttachmentUploads -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.ScheduleSendExpired -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.ScheduleSendMessageLimitExceeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.EoPasswordDecrypt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.ExpirationTimeTooSoon -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.MessageTooLarge -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSendErrorReason.BadRequest -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSendErrorReason, buf: ByteBuffer) {
        when(value) {
            is DraftSendErrorReason.NoRecipients -> {
                buf.putInt(1)
                Unit
            }
            is DraftSendErrorReason.AddressDoesNotHavePrimaryKey -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSendErrorReason.RecipientEmailInvalid -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSendErrorReason.ProtonRecipientDoesNotExist -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSendErrorReason.AddressDisabled -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSendErrorReason.MessageAlreadySent -> {
                buf.putInt(6)
                Unit
            }
            is DraftSendErrorReason.PackageError -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSendErrorReason.AlreadySent -> {
                buf.putInt(8)
                Unit
            }
            is DraftSendErrorReason.MessageDoesNotExist -> {
                buf.putInt(9)
                Unit
            }
            is DraftSendErrorReason.MessageIsNotADraft -> {
                buf.putInt(10)
                Unit
            }
            is DraftSendErrorReason.MissingAttachmentUploads -> {
                buf.putInt(11)
                Unit
            }
            is DraftSendErrorReason.ScheduleSendExpired -> {
                buf.putInt(12)
                Unit
            }
            is DraftSendErrorReason.ScheduleSendMessageLimitExceeded -> {
                buf.putInt(13)
                Unit
            }
            is DraftSendErrorReason.EoPasswordDecrypt -> {
                buf.putInt(14)
                Unit
            }
            is DraftSendErrorReason.ExpirationTimeTooSoon -> {
                buf.putInt(15)
                Unit
            }
            is DraftSendErrorReason.MessageTooLarge -> {
                buf.putInt(16)
                Unit
            }
            is DraftSendErrorReason.BadRequest -> {
                buf.putInt(17)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftSendFailure {
    
    data class Save(
        val v1: DraftSaveErrorReason) : DraftSendFailure() {
        companion object
    }
    
    data class Send(
        val v1: DraftSendErrorReason) : DraftSendFailure() {
        companion object
    }
    
    data class AttachmentUpload(
        val v1: DraftAttachmentUploadErrorReason) : DraftSendFailure() {
        companion object
    }
    
    data class AttachmentDispositionSwap(
        val v1: DraftAttachmentDispositionSwapErrorReason) : DraftSendFailure() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftSendFailure() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendFailure : FfiConverterRustBuffer<DraftSendFailure>{
    override fun read(buf: ByteBuffer): DraftSendFailure {
        return when(buf.getInt()) {
            1 -> DraftSendFailure.Save(
                FfiConverterTypeDraftSaveErrorReason.read(buf),
                )
            2 -> DraftSendFailure.Send(
                FfiConverterTypeDraftSendErrorReason.read(buf),
                )
            3 -> DraftSendFailure.AttachmentUpload(
                FfiConverterTypeDraftAttachmentUploadErrorReason.read(buf),
                )
            4 -> DraftSendFailure.AttachmentDispositionSwap(
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.read(buf),
                )
            5 -> DraftSendFailure.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSendFailure) = when(value) {
        is DraftSendFailure.Save -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSendFailure.Send -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSendErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSendFailure.AttachmentUpload -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentUploadErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSendFailure.AttachmentDispositionSwap -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSendFailure.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSendFailure, buf: ByteBuffer) {
        when(value) {
            is DraftSendFailure.Save -> {
                buf.putInt(1)
                FfiConverterTypeDraftSaveErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSendFailure.Send -> {
                buf.putInt(2)
                FfiConverterTypeDraftSendErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSendFailure.AttachmentUpload -> {
                buf.putInt(3)
                FfiConverterTypeDraftAttachmentUploadErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSendFailure.AttachmentDispositionSwap -> {
                buf.putInt(4)
                FfiConverterTypeDraftAttachmentDispositionSwapErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSendFailure.Other -> {
                buf.putInt(5)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Origin of the result.
 */

enum class DraftSendResultOrigin {
    
    /**
     * When saving a draft without the intention to send.
     */
    SAVE,
    /**
     * When saving a draft with intention to send.
     */
    SAVE_BEFORE_SEND,
    /**
     * Sending of the saved draft.
     */
    SEND,
    /**
     * When uploading an attachment.
     */
    ATTACHMENT_UPLOAD,
    /**
     * We failed when scheduling a message send
     */
    SCHEDULE_SEND,
    /**
     * We failed when attempting to swap an attachment disposition
     */
    ATTACHMENT_DISPOSITION_SWAP;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftSendResultOrigin: FfiConverterRustBuffer<DraftSendResultOrigin> {
    override fun read(buf: ByteBuffer) = try {
        DraftSendResultOrigin.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftSendResultOrigin) = 4UL

    override fun write(value: DraftSendResultOrigin, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftSendResultUnseenResult {
    
    data class Ok(
        val v1: List<DraftSendResult>) : DraftSendResultUnseenResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftSendResultUnseenResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendResultUnseenResult : FfiConverterRustBuffer<DraftSendResultUnseenResult>{
    override fun read(buf: ByteBuffer): DraftSendResultUnseenResult {
        return when(buf.getInt()) {
            1 -> DraftSendResultUnseenResult.Ok(
                FfiConverterSequenceTypeDraftSendResult.read(buf),
                )
            2 -> DraftSendResultUnseenResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSendResultUnseenResult) = when(value) {
        is DraftSendResultUnseenResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeDraftSendResult.allocationSize(value.v1)
            )
        }
        is DraftSendResultUnseenResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSendResultUnseenResult, buf: ByteBuffer) {
        when(value) {
            is DraftSendResultUnseenResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeDraftSendResult.write(value.v1, buf)
                Unit
            }
            is DraftSendResultUnseenResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Indicates how a draft operation completed.
 */
sealed class DraftSendStatus {
    
    /**
     * Everything was completed with success. Contains the number of seconds left
     * until the message's sending can be cancelled. `0` means it is no longer
     * possible or the operation can not be done.
     */
    data class Success(
        val `secondsUntilCancel`: kotlin.ULong, 
        val `deliveryTime`: UnixTimestamp) : DraftSendStatus() {
        companion object
    }
    
    /**
     * Something failed.
     */
    data class Failure(
        val v1: DraftSendFailure) : DraftSendStatus() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSendStatus : FfiConverterRustBuffer<DraftSendStatus>{
    override fun read(buf: ByteBuffer): DraftSendStatus {
        return when(buf.getInt()) {
            1 -> DraftSendStatus.Success(
                FfiConverterULong.read(buf),
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            2 -> DraftSendStatus.Failure(
                FfiConverterTypeDraftSendFailure.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSendStatus) = when(value) {
        is DraftSendStatus.Success -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.`secondsUntilCancel`)
                + FfiConverterTypeUnixTimestamp.allocationSize(value.`deliveryTime`)
            )
        }
        is DraftSendStatus.Failure -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSendFailure.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSendStatus, buf: ByteBuffer) {
        when(value) {
            is DraftSendStatus.Success -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`secondsUntilCancel`, buf)
                FfiConverterTypeUnixTimestamp.write(value.`deliveryTime`, buf)
                Unit
            }
            is DraftSendStatus.Failure -> {
                buf.putInt(2)
                FfiConverterTypeDraftSendFailure.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftSenderAddressChangeError {
    
    data class Reason(
        val v1: DraftSenderAddressChangeErrorReason) : DraftSenderAddressChangeError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftSenderAddressChangeError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSenderAddressChangeError : FfiConverterRustBuffer<DraftSenderAddressChangeError>{
    override fun read(buf: ByteBuffer): DraftSenderAddressChangeError {
        return when(buf.getInt()) {
            1 -> DraftSenderAddressChangeError.Reason(
                FfiConverterTypeDraftSenderAddressChangeErrorReason.read(buf),
                )
            2 -> DraftSenderAddressChangeError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSenderAddressChangeError) = when(value) {
        is DraftSenderAddressChangeError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSenderAddressChangeErrorReason.allocationSize(value.v1)
            )
        }
        is DraftSenderAddressChangeError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftSenderAddressChangeError, buf: ByteBuffer) {
        when(value) {
            is DraftSenderAddressChangeError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftSenderAddressChangeErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftSenderAddressChangeError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class DraftSenderAddressChangeErrorReason {
    
    data class AddressEmailNotFound(
        val v1: kotlin.String) : DraftSenderAddressChangeErrorReason() {
        companion object
    }
    
    object AddressNotSendEnabled : DraftSenderAddressChangeErrorReason()
    
    
    object AddressDisabled : DraftSenderAddressChangeErrorReason()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftSenderAddressChangeErrorReason : FfiConverterRustBuffer<DraftSenderAddressChangeErrorReason>{
    override fun read(buf: ByteBuffer): DraftSenderAddressChangeErrorReason {
        return when(buf.getInt()) {
            1 -> DraftSenderAddressChangeErrorReason.AddressEmailNotFound(
                FfiConverterString.read(buf),
                )
            2 -> DraftSenderAddressChangeErrorReason.AddressNotSendEnabled
            3 -> DraftSenderAddressChangeErrorReason.AddressDisabled
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftSenderAddressChangeErrorReason) = when(value) {
        is DraftSenderAddressChangeErrorReason.AddressEmailNotFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is DraftSenderAddressChangeErrorReason.AddressNotSendEnabled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DraftSenderAddressChangeErrorReason.AddressDisabled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: DraftSenderAddressChangeErrorReason, buf: ByteBuffer) {
        when(value) {
            is DraftSenderAddressChangeErrorReason.AddressEmailNotFound -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DraftSenderAddressChangeErrorReason.AddressNotSendEnabled -> {
                buf.putInt(2)
                Unit
            }
            is DraftSenderAddressChangeErrorReason.AddressDisabled -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class DraftSyncStatus {
    
    CACHED,
    SYNCED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftSyncStatus: FfiConverterRustBuffer<DraftSyncStatus> {
    override fun read(buf: ByteBuffer) = try {
        DraftSyncStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftSyncStatus) = 4UL

    override fun write(value: DraftSyncStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftUndoSendError {
    
    data class Reason(
        val v1: DraftUndoSendErrorReason) : DraftUndoSendError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : DraftUndoSendError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftUndoSendError : FfiConverterRustBuffer<DraftUndoSendError>{
    override fun read(buf: ByteBuffer): DraftUndoSendError {
        return when(buf.getInt()) {
            1 -> DraftUndoSendError.Reason(
                FfiConverterTypeDraftUndoSendErrorReason.read(buf),
                )
            2 -> DraftUndoSendError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftUndoSendError) = when(value) {
        is DraftUndoSendError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftUndoSendErrorReason.allocationSize(value.v1)
            )
        }
        is DraftUndoSendError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftUndoSendError, buf: ByteBuffer) {
        when(value) {
            is DraftUndoSendError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeDraftUndoSendErrorReason.write(value.v1, buf)
                Unit
            }
            is DraftUndoSendError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason when attempting to cancel sending of an already sent draft.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * while saving or sending a draft in order to provide only the necessary
 * information to the user.
 */

enum class DraftUndoSendErrorReason {
    
    /**
     * Can not undo sent this message
     */
    MESSAGE_CAN_NOT_BE_UNDO_SENT,
    /**
     * The cancellation of sending for this message is no longer possible.
     */
    SEND_CAN_NO_LONGER_BE_UNDONE,
    /**
     * This message no longer exists.
     */
    MESSAGE_DOES_NOT_EXIST;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeDraftUndoSendErrorReason: FfiConverterRustBuffer<DraftUndoSendErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        DraftUndoSendErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DraftUndoSendErrorReason) = 4UL

    override fun write(value: DraftUndoSendErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class DraftValidateRecipientsExpirationFeatureResult {
    
    data class Ok(
        val v1: DraftRecipientExpirationFeatureReport) : DraftValidateRecipientsExpirationFeatureResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : DraftValidateRecipientsExpirationFeatureResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDraftValidateRecipientsExpirationFeatureResult : FfiConverterRustBuffer<DraftValidateRecipientsExpirationFeatureResult>{
    override fun read(buf: ByteBuffer): DraftValidateRecipientsExpirationFeatureResult {
        return when(buf.getInt()) {
            1 -> DraftValidateRecipientsExpirationFeatureResult.Ok(
                FfiConverterTypeDraftRecipientExpirationFeatureReport.read(buf),
                )
            2 -> DraftValidateRecipientsExpirationFeatureResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftValidateRecipientsExpirationFeatureResult) = when(value) {
        is DraftValidateRecipientsExpirationFeatureResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftRecipientExpirationFeatureReport.allocationSize(value.v1)
            )
        }
        is DraftValidateRecipientsExpirationFeatureResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DraftValidateRecipientsExpirationFeatureResult, buf: ByteBuffer) {
        when(value) {
            is DraftValidateRecipientsExpirationFeatureResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftRecipientExpirationFeatureReport.write(value.v1, buf)
                Unit
            }
            is DraftValidateRecipientsExpirationFeatureResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class EarlyAccess(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    REGULAR(0u),
    /**
     * TODO: Document this variant.
     */
    BETA(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeEarlyAccess: FfiConverterRustBuffer<EarlyAccess> {
    override fun read(buf: ByteBuffer) = try {
        EarlyAccess.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: EarlyAccess) = 4UL

    override fun write(value: EarlyAccess, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class EventError {
    
    data class Reason(
        val v1: EventErrorReason) : EventError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : EventError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEventError : FfiConverterRustBuffer<EventError>{
    override fun read(buf: ByteBuffer): EventError {
        return when(buf.getInt()) {
            1 -> EventError.Reason(
                FfiConverterTypeEventErrorReason.read(buf),
                )
            2 -> EventError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EventError) = when(value) {
        is EventError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEventErrorReason.allocationSize(value.v1)
            )
        }
        is EventError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: EventError, buf: ByteBuffer) {
        when(value) {
            is EventError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeEventErrorReason.write(value.v1, buf)
                Unit
            }
            is EventError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason for error occurrence within Event Loop.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * in handling event loop related operations in order to provide only the necessary
 * information to the user.
 */

enum class EventErrorReason {
    
    REFRESH,
    SUBSCRIBER,
    CYCLIC_DEPENDENCY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeEventErrorReason: FfiConverterRustBuffer<EventErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        EventErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: EventErrorReason) = 4UL

    override fun write(value: EventErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ExclusiveLocation {
    
    data class System(
        val `name`: SystemLabel, 
        val `id`: Id) : ExclusiveLocation() {
        companion object
    }
    
    data class Custom(
        val `name`: kotlin.String, 
        val `id`: Id, 
        val `color`: LabelColor) : ExclusiveLocation() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeExclusiveLocation : FfiConverterRustBuffer<ExclusiveLocation>{
    override fun read(buf: ByteBuffer): ExclusiveLocation {
        return when(buf.getInt()) {
            1 -> ExclusiveLocation.System(
                FfiConverterTypeSystemLabel.read(buf),
                FfiConverterTypeId.read(buf),
                )
            2 -> ExclusiveLocation.Custom(
                FfiConverterString.read(buf),
                FfiConverterTypeId.read(buf),
                FfiConverterTypeLabelColor.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ExclusiveLocation) = when(value) {
        is ExclusiveLocation.System -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSystemLabel.allocationSize(value.`name`)
                + FfiConverterTypeId.allocationSize(value.`id`)
            )
        }
        is ExclusiveLocation.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`name`)
                + FfiConverterTypeId.allocationSize(value.`id`)
                + FfiConverterTypeLabelColor.allocationSize(value.`color`)
            )
        }
    }

    override fun write(value: ExclusiveLocation, buf: ByteBuffer) {
        when(value) {
            is ExclusiveLocation.System -> {
                buf.putInt(1)
                FfiConverterTypeSystemLabel.write(value.`name`, buf)
                FfiConverterTypeId.write(value.`id`, buf)
                Unit
            }
            is ExclusiveLocation.Custom -> {
                buf.putInt(2)
                FfiConverterString.write(value.`name`, buf)
                FfiConverterTypeId.write(value.`id`, buf)
                FfiConverterTypeLabelColor.write(value.`color`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class FidoLaunchResultStatus {
    
    SUCCESS,
    FAILURE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeFidoLaunchResultStatus: FfiConverterRustBuffer<FidoLaunchResultStatus> {
    override fun read(buf: ByteBuffer) = try {
        FidoLaunchResultStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: FidoLaunchResultStatus) = 4UL

    override fun write(value: FidoLaunchResultStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class FidoSignResultStatus {
    
    EMPTY,
    SUCCESS,
    USER_CANCELLED,
    FAILURE_NOT_SUPPORTED,
    FAILURE_INVALID_STATE,
    FAILURE_SECURITY,
    FAILURE_NETWORK,
    FAILURE_ABORT,
    FAILURE_TIMEOUT,
    FAILURE_ENCODING,
    FAILURE_CONSTRAINT,
    FAILURE_DATA,
    FAILURE_NOT_ALLOWED,
    FAILURE_ATTESTATION_NOT_PRIVATE,
    FAILURE_UNKNOWN,
    FAILURE_NO_RESPONSE,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeFidoSignResultStatus: FfiConverterRustBuffer<FidoSignResultStatus> {
    override fun read(buf: ByteBuffer) = try {
        FidoSignResultStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: FidoSignResultStatus) = 4UL

    override fun write(value: FidoSignResultStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class GenderKind {
    
    object Male : GenderKind()
    
    
    object Female : GenderKind()
    
    
    object Other : GenderKind()
    
    
    object NotApplicable : GenderKind()
    
    
    object Unknown : GenderKind()
    
    
    object None : GenderKind()
    
    
    data class String(
        val v1: kotlin.String) : GenderKind() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGenderKind : FfiConverterRustBuffer<GenderKind>{
    override fun read(buf: ByteBuffer): GenderKind {
        return when(buf.getInt()) {
            1 -> GenderKind.Male
            2 -> GenderKind.Female
            3 -> GenderKind.Other
            4 -> GenderKind.NotApplicable
            5 -> GenderKind.Unknown
            6 -> GenderKind.None
            7 -> GenderKind.String(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GenderKind) = when(value) {
        is GenderKind.Male -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.Female -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.NotApplicable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GenderKind.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GenderKind, buf: ByteBuffer) {
        when(value) {
            is GenderKind.Male -> {
                buf.putInt(1)
                Unit
            }
            is GenderKind.Female -> {
                buf.putInt(2)
                Unit
            }
            is GenderKind.Other -> {
                buf.putInt(3)
                Unit
            }
            is GenderKind.NotApplicable -> {
                buf.putInt(4)
                Unit
            }
            is GenderKind.Unknown -> {
                buf.putInt(5)
                Unit
            }
            is GenderKind.None -> {
                buf.putInt(6)
                Unit
            }
            is GenderKind.String -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class GetAutoDeleteBannerResult {
    
    data class Ok(
        val v1: AutoDeleteBanner?) : GetAutoDeleteBannerResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : GetAutoDeleteBannerResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetAutoDeleteBannerResult : FfiConverterRustBuffer<GetAutoDeleteBannerResult>{
    override fun read(buf: ByteBuffer): GetAutoDeleteBannerResult {
        return when(buf.getInt()) {
            1 -> GetAutoDeleteBannerResult.Ok(
                FfiConverterOptionalTypeAutoDeleteBanner.read(buf),
                )
            2 -> GetAutoDeleteBannerResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GetAutoDeleteBannerResult) = when(value) {
        is GetAutoDeleteBannerResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeAutoDeleteBanner.allocationSize(value.v1)
            )
        }
        is GetAutoDeleteBannerResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GetAutoDeleteBannerResult, buf: ByteBuffer) {
        when(value) {
            is GetAutoDeleteBannerResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeAutoDeleteBanner.write(value.v1, buf)
                Unit
            }
            is GetAutoDeleteBannerResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class GetContactDetailsResult {
    
    data class Ok(
        val v1: ContactDetailCard) : GetContactDetailsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : GetContactDetailsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetContactDetailsResult : FfiConverterRustBuffer<GetContactDetailsResult>{
    override fun read(buf: ByteBuffer): GetContactDetailsResult {
        return when(buf.getInt()) {
            1 -> GetContactDetailsResult.Ok(
                FfiConverterTypeContactDetailCard.read(buf),
                )
            2 -> GetContactDetailsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GetContactDetailsResult) = when(value) {
        is GetContactDetailsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContactDetailCard.allocationSize(value.v1)
            )
        }
        is GetContactDetailsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GetContactDetailsResult, buf: ByteBuffer) {
        when(value) {
            is GetContactDetailsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeContactDetailCard.write(value.v1, buf)
                Unit
            }
            is GetContactDetailsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class GetMessageBodyResult: Disposable  {
    
    data class Ok(
        val v1: DecryptedMessage) : GetMessageBodyResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : GetMessageBodyResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is GetMessageBodyResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is GetMessageBodyResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetMessageBodyResult : FfiConverterRustBuffer<GetMessageBodyResult>{
    override fun read(buf: ByteBuffer): GetMessageBodyResult {
        return when(buf.getInt()) {
            1 -> GetMessageBodyResult.Ok(
                FfiConverterTypeDecryptedMessage.read(buf),
                )
            2 -> GetMessageBodyResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GetMessageBodyResult) = when(value) {
        is GetMessageBodyResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedMessage.allocationSize(value.v1)
            )
        }
        is GetMessageBodyResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GetMessageBodyResult, buf: ByteBuffer) {
        when(value) {
            is GetMessageBodyResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDecryptedMessage.write(value.v1, buf)
                Unit
            }
            is GetMessageBodyResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class GetPrivacyInfoForMessageResult {
    
    data class Ok(
        val v1: PrivacyInfo) : GetPrivacyInfoForMessageResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : GetPrivacyInfoForMessageResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetPrivacyInfoForMessageResult : FfiConverterRustBuffer<GetPrivacyInfoForMessageResult>{
    override fun read(buf: ByteBuffer): GetPrivacyInfoForMessageResult {
        return when(buf.getInt()) {
            1 -> GetPrivacyInfoForMessageResult.Ok(
                FfiConverterTypePrivacyInfo.read(buf),
                )
            2 -> GetPrivacyInfoForMessageResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GetPrivacyInfoForMessageResult) = when(value) {
        is GetPrivacyInfoForMessageResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrivacyInfo.allocationSize(value.v1)
            )
        }
        is GetPrivacyInfoForMessageResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GetPrivacyInfoForMessageResult, buf: ByteBuffer) {
        when(value) {
            is GetPrivacyInfoForMessageResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePrivacyInfo.write(value.v1, buf)
                Unit
            }
            is GetPrivacyInfoForMessageResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class HiddenMessagesBanner {
    
    CONTAINS_TRASHED_MESSAGES,
    CONTAINS_NON_TRASHED_MESSAGES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeHiddenMessagesBanner: FfiConverterRustBuffer<HiddenMessagesBanner> {
    override fun read(buf: ByteBuffer) = try {
        HiddenMessagesBanner.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HiddenMessagesBanner) = 4UL

    override fun write(value: HiddenMessagesBanner, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class HumanVerificationScreenId {
    
    V3;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeHumanVerificationScreenId: FfiConverterRustBuffer<HumanVerificationScreenId> {
    override fun read(buf: ByteBuffer) = try {
        HumanVerificationScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HumanVerificationScreenId) = 4UL

    override fun write(value: HumanVerificationScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class HumanVerificationStatus {
    
    SUCCEEDED,
    FAILED,
    CANCELLED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeHumanVerificationStatus: FfiConverterRustBuffer<HumanVerificationStatus> {
    override fun read(buf: ByteBuffer) = try {
        HumanVerificationStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HumanVerificationStatus) = 4UL

    override fun write(value: HumanVerificationStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class HumanVerificationViewLoadingStatus {
    
    HTTP2XX,
    HTTP4XX,
    HTTP400,
    HTTP404,
    HTTP422,
    HTTP5XX,
    CONNECTION_ERROR,
    SSL_ERROR;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeHumanVerificationViewLoadingStatus: FfiConverterRustBuffer<HumanVerificationViewLoadingStatus> {
    override fun read(buf: ByteBuffer) = try {
        HumanVerificationViewLoadingStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HumanVerificationViewLoadingStatus) = 4UL

    override fun write(value: HumanVerificationViewLoadingStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ImagePolicy {
    
    /**
     * Swap image's protocol from `http` to `https` and allow the image to be
     * proxied through Proton severs (assuming user has this option enabled).
     */
    SAFE,
    /**
     * Load image as-is, without changing the protocol and without passing it
     * through the proxy.
     */
    UNSAFE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeImagePolicy: FfiConverterRustBuffer<ImagePolicy> {
    override fun read(buf: ByteBuffer) = try {
        ImagePolicy.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ImagePolicy) = 4UL

    override fun write(value: ImagePolicy, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class IncludeSwitch(val value: kotlin.UByte) {
    
    DEFAULT(0u),
    WITH_SPAM_AND_TRASH(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeIncludeSwitch: FfiConverterRustBuffer<IncludeSwitch> {
    override fun read(buf: ByteBuffer) = try {
        IncludeSwitch.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: IncludeSwitch) = 4UL

    override fun write(value: IncludeSwitch, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class IosShareExtInitDraftResult {
    
    data class Ok(
        val v1: kotlin.String) : IosShareExtInitDraftResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : IosShareExtInitDraftResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIosShareExtInitDraftResult : FfiConverterRustBuffer<IosShareExtInitDraftResult>{
    override fun read(buf: ByteBuffer): IosShareExtInitDraftResult {
        return when(buf.getInt()) {
            1 -> IosShareExtInitDraftResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> IosShareExtInitDraftResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: IosShareExtInitDraftResult) = when(value) {
        is IosShareExtInitDraftResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is IosShareExtInitDraftResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: IosShareExtInitDraftResult, buf: ByteBuffer) {
        when(value) {
            is IosShareExtInitDraftResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is IosShareExtInitDraftResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class IosShareExtSaveDraftResult {
    
    object Ok : IosShareExtSaveDraftResult()
    
    
    data class Error(
        val v1: ProtonError) : IosShareExtSaveDraftResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIosShareExtSaveDraftResult : FfiConverterRustBuffer<IosShareExtSaveDraftResult>{
    override fun read(buf: ByteBuffer): IosShareExtSaveDraftResult {
        return when(buf.getInt()) {
            1 -> IosShareExtSaveDraftResult.Ok
            2 -> IosShareExtSaveDraftResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: IosShareExtSaveDraftResult) = when(value) {
        is IosShareExtSaveDraftResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is IosShareExtSaveDraftResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: IosShareExtSaveDraftResult, buf: ByteBuffer) {
        when(value) {
            is IosShareExtSaveDraftResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is IosShareExtSaveDraftResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class IpAddr {
    
    data class V4(
        val v1: kotlin.String) : IpAddr() {
        companion object
    }
    
    data class V6(
        val v1: kotlin.String) : IpAddr() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIpAddr : FfiConverterRustBuffer<IpAddr>{
    override fun read(buf: ByteBuffer): IpAddr {
        return when(buf.getInt()) {
            1 -> IpAddr.V4(
                FfiConverterString.read(buf),
                )
            2 -> IpAddr.V6(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: IpAddr) = when(value) {
        is IpAddr.V4 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is IpAddr.V6 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: IpAddr, buf: ByteBuffer) {
        when(value) {
            is IpAddr.V4 -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is IpAddr.V6 -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class IsMessageSenderBlockedResult {
    
    data class Ok(
        val v1: kotlin.Boolean?) : IsMessageSenderBlockedResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : IsMessageSenderBlockedResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeIsMessageSenderBlockedResult : FfiConverterRustBuffer<IsMessageSenderBlockedResult>{
    override fun read(buf: ByteBuffer): IsMessageSenderBlockedResult {
        return when(buf.getInt()) {
            1 -> IsMessageSenderBlockedResult.Ok(
                FfiConverterOptionalBoolean.read(buf),
                )
            2 -> IsMessageSenderBlockedResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: IsMessageSenderBlockedResult) = when(value) {
        is IsMessageSenderBlockedResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalBoolean.allocationSize(value.v1)
            )
        }
        is IsMessageSenderBlockedResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: IsMessageSenderBlockedResult, buf: ByteBuffer) {
        when(value) {
            is IsMessageSenderBlockedResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalBoolean.write(value.v1, buf)
                Unit
            }
            is IsMessageSenderBlockedResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * This enum represents the state of a selection.
 * Actions such as MoveAction or LabelAsAction should
 * be able to represent the state of its selection.

 */

enum class IsSelected {
    
    /**
     * All actions on any number of items are selected or not applied.
     */
    SELECTED,
    /**
     * All actions on any number of items are unselected (= not applied).
     */
    UNSELECTED,
    /**
     * Some actions on any number of items are selected, some are unselected.
     */
    PARTIAL;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeIsSelected: FfiConverterRustBuffer<IsSelected> {
    override fun read(buf: ByteBuffer) = try {
        IsSelected.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: IsSelected) = 4UL

    override fun write(value: IsSelected, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class LabelConversationsAsResult: Disposable  {
    
    data class Ok(
        val v1: LabelAsOutput) : LabelConversationsAsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : LabelConversationsAsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is LabelConversationsAsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is LabelConversationsAsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelConversationsAsResult : FfiConverterRustBuffer<LabelConversationsAsResult>{
    override fun read(buf: ByteBuffer): LabelConversationsAsResult {
        return when(buf.getInt()) {
            1 -> LabelConversationsAsResult.Ok(
                FfiConverterTypeLabelAsOutput.read(buf),
                )
            2 -> LabelConversationsAsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LabelConversationsAsResult) = when(value) {
        is LabelConversationsAsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLabelAsOutput.allocationSize(value.v1)
            )
        }
        is LabelConversationsAsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LabelConversationsAsResult, buf: ByteBuffer) {
        when(value) {
            is LabelConversationsAsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeLabelAsOutput.write(value.v1, buf)
                Unit
            }
            is LabelConversationsAsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Extended version of [`LabelType`].
 */
sealed class LabelDescription {
    
    object Label : LabelDescription()
    
    
    object ContactGroup : LabelDescription()
    
    
    object Folder : LabelDescription()
    
    
    data class System(
        val v1: SystemLabel?) : LabelDescription() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelDescription : FfiConverterRustBuffer<LabelDescription>{
    override fun read(buf: ByteBuffer): LabelDescription {
        return when(buf.getInt()) {
            1 -> LabelDescription.Label
            2 -> LabelDescription.ContactGroup
            3 -> LabelDescription.Folder
            4 -> LabelDescription.System(
                FfiConverterOptionalTypeSystemLabel.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LabelDescription) = when(value) {
        is LabelDescription.Label -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LabelDescription.ContactGroup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LabelDescription.Folder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LabelDescription.System -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeSystemLabel.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LabelDescription, buf: ByteBuffer) {
        when(value) {
            is LabelDescription.Label -> {
                buf.putInt(1)
                Unit
            }
            is LabelDescription.ContactGroup -> {
                buf.putInt(2)
                Unit
            }
            is LabelDescription.Folder -> {
                buf.putInt(3)
                Unit
            }
            is LabelDescription.System -> {
                buf.putInt(4)
                FfiConverterOptionalTypeSystemLabel.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class LabelMessagesAsResult: Disposable  {
    
    data class Ok(
        val v1: LabelAsOutput) : LabelMessagesAsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : LabelMessagesAsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is LabelMessagesAsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is LabelMessagesAsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelMessagesAsResult : FfiConverterRustBuffer<LabelMessagesAsResult>{
    override fun read(buf: ByteBuffer): LabelMessagesAsResult {
        return when(buf.getInt()) {
            1 -> LabelMessagesAsResult.Ok(
                FfiConverterTypeLabelAsOutput.read(buf),
                )
            2 -> LabelMessagesAsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LabelMessagesAsResult) = when(value) {
        is LabelMessagesAsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLabelAsOutput.allocationSize(value.v1)
            )
        }
        is LabelMessagesAsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LabelMessagesAsResult, buf: ByteBuffer) {
        when(value) {
            is LabelMessagesAsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeLabelAsOutput.write(value.v1, buf)
                Unit
            }
            is LabelMessagesAsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class LabelType(val value: kotlin.UByte) {
    
    LABEL(1u),
    CONTACT_GROUP(2u),
    FOLDER(3u),
    SYSTEM(4u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLabelType: FfiConverterRustBuffer<LabelType> {
    override fun read(buf: ByteBuffer) = try {
        LabelType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LabelType) = 4UL

    override fun write(value: LabelType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Enumeration grouping all possible actions for List Toolbar
 */
sealed class ListActions {
    
    object LabelAs : ListActions()
    
    
    object MarkRead : ListActions()
    
    
    object MarkUnread : ListActions()
    
    
    object More : ListActions()
    
    
    object MoveTo : ListActions()
    
    
    data class MoveToSystemFolder(
        val v1: MovableSystemFolderAction) : ListActions() {
        companion object
    }
    
    data class NotSpam(
        val v1: MovableSystemFolderAction) : ListActions() {
        companion object
    }
    
    object PermanentDelete : ListActions()
    
    
    object Star : ListActions()
    
    
    object Unstar : ListActions()
    
    
    object Snooze : ListActions()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeListActions : FfiConverterRustBuffer<ListActions>{
    override fun read(buf: ByteBuffer): ListActions {
        return when(buf.getInt()) {
            1 -> ListActions.LabelAs
            2 -> ListActions.MarkRead
            3 -> ListActions.MarkUnread
            4 -> ListActions.More
            5 -> ListActions.MoveTo
            6 -> ListActions.MoveToSystemFolder(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            7 -> ListActions.NotSpam(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            8 -> ListActions.PermanentDelete
            9 -> ListActions.Star
            10 -> ListActions.Unstar
            11 -> ListActions.Snooze
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ListActions) = when(value) {
        is ListActions.LabelAs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.MarkRead -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.MarkUnread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.More -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.MoveTo -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.MoveToSystemFolder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is ListActions.NotSpam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is ListActions.PermanentDelete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.Star -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.Unstar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ListActions.Snooze -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ListActions, buf: ByteBuffer) {
        when(value) {
            is ListActions.LabelAs -> {
                buf.putInt(1)
                Unit
            }
            is ListActions.MarkRead -> {
                buf.putInt(2)
                Unit
            }
            is ListActions.MarkUnread -> {
                buf.putInt(3)
                Unit
            }
            is ListActions.More -> {
                buf.putInt(4)
                Unit
            }
            is ListActions.MoveTo -> {
                buf.putInt(5)
                Unit
            }
            is ListActions.MoveToSystemFolder -> {
                buf.putInt(6)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is ListActions.NotSpam -> {
                buf.putInt(7)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is ListActions.PermanentDelete -> {
                buf.putInt(8)
                Unit
            }
            is ListActions.Star -> {
                buf.putInt(9)
                Unit
            }
            is ListActions.Unstar -> {
                buf.putInt(10)
                Unit
            }
            is ListActions.Snooze -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class LogAuth(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    DISABLED(0u),
    /**
     * TODO: Document this variant.
     */
    BASIC(1u),
    /**
     * TODO: Document this variant.
     */
    ADVANCED(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLogAuth: FfiConverterRustBuffer<LogAuth> {
    override fun read(buf: ByteBuffer) = try {
        LogAuth.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LogAuth) = 4UL

    override fun write(value: LogAuth, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class LoginScreenId {
    
    CHOOSE_INTERNAL_ADDRESS,
    SIGN_IN_WITH_SSO,
    SSO_IDENTITY_PROVIDER,
    SECOND_FACTOR,
    SIGN_IN_WITH_USERNAME_PASSWORD,
    MAILBOX_PASSWORD;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLoginScreenId: FfiConverterRustBuffer<LoginScreenId> {
    override fun read(buf: ByteBuffer) = try {
        LoginScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LoginScreenId) = 4UL

    override fun write(value: LoginScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MailConversationCursorFetchNextResult {
    
    data class Ok(
        val v1: Conversation?) : MailConversationCursorFetchNextResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MailConversationCursorFetchNextResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailConversationCursorFetchNextResult : FfiConverterRustBuffer<MailConversationCursorFetchNextResult>{
    override fun read(buf: ByteBuffer): MailConversationCursorFetchNextResult {
        return when(buf.getInt()) {
            1 -> MailConversationCursorFetchNextResult.Ok(
                FfiConverterOptionalTypeConversation.read(buf),
                )
            2 -> MailConversationCursorFetchNextResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailConversationCursorFetchNextResult) = when(value) {
        is MailConversationCursorFetchNextResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeConversation.allocationSize(value.v1)
            )
        }
        is MailConversationCursorFetchNextResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailConversationCursorFetchNextResult, buf: ByteBuffer) {
        when(value) {
            is MailConversationCursorFetchNextResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeConversation.write(value.v1, buf)
                Unit
            }
            is MailConversationCursorFetchNextResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailMessageCursorFetchNextResult {
    
    data class Ok(
        val v1: Message?) : MailMessageCursorFetchNextResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MailMessageCursorFetchNextResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailMessageCursorFetchNextResult : FfiConverterRustBuffer<MailMessageCursorFetchNextResult>{
    override fun read(buf: ByteBuffer): MailMessageCursorFetchNextResult {
        return when(buf.getInt()) {
            1 -> MailMessageCursorFetchNextResult.Ok(
                FfiConverterOptionalTypeMessage.read(buf),
                )
            2 -> MailMessageCursorFetchNextResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailMessageCursorFetchNextResult) = when(value) {
        is MailMessageCursorFetchNextResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeMessage.allocationSize(value.v1)
            )
        }
        is MailMessageCursorFetchNextResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailMessageCursorFetchNextResult, buf: ByteBuffer) {
        when(value) {
            is MailMessageCursorFetchNextResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeMessage.write(value.v1, buf)
                Unit
            }
            is MailMessageCursorFetchNextResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailScrollerError {
    
    data class Reason(
        val v1: MailScrollerErrorReason) : MailScrollerError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : MailScrollerError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailScrollerError : FfiConverterRustBuffer<MailScrollerError>{
    override fun read(buf: ByteBuffer): MailScrollerError {
        return when(buf.getInt()) {
            1 -> MailScrollerError.Reason(
                FfiConverterTypeMailScrollerErrorReason.read(buf),
                )
            2 -> MailScrollerError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailScrollerError) = when(value) {
        is MailScrollerError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerErrorReason.allocationSize(value.v1)
            )
        }
        is MailScrollerError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailScrollerError, buf: ByteBuffer) {
        when(value) {
            is MailScrollerError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeMailScrollerErrorReason.write(value.v1, buf)
                Unit
            }
            is MailScrollerError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MailScrollerErrorReason {
    
    NOT_SYNCED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMailScrollerErrorReason: FfiConverterRustBuffer<MailScrollerErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        MailScrollerErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MailScrollerErrorReason) = 4UL

    override fun write(value: MailScrollerErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MailSessionAppProtectionResult {
    
    data class Ok(
        val v1: AppProtection) : MailSessionAppProtectionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionAppProtectionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionAppProtectionResult : FfiConverterRustBuffer<MailSessionAppProtectionResult>{
    override fun read(buf: ByteBuffer): MailSessionAppProtectionResult {
        return when(buf.getInt()) {
            1 -> MailSessionAppProtectionResult.Ok(
                FfiConverterTypeAppProtection.read(buf),
                )
            2 -> MailSessionAppProtectionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionAppProtectionResult) = when(value) {
        is MailSessionAppProtectionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAppProtection.allocationSize(value.v1)
            )
        }
        is MailSessionAppProtectionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionAppProtectionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionAppProtectionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAppProtection.write(value.v1, buf)
                Unit
            }
            is MailSessionAppProtectionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionChangeAppSettingsResult {
    
    object Ok : MailSessionChangeAppSettingsResult()
    
    
    data class Error(
        val v1: UserSessionError) : MailSessionChangeAppSettingsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionChangeAppSettingsResult : FfiConverterRustBuffer<MailSessionChangeAppSettingsResult>{
    override fun read(buf: ByteBuffer): MailSessionChangeAppSettingsResult {
        return when(buf.getInt()) {
            1 -> MailSessionChangeAppSettingsResult.Ok
            2 -> MailSessionChangeAppSettingsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionChangeAppSettingsResult) = when(value) {
        is MailSessionChangeAppSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionChangeAppSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionChangeAppSettingsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionChangeAppSettingsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionChangeAppSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionDeletePinCodeResult {
    
    object Ok : MailSessionDeletePinCodeResult()
    
    
    data class Error(
        val v1: PinAuthError) : MailSessionDeletePinCodeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionDeletePinCodeResult : FfiConverterRustBuffer<MailSessionDeletePinCodeResult>{
    override fun read(buf: ByteBuffer): MailSessionDeletePinCodeResult {
        return when(buf.getInt()) {
            1 -> MailSessionDeletePinCodeResult.Ok
            2 -> MailSessionDeletePinCodeResult.Error(
                FfiConverterTypePinAuthError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionDeletePinCodeResult) = when(value) {
        is MailSessionDeletePinCodeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionDeletePinCodeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePinAuthError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionDeletePinCodeResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionDeletePinCodeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionDeletePinCodeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePinAuthError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionExportLogsResult {
    
    data class Ok(
        val v1: kotlin.ULong) : MailSessionExportLogsResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionExportLogsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionExportLogsResult : FfiConverterRustBuffer<MailSessionExportLogsResult>{
    override fun read(buf: ByteBuffer): MailSessionExportLogsResult {
        return when(buf.getInt()) {
            1 -> MailSessionExportLogsResult.Ok(
                FfiConverterULong.read(buf),
                )
            2 -> MailSessionExportLogsResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionExportLogsResult) = when(value) {
        is MailSessionExportLogsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is MailSessionExportLogsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionExportLogsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionExportLogsResult.Ok -> {
                buf.putInt(1)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is MailSessionExportLogsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetAccountResult: Disposable  {
    
    data class Ok(
        val v1: StoredAccount?) : MailSessionGetAccountResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetAccountResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetAccountResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetAccountResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetAccountResult : FfiConverterRustBuffer<MailSessionGetAccountResult>{
    override fun read(buf: ByteBuffer): MailSessionGetAccountResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetAccountResult.Ok(
                FfiConverterOptionalTypeStoredAccount.read(buf),
                )
            2 -> MailSessionGetAccountResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetAccountResult) = when(value) {
        is MailSessionGetAccountResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeStoredAccount.allocationSize(value.v1)
            )
        }
        is MailSessionGetAccountResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetAccountResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetAccountResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeStoredAccount.write(value.v1, buf)
                Unit
            }
            is MailSessionGetAccountResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetAccountSessionsResult: Disposable  {
    
    data class Ok(
        val v1: List<StoredSession>) : MailSessionGetAccountSessionsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetAccountSessionsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetAccountSessionsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetAccountSessionsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetAccountSessionsResult : FfiConverterRustBuffer<MailSessionGetAccountSessionsResult>{
    override fun read(buf: ByteBuffer): MailSessionGetAccountSessionsResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetAccountSessionsResult.Ok(
                FfiConverterSequenceTypeStoredSession.read(buf),
                )
            2 -> MailSessionGetAccountSessionsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetAccountSessionsResult) = when(value) {
        is MailSessionGetAccountSessionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeStoredSession.allocationSize(value.v1)
            )
        }
        is MailSessionGetAccountSessionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetAccountSessionsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetAccountSessionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeStoredSession.write(value.v1, buf)
                Unit
            }
            is MailSessionGetAccountSessionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetAccountStateResult {
    
    data class Ok(
        val v1: StoredAccountState?) : MailSessionGetAccountStateResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetAccountStateResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetAccountStateResult : FfiConverterRustBuffer<MailSessionGetAccountStateResult>{
    override fun read(buf: ByteBuffer): MailSessionGetAccountStateResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetAccountStateResult.Ok(
                FfiConverterOptionalTypeStoredAccountState.read(buf),
                )
            2 -> MailSessionGetAccountStateResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetAccountStateResult) = when(value) {
        is MailSessionGetAccountStateResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeStoredAccountState.allocationSize(value.v1)
            )
        }
        is MailSessionGetAccountStateResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetAccountStateResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetAccountStateResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeStoredAccountState.write(value.v1, buf)
                Unit
            }
            is MailSessionGetAccountStateResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetAccountsResult: Disposable  {
    
    data class Ok(
        val v1: List<StoredAccount>) : MailSessionGetAccountsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetAccountsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetAccountsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetAccountsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetAccountsResult : FfiConverterRustBuffer<MailSessionGetAccountsResult>{
    override fun read(buf: ByteBuffer): MailSessionGetAccountsResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetAccountsResult.Ok(
                FfiConverterSequenceTypeStoredAccount.read(buf),
                )
            2 -> MailSessionGetAccountsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetAccountsResult) = when(value) {
        is MailSessionGetAccountsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeStoredAccount.allocationSize(value.v1)
            )
        }
        is MailSessionGetAccountsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetAccountsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetAccountsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeStoredAccount.write(value.v1, buf)
                Unit
            }
            is MailSessionGetAccountsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetAppSettingsResult {
    
    data class Ok(
        val v1: AppSettings) : MailSessionGetAppSettingsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetAppSettingsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetAppSettingsResult : FfiConverterRustBuffer<MailSessionGetAppSettingsResult>{
    override fun read(buf: ByteBuffer): MailSessionGetAppSettingsResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetAppSettingsResult.Ok(
                FfiConverterTypeAppSettings.read(buf),
                )
            2 -> MailSessionGetAppSettingsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetAppSettingsResult) = when(value) {
        is MailSessionGetAppSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAppSettings.allocationSize(value.v1)
            )
        }
        is MailSessionGetAppSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetAppSettingsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetAppSettingsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAppSettings.write(value.v1, buf)
                Unit
            }
            is MailSessionGetAppSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetPrimaryAccountResult: Disposable  {
    
    data class Ok(
        val v1: StoredAccount?) : MailSessionGetPrimaryAccountResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetPrimaryAccountResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetPrimaryAccountResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetPrimaryAccountResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetPrimaryAccountResult : FfiConverterRustBuffer<MailSessionGetPrimaryAccountResult>{
    override fun read(buf: ByteBuffer): MailSessionGetPrimaryAccountResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetPrimaryAccountResult.Ok(
                FfiConverterOptionalTypeStoredAccount.read(buf),
                )
            2 -> MailSessionGetPrimaryAccountResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetPrimaryAccountResult) = when(value) {
        is MailSessionGetPrimaryAccountResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeStoredAccount.allocationSize(value.v1)
            )
        }
        is MailSessionGetPrimaryAccountResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetPrimaryAccountResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetPrimaryAccountResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeStoredAccount.write(value.v1, buf)
                Unit
            }
            is MailSessionGetPrimaryAccountResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetSessionResult: Disposable  {
    
    data class Ok(
        val v1: StoredSession?) : MailSessionGetSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetSessionResult : FfiConverterRustBuffer<MailSessionGetSessionResult>{
    override fun read(buf: ByteBuffer): MailSessionGetSessionResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetSessionResult.Ok(
                FfiConverterOptionalTypeStoredSession.read(buf),
                )
            2 -> MailSessionGetSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetSessionResult) = when(value) {
        is MailSessionGetSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeStoredSession.allocationSize(value.v1)
            )
        }
        is MailSessionGetSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetSessionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeStoredSession.write(value.v1, buf)
                Unit
            }
            is MailSessionGetSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetSessionStateResult {
    
    data class Ok(
        val v1: StoredSessionState?) : MailSessionGetSessionStateResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetSessionStateResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetSessionStateResult : FfiConverterRustBuffer<MailSessionGetSessionStateResult>{
    override fun read(buf: ByteBuffer): MailSessionGetSessionStateResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetSessionStateResult.Ok(
                FfiConverterOptionalTypeStoredSessionState.read(buf),
                )
            2 -> MailSessionGetSessionStateResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetSessionStateResult) = when(value) {
        is MailSessionGetSessionStateResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeStoredSessionState.allocationSize(value.v1)
            )
        }
        is MailSessionGetSessionStateResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetSessionStateResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetSessionStateResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeStoredSessionState.write(value.v1, buf)
                Unit
            }
            is MailSessionGetSessionStateResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionGetSessionsResult: Disposable  {
    
    data class Ok(
        val v1: List<StoredSession>) : MailSessionGetSessionsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionGetSessionsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionGetSessionsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionGetSessionsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionGetSessionsResult : FfiConverterRustBuffer<MailSessionGetSessionsResult>{
    override fun read(buf: ByteBuffer): MailSessionGetSessionsResult {
        return when(buf.getInt()) {
            1 -> MailSessionGetSessionsResult.Ok(
                FfiConverterSequenceTypeStoredSession.read(buf),
                )
            2 -> MailSessionGetSessionsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionGetSessionsResult) = when(value) {
        is MailSessionGetSessionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeStoredSession.allocationSize(value.v1)
            )
        }
        is MailSessionGetSessionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionGetSessionsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionGetSessionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeStoredSession.write(value.v1, buf)
                Unit
            }
            is MailSessionGetSessionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionInitializedUserSessionFromStoredSessionResult: Disposable  {
    
    data class Ok(
        val v1: MailUserSession?) : MailSessionInitializedUserSessionFromStoredSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionInitializedUserSessionFromStoredSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionInitializedUserSessionFromStoredSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionInitializedUserSessionFromStoredSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionInitializedUserSessionFromStoredSessionResult : FfiConverterRustBuffer<MailSessionInitializedUserSessionFromStoredSessionResult>{
    override fun read(buf: ByteBuffer): MailSessionInitializedUserSessionFromStoredSessionResult {
        return when(buf.getInt()) {
            1 -> MailSessionInitializedUserSessionFromStoredSessionResult.Ok(
                FfiConverterOptionalTypeMailUserSession.read(buf),
                )
            2 -> MailSessionInitializedUserSessionFromStoredSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionInitializedUserSessionFromStoredSessionResult) = when(value) {
        is MailSessionInitializedUserSessionFromStoredSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeMailUserSession.allocationSize(value.v1)
            )
        }
        is MailSessionInitializedUserSessionFromStoredSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionInitializedUserSessionFromStoredSessionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionInitializedUserSessionFromStoredSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeMailUserSession.write(value.v1, buf)
                Unit
            }
            is MailSessionInitializedUserSessionFromStoredSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionIsFeatureEnabledResult {
    
    data class Ok(
        val v1: kotlin.Boolean?) : MailSessionIsFeatureEnabledResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionIsFeatureEnabledResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionIsFeatureEnabledResult : FfiConverterRustBuffer<MailSessionIsFeatureEnabledResult>{
    override fun read(buf: ByteBuffer): MailSessionIsFeatureEnabledResult {
        return when(buf.getInt()) {
            1 -> MailSessionIsFeatureEnabledResult.Ok(
                FfiConverterOptionalBoolean.read(buf),
                )
            2 -> MailSessionIsFeatureEnabledResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionIsFeatureEnabledResult) = when(value) {
        is MailSessionIsFeatureEnabledResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalBoolean.allocationSize(value.v1)
            )
        }
        is MailSessionIsFeatureEnabledResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionIsFeatureEnabledResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionIsFeatureEnabledResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalBoolean.write(value.v1, buf)
                Unit
            }
            is MailSessionIsFeatureEnabledResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionNewLoginFlowResult: Disposable  {
    
    data class Ok(
        val v1: LoginFlow) : MailSessionNewLoginFlowResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionNewLoginFlowResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionNewLoginFlowResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionNewLoginFlowResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionNewLoginFlowResult : FfiConverterRustBuffer<MailSessionNewLoginFlowResult>{
    override fun read(buf: ByteBuffer): MailSessionNewLoginFlowResult {
        return when(buf.getInt()) {
            1 -> MailSessionNewLoginFlowResult.Ok(
                FfiConverterTypeLoginFlow.read(buf),
                )
            2 -> MailSessionNewLoginFlowResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionNewLoginFlowResult) = when(value) {
        is MailSessionNewLoginFlowResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginFlow.allocationSize(value.v1)
            )
        }
        is MailSessionNewLoginFlowResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionNewLoginFlowResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionNewLoginFlowResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeLoginFlow.write(value.v1, buf)
                Unit
            }
            is MailSessionNewLoginFlowResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionNewSignupFlowResult: Disposable  {
    
    data class Ok(
        val v1: SignupFlow) : MailSessionNewSignupFlowResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionNewSignupFlowResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionNewSignupFlowResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionNewSignupFlowResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionNewSignupFlowResult : FfiConverterRustBuffer<MailSessionNewSignupFlowResult>{
    override fun read(buf: ByteBuffer): MailSessionNewSignupFlowResult {
        return when(buf.getInt()) {
            1 -> MailSessionNewSignupFlowResult.Ok(
                FfiConverterTypeSignupFlow.read(buf),
                )
            2 -> MailSessionNewSignupFlowResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionNewSignupFlowResult) = when(value) {
        is MailSessionNewSignupFlowResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignupFlow.allocationSize(value.v1)
            )
        }
        is MailSessionNewSignupFlowResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionNewSignupFlowResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionNewSignupFlowResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSignupFlow.write(value.v1, buf)
                Unit
            }
            is MailSessionNewSignupFlowResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionRegisterDeviceTaskResult: Disposable  {
    
    data class Ok(
        val v1: RegisterDeviceTaskHandle) : MailSessionRegisterDeviceTaskResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MailSessionRegisterDeviceTaskResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionRegisterDeviceTaskResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionRegisterDeviceTaskResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionRegisterDeviceTaskResult : FfiConverterRustBuffer<MailSessionRegisterDeviceTaskResult>{
    override fun read(buf: ByteBuffer): MailSessionRegisterDeviceTaskResult {
        return when(buf.getInt()) {
            1 -> MailSessionRegisterDeviceTaskResult.Ok(
                FfiConverterTypeRegisterDeviceTaskHandle.read(buf),
                )
            2 -> MailSessionRegisterDeviceTaskResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionRegisterDeviceTaskResult) = when(value) {
        is MailSessionRegisterDeviceTaskResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRegisterDeviceTaskHandle.allocationSize(value.v1)
            )
        }
        is MailSessionRegisterDeviceTaskResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionRegisterDeviceTaskResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionRegisterDeviceTaskResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeRegisterDeviceTaskHandle.write(value.v1, buf)
                Unit
            }
            is MailSessionRegisterDeviceTaskResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionRemainingPinAttemptsResult {
    
    data class Ok(
        val v1: kotlin.UInt?) : MailSessionRemainingPinAttemptsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionRemainingPinAttemptsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionRemainingPinAttemptsResult : FfiConverterRustBuffer<MailSessionRemainingPinAttemptsResult>{
    override fun read(buf: ByteBuffer): MailSessionRemainingPinAttemptsResult {
        return when(buf.getInt()) {
            1 -> MailSessionRemainingPinAttemptsResult.Ok(
                FfiConverterOptionalUInt.read(buf),
                )
            2 -> MailSessionRemainingPinAttemptsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionRemainingPinAttemptsResult) = when(value) {
        is MailSessionRemainingPinAttemptsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalUInt.allocationSize(value.v1)
            )
        }
        is MailSessionRemainingPinAttemptsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionRemainingPinAttemptsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionRemainingPinAttemptsResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalUInt.write(value.v1, buf)
                Unit
            }
            is MailSessionRemainingPinAttemptsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionResumeLoginFlowResult: Disposable  {
    
    data class Ok(
        val v1: LoginFlow) : MailSessionResumeLoginFlowResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionResumeLoginFlowResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionResumeLoginFlowResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionResumeLoginFlowResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionResumeLoginFlowResult : FfiConverterRustBuffer<MailSessionResumeLoginFlowResult>{
    override fun read(buf: ByteBuffer): MailSessionResumeLoginFlowResult {
        return when(buf.getInt()) {
            1 -> MailSessionResumeLoginFlowResult.Ok(
                FfiConverterTypeLoginFlow.read(buf),
                )
            2 -> MailSessionResumeLoginFlowResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionResumeLoginFlowResult) = when(value) {
        is MailSessionResumeLoginFlowResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLoginFlow.allocationSize(value.v1)
            )
        }
        is MailSessionResumeLoginFlowResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionResumeLoginFlowResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionResumeLoginFlowResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeLoginFlow.write(value.v1, buf)
                Unit
            }
            is MailSessionResumeLoginFlowResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionSetBiometricsAppProtectionResult {
    
    object Ok : MailSessionSetBiometricsAppProtectionResult()
    
    
    data class Error(
        val v1: UserSessionError) : MailSessionSetBiometricsAppProtectionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionSetBiometricsAppProtectionResult : FfiConverterRustBuffer<MailSessionSetBiometricsAppProtectionResult>{
    override fun read(buf: ByteBuffer): MailSessionSetBiometricsAppProtectionResult {
        return when(buf.getInt()) {
            1 -> MailSessionSetBiometricsAppProtectionResult.Ok
            2 -> MailSessionSetBiometricsAppProtectionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionSetBiometricsAppProtectionResult) = when(value) {
        is MailSessionSetBiometricsAppProtectionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionSetBiometricsAppProtectionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionSetBiometricsAppProtectionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionSetBiometricsAppProtectionResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionSetBiometricsAppProtectionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionSetPinCodeResult {
    
    object Ok : MailSessionSetPinCodeResult()
    
    
    data class Error(
        val v1: PinSetError) : MailSessionSetPinCodeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionSetPinCodeResult : FfiConverterRustBuffer<MailSessionSetPinCodeResult>{
    override fun read(buf: ByteBuffer): MailSessionSetPinCodeResult {
        return when(buf.getInt()) {
            1 -> MailSessionSetPinCodeResult.Ok
            2 -> MailSessionSetPinCodeResult.Error(
                FfiConverterTypePinSetError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionSetPinCodeResult) = when(value) {
        is MailSessionSetPinCodeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionSetPinCodeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePinSetError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionSetPinCodeResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionSetPinCodeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionSetPinCodeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePinSetError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionShouldAutoLockResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : MailSessionShouldAutoLockResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionShouldAutoLockResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionShouldAutoLockResult : FfiConverterRustBuffer<MailSessionShouldAutoLockResult>{
    override fun read(buf: ByteBuffer): MailSessionShouldAutoLockResult {
        return when(buf.getInt()) {
            1 -> MailSessionShouldAutoLockResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> MailSessionShouldAutoLockResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionShouldAutoLockResult) = when(value) {
        is MailSessionShouldAutoLockResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is MailSessionShouldAutoLockResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionShouldAutoLockResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionShouldAutoLockResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is MailSessionShouldAutoLockResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionSignOutAllResult {
    
    object Ok : MailSessionSignOutAllResult()
    
    
    data class Error(
        val v1: UserSessionError) : MailSessionSignOutAllResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionSignOutAllResult : FfiConverterRustBuffer<MailSessionSignOutAllResult>{
    override fun read(buf: ByteBuffer): MailSessionSignOutAllResult {
        return when(buf.getInt()) {
            1 -> MailSessionSignOutAllResult.Ok
            2 -> MailSessionSignOutAllResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionSignOutAllResult) = when(value) {
        is MailSessionSignOutAllResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionSignOutAllResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionSignOutAllResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionSignOutAllResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionSignOutAllResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionStartBackgroundExecutionResult: Disposable  {
    
    data class Ok(
        val v1: BackgroundExecutionHandle) : MailSessionStartBackgroundExecutionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionStartBackgroundExecutionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionStartBackgroundExecutionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionStartBackgroundExecutionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionStartBackgroundExecutionResult : FfiConverterRustBuffer<MailSessionStartBackgroundExecutionResult>{
    override fun read(buf: ByteBuffer): MailSessionStartBackgroundExecutionResult {
        return when(buf.getInt()) {
            1 -> MailSessionStartBackgroundExecutionResult.Ok(
                FfiConverterTypeBackgroundExecutionHandle.read(buf),
                )
            2 -> MailSessionStartBackgroundExecutionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionStartBackgroundExecutionResult) = when(value) {
        is MailSessionStartBackgroundExecutionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBackgroundExecutionHandle.allocationSize(value.v1)
            )
        }
        is MailSessionStartBackgroundExecutionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionStartBackgroundExecutionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionStartBackgroundExecutionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeBackgroundExecutionHandle.write(value.v1, buf)
                Unit
            }
            is MailSessionStartBackgroundExecutionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionStartBackgroundExecutionWithDurationResult: Disposable  {
    
    data class Ok(
        val v1: BackgroundExecutionHandle) : MailSessionStartBackgroundExecutionWithDurationResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionStartBackgroundExecutionWithDurationResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionStartBackgroundExecutionWithDurationResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionStartBackgroundExecutionWithDurationResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionStartBackgroundExecutionWithDurationResult : FfiConverterRustBuffer<MailSessionStartBackgroundExecutionWithDurationResult>{
    override fun read(buf: ByteBuffer): MailSessionStartBackgroundExecutionWithDurationResult {
        return when(buf.getInt()) {
            1 -> MailSessionStartBackgroundExecutionWithDurationResult.Ok(
                FfiConverterTypeBackgroundExecutionHandle.read(buf),
                )
            2 -> MailSessionStartBackgroundExecutionWithDurationResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionStartBackgroundExecutionWithDurationResult) = when(value) {
        is MailSessionStartBackgroundExecutionWithDurationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBackgroundExecutionHandle.allocationSize(value.v1)
            )
        }
        is MailSessionStartBackgroundExecutionWithDurationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionStartBackgroundExecutionWithDurationResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionStartBackgroundExecutionWithDurationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeBackgroundExecutionHandle.write(value.v1, buf)
                Unit
            }
            is MailSessionStartBackgroundExecutionWithDurationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionToPrimaryUserSessionResult: Disposable  {
    
    data class Ok(
        val v1: MailUserSession) : MailSessionToPrimaryUserSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionToPrimaryUserSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionToPrimaryUserSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionToPrimaryUserSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionToPrimaryUserSessionResult : FfiConverterRustBuffer<MailSessionToPrimaryUserSessionResult>{
    override fun read(buf: ByteBuffer): MailSessionToPrimaryUserSessionResult {
        return when(buf.getInt()) {
            1 -> MailSessionToPrimaryUserSessionResult.Ok(
                FfiConverterTypeMailUserSession.read(buf),
                )
            2 -> MailSessionToPrimaryUserSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionToPrimaryUserSessionResult) = when(value) {
        is MailSessionToPrimaryUserSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailUserSession.allocationSize(value.v1)
            )
        }
        is MailSessionToPrimaryUserSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionToPrimaryUserSessionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionToPrimaryUserSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailUserSession.write(value.v1, buf)
                Unit
            }
            is MailSessionToPrimaryUserSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionToUserSessionResult: Disposable  {
    
    data class Ok(
        val v1: MailUserSession) : MailSessionToUserSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionToUserSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionToUserSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionToUserSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionToUserSessionResult : FfiConverterRustBuffer<MailSessionToUserSessionResult>{
    override fun read(buf: ByteBuffer): MailSessionToUserSessionResult {
        return when(buf.getInt()) {
            1 -> MailSessionToUserSessionResult.Ok(
                FfiConverterTypeMailUserSession.read(buf),
                )
            2 -> MailSessionToUserSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionToUserSessionResult) = when(value) {
        is MailSessionToUserSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailUserSession.allocationSize(value.v1)
            )
        }
        is MailSessionToUserSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionToUserSessionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionToUserSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailUserSession.write(value.v1, buf)
                Unit
            }
            is MailSessionToUserSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionUnsetBiometricsAppProtectionResult {
    
    object Ok : MailSessionUnsetBiometricsAppProtectionResult()
    
    
    data class Error(
        val v1: UserSessionError) : MailSessionUnsetBiometricsAppProtectionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionUnsetBiometricsAppProtectionResult : FfiConverterRustBuffer<MailSessionUnsetBiometricsAppProtectionResult>{
    override fun read(buf: ByteBuffer): MailSessionUnsetBiometricsAppProtectionResult {
        return when(buf.getInt()) {
            1 -> MailSessionUnsetBiometricsAppProtectionResult.Ok
            2 -> MailSessionUnsetBiometricsAppProtectionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionUnsetBiometricsAppProtectionResult) = when(value) {
        is MailSessionUnsetBiometricsAppProtectionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionUnsetBiometricsAppProtectionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionUnsetBiometricsAppProtectionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionUnsetBiometricsAppProtectionResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionUnsetBiometricsAppProtectionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionUserSessionFromStoredSessionResult: Disposable  {
    
    data class Ok(
        val v1: MailUserSession) : MailSessionUserSessionFromStoredSessionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionUserSessionFromStoredSessionResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionUserSessionFromStoredSessionResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionUserSessionFromStoredSessionResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionUserSessionFromStoredSessionResult : FfiConverterRustBuffer<MailSessionUserSessionFromStoredSessionResult>{
    override fun read(buf: ByteBuffer): MailSessionUserSessionFromStoredSessionResult {
        return when(buf.getInt()) {
            1 -> MailSessionUserSessionFromStoredSessionResult.Ok(
                FfiConverterTypeMailUserSession.read(buf),
                )
            2 -> MailSessionUserSessionFromStoredSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionUserSessionFromStoredSessionResult) = when(value) {
        is MailSessionUserSessionFromStoredSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailUserSession.allocationSize(value.v1)
            )
        }
        is MailSessionUserSessionFromStoredSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionUserSessionFromStoredSessionResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionUserSessionFromStoredSessionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailUserSession.write(value.v1, buf)
                Unit
            }
            is MailSessionUserSessionFromStoredSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionVerifyPinCodeResult {
    
    object Ok : MailSessionVerifyPinCodeResult()
    
    
    data class Error(
        val v1: PinAuthError) : MailSessionVerifyPinCodeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionVerifyPinCodeResult : FfiConverterRustBuffer<MailSessionVerifyPinCodeResult>{
    override fun read(buf: ByteBuffer): MailSessionVerifyPinCodeResult {
        return when(buf.getInt()) {
            1 -> MailSessionVerifyPinCodeResult.Ok
            2 -> MailSessionVerifyPinCodeResult.Error(
                FfiConverterTypePinAuthError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionVerifyPinCodeResult) = when(value) {
        is MailSessionVerifyPinCodeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailSessionVerifyPinCodeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePinAuthError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionVerifyPinCodeResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionVerifyPinCodeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailSessionVerifyPinCodeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypePinAuthError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchAccountSessionsResult: Disposable  {
    
    data class Ok(
        val v1: WatchedSessions) : MailSessionWatchAccountSessionsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionWatchAccountSessionsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchAccountSessionsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchAccountSessionsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchAccountSessionsResult : FfiConverterRustBuffer<MailSessionWatchAccountSessionsResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchAccountSessionsResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchAccountSessionsResult.Ok(
                FfiConverterTypeWatchedSessions.read(buf),
                )
            2 -> MailSessionWatchAccountSessionsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchAccountSessionsResult) = when(value) {
        is MailSessionWatchAccountSessionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedSessions.allocationSize(value.v1)
            )
        }
        is MailSessionWatchAccountSessionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchAccountSessionsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchAccountSessionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedSessions.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchAccountSessionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchAccountsAsyncResult: Disposable  {
    
    data class Ok(
        val v1: WatchedAccounts) : MailSessionWatchAccountsAsyncResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionWatchAccountsAsyncResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchAccountsAsyncResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchAccountsAsyncResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchAccountsAsyncResult : FfiConverterRustBuffer<MailSessionWatchAccountsAsyncResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchAccountsAsyncResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchAccountsAsyncResult.Ok(
                FfiConverterTypeWatchedAccounts.read(buf),
                )
            2 -> MailSessionWatchAccountsAsyncResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchAccountsAsyncResult) = when(value) {
        is MailSessionWatchAccountsAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedAccounts.allocationSize(value.v1)
            )
        }
        is MailSessionWatchAccountsAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchAccountsAsyncResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchAccountsAsyncResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedAccounts.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchAccountsAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchAccountsResult: Disposable  {
    
    data class Ok(
        val v1: WatchedAccounts) : MailSessionWatchAccountsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionWatchAccountsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchAccountsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchAccountsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchAccountsResult : FfiConverterRustBuffer<MailSessionWatchAccountsResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchAccountsResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchAccountsResult.Ok(
                FfiConverterTypeWatchedAccounts.read(buf),
                )
            2 -> MailSessionWatchAccountsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchAccountsResult) = when(value) {
        is MailSessionWatchAccountsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedAccounts.allocationSize(value.v1)
            )
        }
        is MailSessionWatchAccountsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchAccountsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchAccountsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedAccounts.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchAccountsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchFeatureFlagsAsyncResult: Disposable  {
    
    data class Ok(
        val v1: WatchedFeatureFlags) : MailSessionWatchFeatureFlagsAsyncResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionWatchFeatureFlagsAsyncResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchFeatureFlagsAsyncResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchFeatureFlagsAsyncResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchFeatureFlagsAsyncResult : FfiConverterRustBuffer<MailSessionWatchFeatureFlagsAsyncResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchFeatureFlagsAsyncResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchFeatureFlagsAsyncResult.Ok(
                FfiConverterTypeWatchedFeatureFlags.read(buf),
                )
            2 -> MailSessionWatchFeatureFlagsAsyncResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchFeatureFlagsAsyncResult) = when(value) {
        is MailSessionWatchFeatureFlagsAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedFeatureFlags.allocationSize(value.v1)
            )
        }
        is MailSessionWatchFeatureFlagsAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchFeatureFlagsAsyncResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchFeatureFlagsAsyncResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedFeatureFlags.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchFeatureFlagsAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchFeatureFlagsResult: Disposable  {
    
    data class Ok(
        val v1: WatchedFeatureFlags) : MailSessionWatchFeatureFlagsResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailSessionWatchFeatureFlagsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchFeatureFlagsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchFeatureFlagsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchFeatureFlagsResult : FfiConverterRustBuffer<MailSessionWatchFeatureFlagsResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchFeatureFlagsResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchFeatureFlagsResult.Ok(
                FfiConverterTypeWatchedFeatureFlags.read(buf),
                )
            2 -> MailSessionWatchFeatureFlagsResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchFeatureFlagsResult) = when(value) {
        is MailSessionWatchFeatureFlagsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedFeatureFlags.allocationSize(value.v1)
            )
        }
        is MailSessionWatchFeatureFlagsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchFeatureFlagsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchFeatureFlagsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedFeatureFlags.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchFeatureFlagsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchSessionsAsyncResult: Disposable  {
    
    data class Ok(
        val v1: WatchedSessions) : MailSessionWatchSessionsAsyncResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionWatchSessionsAsyncResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchSessionsAsyncResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchSessionsAsyncResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchSessionsAsyncResult : FfiConverterRustBuffer<MailSessionWatchSessionsAsyncResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchSessionsAsyncResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchSessionsAsyncResult.Ok(
                FfiConverterTypeWatchedSessions.read(buf),
                )
            2 -> MailSessionWatchSessionsAsyncResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchSessionsAsyncResult) = when(value) {
        is MailSessionWatchSessionsAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedSessions.allocationSize(value.v1)
            )
        }
        is MailSessionWatchSessionsAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchSessionsAsyncResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchSessionsAsyncResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedSessions.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchSessionsAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSessionWatchSessionsResult: Disposable  {
    
    data class Ok(
        val v1: WatchedSessions) : MailSessionWatchSessionsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSessionWatchSessionsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailSessionWatchSessionsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailSessionWatchSessionsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSessionWatchSessionsResult : FfiConverterRustBuffer<MailSessionWatchSessionsResult>{
    override fun read(buf: ByteBuffer): MailSessionWatchSessionsResult {
        return when(buf.getInt()) {
            1 -> MailSessionWatchSessionsResult.Ok(
                FfiConverterTypeWatchedSessions.read(buf),
                )
            2 -> MailSessionWatchSessionsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSessionWatchSessionsResult) = when(value) {
        is MailSessionWatchSessionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedSessions.allocationSize(value.v1)
            )
        }
        is MailSessionWatchSessionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSessionWatchSessionsResult, buf: ByteBuffer) {
        when(value) {
            is MailSessionWatchSessionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedSessions.write(value.v1, buf)
                Unit
            }
            is MailSessionWatchSessionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSettingsResult {
    
    data class Ok(
        val v1: MailSettings) : MailSettingsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSettingsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSettingsResult : FfiConverterRustBuffer<MailSettingsResult>{
    override fun read(buf: ByteBuffer): MailSettingsResult {
        return when(buf.getInt()) {
            1 -> MailSettingsResult.Ok(
                FfiConverterTypeMailSettings.read(buf),
                )
            2 -> MailSettingsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSettingsResult) = when(value) {
        is MailSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailSettings.allocationSize(value.v1)
            )
        }
        is MailSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSettingsResult, buf: ByteBuffer) {
        when(value) {
            is MailSettingsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailSettings.write(value.v1, buf)
                Unit
            }
            is MailSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailSettingsSyncResult {
    
    data class Ok(
        val v1: MailSettings) : MailSettingsSyncResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailSettingsSyncResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailSettingsSyncResult : FfiConverterRustBuffer<MailSettingsSyncResult>{
    override fun read(buf: ByteBuffer): MailSettingsSyncResult {
        return when(buf.getInt()) {
            1 -> MailSettingsSyncResult.Ok(
                FfiConverterTypeMailSettings.read(buf),
                )
            2 -> MailSettingsSyncResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailSettingsSyncResult) = when(value) {
        is MailSettingsSyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailSettings.allocationSize(value.v1)
            )
        }
        is MailSettingsSyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailSettingsSyncResult, buf: ByteBuffer) {
        when(value) {
            is MailSettingsSyncResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailSettings.write(value.v1, buf)
                Unit
            }
            is MailSettingsSyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MailTheme {
    
    LIGHT_MODE,
    DARK_MODE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMailTheme: FfiConverterRustBuffer<MailTheme> {
    override fun read(buf: ByteBuffer) = try {
        MailTheme.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MailTheme) = 4UL

    override fun write(value: MailTheme, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MailUserSessionAccountDetailsResult {
    
    data class Ok(
        val v1: AccountDetails) : MailUserSessionAccountDetailsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionAccountDetailsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionAccountDetailsResult : FfiConverterRustBuffer<MailUserSessionAccountDetailsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionAccountDetailsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionAccountDetailsResult.Ok(
                FfiConverterTypeAccountDetails.read(buf),
                )
            2 -> MailUserSessionAccountDetailsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionAccountDetailsResult) = when(value) {
        is MailUserSessionAccountDetailsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAccountDetails.allocationSize(value.v1)
            )
        }
        is MailUserSessionAccountDetailsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionAccountDetailsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionAccountDetailsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeAccountDetails.write(value.v1, buf)
                Unit
            }
            is MailUserSessionAccountDetailsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionApplicableLabelsResult {
    
    data class Ok(
        val v1: List<SidebarCustomLabel>) : MailUserSessionApplicableLabelsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionApplicableLabelsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionApplicableLabelsResult : FfiConverterRustBuffer<MailUserSessionApplicableLabelsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionApplicableLabelsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionApplicableLabelsResult.Ok(
                FfiConverterSequenceTypeSidebarCustomLabel.read(buf),
                )
            2 -> MailUserSessionApplicableLabelsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionApplicableLabelsResult) = when(value) {
        is MailUserSessionApplicableLabelsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarCustomLabel.allocationSize(value.v1)
            )
        }
        is MailUserSessionApplicableLabelsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionApplicableLabelsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionApplicableLabelsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarCustomLabel.write(value.v1, buf)
                Unit
            }
            is MailUserSessionApplicableLabelsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionConnectionStatusResult {
    
    data class Ok(
        val v1: ConnectionStatus) : MailUserSessionConnectionStatusResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionConnectionStatusResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionConnectionStatusResult : FfiConverterRustBuffer<MailUserSessionConnectionStatusResult>{
    override fun read(buf: ByteBuffer): MailUserSessionConnectionStatusResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionConnectionStatusResult.Ok(
                FfiConverterTypeConnectionStatus.read(buf),
                )
            2 -> MailUserSessionConnectionStatusResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionConnectionStatusResult) = when(value) {
        is MailUserSessionConnectionStatusResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConnectionStatus.allocationSize(value.v1)
            )
        }
        is MailUserSessionConnectionStatusResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionConnectionStatusResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionConnectionStatusResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeConnectionStatus.write(value.v1, buf)
                Unit
            }
            is MailUserSessionConnectionStatusResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionForkResult {
    
    data class Ok(
        val v1: kotlin.String) : MailUserSessionForkResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionForkResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionForkResult : FfiConverterRustBuffer<MailUserSessionForkResult>{
    override fun read(buf: ByteBuffer): MailUserSessionForkResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionForkResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> MailUserSessionForkResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionForkResult) = when(value) {
        is MailUserSessionForkResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is MailUserSessionForkResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionForkResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionForkResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MailUserSessionForkResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetAttachmentResult {
    
    data class Ok(
        val v1: DecryptedAttachment) : MailUserSessionGetAttachmentResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MailUserSessionGetAttachmentResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetAttachmentResult : FfiConverterRustBuffer<MailUserSessionGetAttachmentResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetAttachmentResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetAttachmentResult.Ok(
                FfiConverterTypeDecryptedAttachment.read(buf),
                )
            2 -> MailUserSessionGetAttachmentResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetAttachmentResult) = when(value) {
        is MailUserSessionGetAttachmentResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedAttachment.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetAttachmentResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetAttachmentResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetAttachmentResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDecryptedAttachment.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetAttachmentResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetPaymentMethodResult {
    
    data class Ok(
        val v1: PaymentMethod) : MailUserSessionGetPaymentMethodResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionGetPaymentMethodResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetPaymentMethodResult : FfiConverterRustBuffer<MailUserSessionGetPaymentMethodResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetPaymentMethodResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetPaymentMethodResult.Ok(
                FfiConverterTypePaymentMethod.read(buf),
                )
            2 -> MailUserSessionGetPaymentMethodResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetPaymentMethodResult) = when(value) {
        is MailUserSessionGetPaymentMethodResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentMethod.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetPaymentMethodResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetPaymentMethodResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetPaymentMethodResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePaymentMethod.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetPaymentMethodResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetPaymentsPlansResult {
    
    data class Ok(
        val v1: PaymentsPlans) : MailUserSessionGetPaymentsPlansResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionGetPaymentsPlansResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetPaymentsPlansResult : FfiConverterRustBuffer<MailUserSessionGetPaymentsPlansResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetPaymentsPlansResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetPaymentsPlansResult.Ok(
                FfiConverterTypePaymentsPlans.read(buf),
                )
            2 -> MailUserSessionGetPaymentsPlansResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetPaymentsPlansResult) = when(value) {
        is MailUserSessionGetPaymentsPlansResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentsPlans.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetPaymentsPlansResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetPaymentsPlansResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetPaymentsPlansResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePaymentsPlans.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetPaymentsPlansResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetPaymentsResourcesIconsResult {
    
    data class Ok(
        val v1: kotlin.ByteArray) : MailUserSessionGetPaymentsResourcesIconsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionGetPaymentsResourcesIconsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetPaymentsResourcesIconsResult : FfiConverterRustBuffer<MailUserSessionGetPaymentsResourcesIconsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetPaymentsResourcesIconsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetPaymentsResourcesIconsResult.Ok(
                FfiConverterByteArray.read(buf),
                )
            2 -> MailUserSessionGetPaymentsResourcesIconsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetPaymentsResourcesIconsResult) = when(value) {
        is MailUserSessionGetPaymentsResourcesIconsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterByteArray.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetPaymentsResourcesIconsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetPaymentsResourcesIconsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetPaymentsResourcesIconsResult.Ok -> {
                buf.putInt(1)
                FfiConverterByteArray.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetPaymentsResourcesIconsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetPaymentsStatusResult {
    
    data class Ok(
        val v1: PaymentsStatus) : MailUserSessionGetPaymentsStatusResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionGetPaymentsStatusResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetPaymentsStatusResult : FfiConverterRustBuffer<MailUserSessionGetPaymentsStatusResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetPaymentsStatusResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetPaymentsStatusResult.Ok(
                FfiConverterTypePaymentsStatus.read(buf),
                )
            2 -> MailUserSessionGetPaymentsStatusResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetPaymentsStatusResult) = when(value) {
        is MailUserSessionGetPaymentsStatusResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentsStatus.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetPaymentsStatusResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetPaymentsStatusResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetPaymentsStatusResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePaymentsStatus.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetPaymentsStatusResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionGetPaymentsSubscriptionResult {
    
    data class Ok(
        val v1: Subscriptions) : MailUserSessionGetPaymentsSubscriptionResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionGetPaymentsSubscriptionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionGetPaymentsSubscriptionResult : FfiConverterRustBuffer<MailUserSessionGetPaymentsSubscriptionResult>{
    override fun read(buf: ByteBuffer): MailUserSessionGetPaymentsSubscriptionResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionGetPaymentsSubscriptionResult.Ok(
                FfiConverterTypeSubscriptions.read(buf),
                )
            2 -> MailUserSessionGetPaymentsSubscriptionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionGetPaymentsSubscriptionResult) = when(value) {
        is MailUserSessionGetPaymentsSubscriptionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSubscriptions.allocationSize(value.v1)
            )
        }
        is MailUserSessionGetPaymentsSubscriptionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionGetPaymentsSubscriptionResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionGetPaymentsSubscriptionResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSubscriptions.write(value.v1, buf)
                Unit
            }
            is MailUserSessionGetPaymentsSubscriptionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionHasValidSenderAddressResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : MailUserSessionHasValidSenderAddressResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionHasValidSenderAddressResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionHasValidSenderAddressResult : FfiConverterRustBuffer<MailUserSessionHasValidSenderAddressResult>{
    override fun read(buf: ByteBuffer): MailUserSessionHasValidSenderAddressResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionHasValidSenderAddressResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> MailUserSessionHasValidSenderAddressResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionHasValidSenderAddressResult) = when(value) {
        is MailUserSessionHasValidSenderAddressResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is MailUserSessionHasValidSenderAddressResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionHasValidSenderAddressResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionHasValidSenderAddressResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is MailUserSessionHasValidSenderAddressResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionImageForSenderResult {
    
    data class Ok(
        val v1: kotlin.String?) : MailUserSessionImageForSenderResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionImageForSenderResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionImageForSenderResult : FfiConverterRustBuffer<MailUserSessionImageForSenderResult>{
    override fun read(buf: ByteBuffer): MailUserSessionImageForSenderResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionImageForSenderResult.Ok(
                FfiConverterOptionalString.read(buf),
                )
            2 -> MailUserSessionImageForSenderResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionImageForSenderResult) = when(value) {
        is MailUserSessionImageForSenderResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.v1)
            )
        }
        is MailUserSessionImageForSenderResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionImageForSenderResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionImageForSenderResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalString.write(value.v1, buf)
                Unit
            }
            is MailUserSessionImageForSenderResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionIsFeatureEnabledResult {
    
    data class Ok(
        val v1: kotlin.Boolean?) : MailUserSessionIsFeatureEnabledResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionIsFeatureEnabledResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionIsFeatureEnabledResult : FfiConverterRustBuffer<MailUserSessionIsFeatureEnabledResult>{
    override fun read(buf: ByteBuffer): MailUserSessionIsFeatureEnabledResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionIsFeatureEnabledResult.Ok(
                FfiConverterOptionalBoolean.read(buf),
                )
            2 -> MailUserSessionIsFeatureEnabledResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionIsFeatureEnabledResult) = when(value) {
        is MailUserSessionIsFeatureEnabledResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalBoolean.allocationSize(value.v1)
            )
        }
        is MailUserSessionIsFeatureEnabledResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionIsFeatureEnabledResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionIsFeatureEnabledResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalBoolean.write(value.v1, buf)
                Unit
            }
            is MailUserSessionIsFeatureEnabledResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionMovableFoldersResult {
    
    data class Ok(
        val v1: List<SidebarCustomFolder>) : MailUserSessionMovableFoldersResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionMovableFoldersResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionMovableFoldersResult : FfiConverterRustBuffer<MailUserSessionMovableFoldersResult>{
    override fun read(buf: ByteBuffer): MailUserSessionMovableFoldersResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionMovableFoldersResult.Ok(
                FfiConverterSequenceTypeSidebarCustomFolder.read(buf),
                )
            2 -> MailUserSessionMovableFoldersResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionMovableFoldersResult) = when(value) {
        is MailUserSessionMovableFoldersResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarCustomFolder.allocationSize(value.v1)
            )
        }
        is MailUserSessionMovableFoldersResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionMovableFoldersResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionMovableFoldersResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarCustomFolder.write(value.v1, buf)
                Unit
            }
            is MailUserSessionMovableFoldersResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionNewPasswordChangeFlowResult: Disposable  {
    
    data class Ok(
        val v1: PasswordFlow) : MailUserSessionNewPasswordChangeFlowResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionNewPasswordChangeFlowResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionNewPasswordChangeFlowResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionNewPasswordChangeFlowResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionNewPasswordChangeFlowResult : FfiConverterRustBuffer<MailUserSessionNewPasswordChangeFlowResult>{
    override fun read(buf: ByteBuffer): MailUserSessionNewPasswordChangeFlowResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionNewPasswordChangeFlowResult.Ok(
                FfiConverterTypePasswordFlow.read(buf),
                )
            2 -> MailUserSessionNewPasswordChangeFlowResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionNewPasswordChangeFlowResult) = when(value) {
        is MailUserSessionNewPasswordChangeFlowResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePasswordFlow.allocationSize(value.v1)
            )
        }
        is MailUserSessionNewPasswordChangeFlowResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionNewPasswordChangeFlowResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionNewPasswordChangeFlowResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePasswordFlow.write(value.v1, buf)
                Unit
            }
            is MailUserSessionNewPasswordChangeFlowResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionObserveEventLoopErrorsResult: Disposable  {
    
    data class Ok(
        val v1: EventLoopErrorObserverHandle) : MailUserSessionObserveEventLoopErrorsResult() {
        companion object
    }
    
    data class Error(
        val v1: EventError) : MailUserSessionObserveEventLoopErrorsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionObserveEventLoopErrorsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionObserveEventLoopErrorsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionObserveEventLoopErrorsResult : FfiConverterRustBuffer<MailUserSessionObserveEventLoopErrorsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionObserveEventLoopErrorsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionObserveEventLoopErrorsResult.Ok(
                FfiConverterTypeEventLoopErrorObserverHandle.read(buf),
                )
            2 -> MailUserSessionObserveEventLoopErrorsResult.Error(
                FfiConverterTypeEventError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionObserveEventLoopErrorsResult) = when(value) {
        is MailUserSessionObserveEventLoopErrorsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEventLoopErrorObserverHandle.allocationSize(value.v1)
            )
        }
        is MailUserSessionObserveEventLoopErrorsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEventError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionObserveEventLoopErrorsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionObserveEventLoopErrorsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeEventLoopErrorObserverHandle.write(value.v1, buf)
                Unit
            }
            is MailUserSessionObserveEventLoopErrorsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeEventError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionOverrideUserFeatureFlagResult {
    
    object Ok : MailUserSessionOverrideUserFeatureFlagResult()
    
    
    data class Error(
        val v1: ActionError) : MailUserSessionOverrideUserFeatureFlagResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionOverrideUserFeatureFlagResult : FfiConverterRustBuffer<MailUserSessionOverrideUserFeatureFlagResult>{
    override fun read(buf: ByteBuffer): MailUserSessionOverrideUserFeatureFlagResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionOverrideUserFeatureFlagResult.Ok
            2 -> MailUserSessionOverrideUserFeatureFlagResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionOverrideUserFeatureFlagResult) = when(value) {
        is MailUserSessionOverrideUserFeatureFlagResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailUserSessionOverrideUserFeatureFlagResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionOverrideUserFeatureFlagResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionOverrideUserFeatureFlagResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailUserSessionOverrideUserFeatureFlagResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionPostPaymentsSubscriptionResult {
    
    object Ok : MailUserSessionPostPaymentsSubscriptionResult()
    
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionPostPaymentsSubscriptionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionPostPaymentsSubscriptionResult : FfiConverterRustBuffer<MailUserSessionPostPaymentsSubscriptionResult>{
    override fun read(buf: ByteBuffer): MailUserSessionPostPaymentsSubscriptionResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionPostPaymentsSubscriptionResult.Ok
            2 -> MailUserSessionPostPaymentsSubscriptionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionPostPaymentsSubscriptionResult) = when(value) {
        is MailUserSessionPostPaymentsSubscriptionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailUserSessionPostPaymentsSubscriptionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionPostPaymentsSubscriptionResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionPostPaymentsSubscriptionResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailUserSessionPostPaymentsSubscriptionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionPostPaymentsTokensResult {
    
    data class Ok(
        val v1: PaymentToken) : MailUserSessionPostPaymentsTokensResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionPostPaymentsTokensResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionPostPaymentsTokensResult : FfiConverterRustBuffer<MailUserSessionPostPaymentsTokensResult>{
    override fun read(buf: ByteBuffer): MailUserSessionPostPaymentsTokensResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionPostPaymentsTokensResult.Ok(
                FfiConverterTypePaymentToken.read(buf),
                )
            2 -> MailUserSessionPostPaymentsTokensResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionPostPaymentsTokensResult) = when(value) {
        is MailUserSessionPostPaymentsTokensResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentToken.allocationSize(value.v1)
            )
        }
        is MailUserSessionPostPaymentsTokensResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionPostPaymentsTokensResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionPostPaymentsTokensResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePaymentToken.write(value.v1, buf)
                Unit
            }
            is MailUserSessionPostPaymentsTokensResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionProcessTargetDeviceQrCodeResult {
    
    object Ok : MailUserSessionProcessTargetDeviceQrCodeResult()
    
    
    data class Error(
        val v1: ProcessTargetDeviceQrError) : MailUserSessionProcessTargetDeviceQrCodeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionProcessTargetDeviceQrCodeResult : FfiConverterRustBuffer<MailUserSessionProcessTargetDeviceQrCodeResult>{
    override fun read(buf: ByteBuffer): MailUserSessionProcessTargetDeviceQrCodeResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionProcessTargetDeviceQrCodeResult.Ok
            2 -> MailUserSessionProcessTargetDeviceQrCodeResult.Error(
                FfiConverterTypeProcessTargetDeviceQrError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionProcessTargetDeviceQrCodeResult) = when(value) {
        is MailUserSessionProcessTargetDeviceQrCodeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MailUserSessionProcessTargetDeviceQrCodeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProcessTargetDeviceQrError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionProcessTargetDeviceQrCodeResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionProcessTargetDeviceQrCodeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MailUserSessionProcessTargetDeviceQrCodeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProcessTargetDeviceQrError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionSessionIdResult {
    
    data class Ok(
        val v1: kotlin.String) : MailUserSessionSessionIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionSessionIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionSessionIdResult : FfiConverterRustBuffer<MailUserSessionSessionIdResult>{
    override fun read(buf: ByteBuffer): MailUserSessionSessionIdResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionSessionIdResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> MailUserSessionSessionIdResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionSessionIdResult) = when(value) {
        is MailUserSessionSessionIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is MailUserSessionSessionIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionSessionIdResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionSessionIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MailUserSessionSessionIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionSessionUuidResult {
    
    data class Ok(
        val v1: kotlin.String) : MailUserSessionSessionUuidResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionSessionUuidResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionSessionUuidResult : FfiConverterRustBuffer<MailUserSessionSessionUuidResult>{
    override fun read(buf: ByteBuffer): MailUserSessionSessionUuidResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionSessionUuidResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> MailUserSessionSessionUuidResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionSessionUuidResult) = when(value) {
        is MailUserSessionSessionUuidResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is MailUserSessionSessionUuidResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionSessionUuidResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionSessionUuidResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MailUserSessionSessionUuidResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionUpsellEligibilityResult {
    
    data class Ok(
        val v1: UpsellEligibility) : MailUserSessionUpsellEligibilityResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionUpsellEligibilityResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionUpsellEligibilityResult : FfiConverterRustBuffer<MailUserSessionUpsellEligibilityResult>{
    override fun read(buf: ByteBuffer): MailUserSessionUpsellEligibilityResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionUpsellEligibilityResult.Ok(
                FfiConverterTypeUpsellEligibility.read(buf),
                )
            2 -> MailUserSessionUpsellEligibilityResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionUpsellEligibilityResult) = when(value) {
        is MailUserSessionUpsellEligibilityResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUpsellEligibility.allocationSize(value.v1)
            )
        }
        is MailUserSessionUpsellEligibilityResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionUpsellEligibilityResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionUpsellEligibilityResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeUpsellEligibility.write(value.v1, buf)
                Unit
            }
            is MailUserSessionUpsellEligibilityResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionUserIdResult {
    
    data class Ok(
        val v1: kotlin.String) : MailUserSessionUserIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionUserIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionUserIdResult : FfiConverterRustBuffer<MailUserSessionUserIdResult>{
    override fun read(buf: ByteBuffer): MailUserSessionUserIdResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionUserIdResult.Ok(
                FfiConverterString.read(buf),
                )
            2 -> MailUserSessionUserIdResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionUserIdResult) = when(value) {
        is MailUserSessionUserIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is MailUserSessionUserIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionUserIdResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionUserIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MailUserSessionUserIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionUserResult {
    
    data class Ok(
        val v1: User) : MailUserSessionUserResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionUserResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionUserResult : FfiConverterRustBuffer<MailUserSessionUserResult>{
    override fun read(buf: ByteBuffer): MailUserSessionUserResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionUserResult.Ok(
                FfiConverterTypeUser.read(buf),
                )
            2 -> MailUserSessionUserResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionUserResult) = when(value) {
        is MailUserSessionUserResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUser.allocationSize(value.v1)
            )
        }
        is MailUserSessionUserResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionUserResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionUserResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeUser.write(value.v1, buf)
                Unit
            }
            is MailUserSessionUserResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionUserSettingsResult {
    
    data class Ok(
        val v1: UserSettings) : MailUserSessionUserSettingsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailUserSessionUserSettingsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionUserSettingsResult : FfiConverterRustBuffer<MailUserSessionUserSettingsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionUserSettingsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionUserSettingsResult.Ok(
                FfiConverterTypeUserSettings.read(buf),
                )
            2 -> MailUserSessionUserSettingsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionUserSettingsResult) = when(value) {
        is MailUserSessionUserSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSettings.allocationSize(value.v1)
            )
        }
        is MailUserSessionUserSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionUserSettingsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionUserSettingsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeUserSettings.write(value.v1, buf)
                Unit
            }
            is MailUserSessionUserSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchAddressesResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : MailUserSessionWatchAddressesResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchAddressesResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchAddressesResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchAddressesResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchAddressesResult : FfiConverterRustBuffer<MailUserSessionWatchAddressesResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchAddressesResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchAddressesResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> MailUserSessionWatchAddressesResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchAddressesResult) = when(value) {
        is MailUserSessionWatchAddressesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchAddressesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchAddressesResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchAddressesResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchAddressesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchFeatureFlagsStreamResult: Disposable  {
    
    data class Ok(
        val v1: WatchUserFeatureFlagsStream) : MailUserSessionWatchFeatureFlagsStreamResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchFeatureFlagsStreamResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchFeatureFlagsStreamResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchFeatureFlagsStreamResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchFeatureFlagsStreamResult : FfiConverterRustBuffer<MailUserSessionWatchFeatureFlagsStreamResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchFeatureFlagsStreamResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchFeatureFlagsStreamResult.Ok(
                FfiConverterTypeWatchUserFeatureFlagsStream.read(buf),
                )
            2 -> MailUserSessionWatchFeatureFlagsStreamResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchFeatureFlagsStreamResult) = when(value) {
        is MailUserSessionWatchFeatureFlagsStreamResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchUserFeatureFlagsStream.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchFeatureFlagsStreamResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchFeatureFlagsStreamResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchFeatureFlagsStreamResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchUserFeatureFlagsStream.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchFeatureFlagsStreamResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchUpsellEligibilityResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : MailUserSessionWatchUpsellEligibilityResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchUpsellEligibilityResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchUpsellEligibilityResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchUpsellEligibilityResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchUpsellEligibilityResult : FfiConverterRustBuffer<MailUserSessionWatchUpsellEligibilityResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchUpsellEligibilityResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchUpsellEligibilityResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> MailUserSessionWatchUpsellEligibilityResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchUpsellEligibilityResult) = when(value) {
        is MailUserSessionWatchUpsellEligibilityResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchUpsellEligibilityResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchUpsellEligibilityResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchUpsellEligibilityResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchUpsellEligibilityResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchUserResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : MailUserSessionWatchUserResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchUserResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchUserResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchUserResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchUserResult : FfiConverterRustBuffer<MailUserSessionWatchUserResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchUserResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchUserResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> MailUserSessionWatchUserResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchUserResult) = when(value) {
        is MailUserSessionWatchUserResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchUserResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchUserResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchUserResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchUserResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchUserSettingsResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : MailUserSessionWatchUserSettingsResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchUserSettingsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchUserSettingsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchUserSettingsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchUserSettingsResult : FfiConverterRustBuffer<MailUserSessionWatchUserSettingsResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchUserSettingsResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchUserSettingsResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> MailUserSessionWatchUserSettingsResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchUserSettingsResult) = when(value) {
        is MailUserSessionWatchUserSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchUserSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchUserSettingsResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchUserSettingsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchUserSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailUserSessionWatchUserStreamResult: Disposable  {
    
    data class Ok(
        val v1: WatchUserStream) : MailUserSessionWatchUserStreamResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : MailUserSessionWatchUserStreamResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailUserSessionWatchUserStreamResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailUserSessionWatchUserStreamResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailUserSessionWatchUserStreamResult : FfiConverterRustBuffer<MailUserSessionWatchUserStreamResult>{
    override fun read(buf: ByteBuffer): MailUserSessionWatchUserStreamResult {
        return when(buf.getInt()) {
            1 -> MailUserSessionWatchUserStreamResult.Ok(
                FfiConverterTypeWatchUserStream.read(buf),
                )
            2 -> MailUserSessionWatchUserStreamResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailUserSessionWatchUserStreamResult) = when(value) {
        is MailUserSessionWatchUserStreamResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchUserStream.allocationSize(value.v1)
            )
        }
        is MailUserSessionWatchUserStreamResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailUserSessionWatchUserStreamResult, buf: ByteBuffer) {
        when(value) {
            is MailUserSessionWatchUserStreamResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchUserStream.write(value.v1, buf)
                Unit
            }
            is MailUserSessionWatchUserStreamResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailboxGetAttachmentResult {
    
    data class Ok(
        val v1: DecryptedAttachment) : MailboxGetAttachmentResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MailboxGetAttachmentResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailboxGetAttachmentResult : FfiConverterRustBuffer<MailboxGetAttachmentResult>{
    override fun read(buf: ByteBuffer): MailboxGetAttachmentResult {
        return when(buf.getInt()) {
            1 -> MailboxGetAttachmentResult.Ok(
                FfiConverterTypeDecryptedAttachment.read(buf),
                )
            2 -> MailboxGetAttachmentResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailboxGetAttachmentResult) = when(value) {
        is MailboxGetAttachmentResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDecryptedAttachment.allocationSize(value.v1)
            )
        }
        is MailboxGetAttachmentResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailboxGetAttachmentResult, buf: ByteBuffer) {
        when(value) {
            is MailboxGetAttachmentResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDecryptedAttachment.write(value.v1, buf)
                Unit
            }
            is MailboxGetAttachmentResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailboxUnreadCountResult {
    
    data class Ok(
        val v1: kotlin.ULong) : MailboxUnreadCountResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailboxUnreadCountResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailboxUnreadCountResult : FfiConverterRustBuffer<MailboxUnreadCountResult>{
    override fun read(buf: ByteBuffer): MailboxUnreadCountResult {
        return when(buf.getInt()) {
            1 -> MailboxUnreadCountResult.Ok(
                FfiConverterULong.read(buf),
                )
            2 -> MailboxUnreadCountResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailboxUnreadCountResult) = when(value) {
        is MailboxUnreadCountResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is MailboxUnreadCountResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailboxUnreadCountResult, buf: ByteBuffer) {
        when(value) {
            is MailboxUnreadCountResult.Ok -> {
                buf.putInt(1)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is MailboxUnreadCountResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MailboxWatchUnreadCountResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : MailboxWatchUnreadCountResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : MailboxWatchUnreadCountResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MailboxWatchUnreadCountResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MailboxWatchUnreadCountResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMailboxWatchUnreadCountResult : FfiConverterRustBuffer<MailboxWatchUnreadCountResult>{
    override fun read(buf: ByteBuffer): MailboxWatchUnreadCountResult {
        return when(buf.getInt()) {
            1 -> MailboxWatchUnreadCountResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> MailboxWatchUnreadCountResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MailboxWatchUnreadCountResult) = when(value) {
        is MailboxWatchUnreadCountResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is MailboxWatchUnreadCountResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MailboxWatchUnreadCountResult, buf: ByteBuffer) {
        when(value) {
            is MailboxWatchUnreadCountResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is MailboxWatchUnreadCountResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Enumeration grouping all possible actions for Message Toolbar
 */
sealed class MessageAction {
    
    object MarkRead : MessageAction()
    
    
    object MarkUnread : MessageAction()
    
    
    object Star : MessageAction()
    
    
    object Unstar : MessageAction()
    
    
    object LabelAs : MessageAction()
    
    
    object MoveTo : MessageAction()
    
    
    data class MoveToSystemFolder(
        val v1: MovableSystemFolderAction) : MessageAction() {
        companion object
    }
    
    data class NotSpam(
        val v1: MovableSystemFolderAction) : MessageAction() {
        companion object
    }
    
    object PermanentDelete : MessageAction()
    
    
    object Reply : MessageAction()
    
    
    object ReplyAll : MessageAction()
    
    
    object Forward : MessageAction()
    
    
    object Print : MessageAction()
    
    
    object ViewHeaders : MessageAction()
    
    
    object ViewHtml : MessageAction()
    
    
    object ViewInLightMode : MessageAction()
    
    
    object ViewInDarkMode : MessageAction()
    
    
    object ReportPhishing : MessageAction()
    
    
    object More : MessageAction()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageAction : FfiConverterRustBuffer<MessageAction>{
    override fun read(buf: ByteBuffer): MessageAction {
        return when(buf.getInt()) {
            1 -> MessageAction.MarkRead
            2 -> MessageAction.MarkUnread
            3 -> MessageAction.Star
            4 -> MessageAction.Unstar
            5 -> MessageAction.LabelAs
            6 -> MessageAction.MoveTo
            7 -> MessageAction.MoveToSystemFolder(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            8 -> MessageAction.NotSpam(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            9 -> MessageAction.PermanentDelete
            10 -> MessageAction.Reply
            11 -> MessageAction.ReplyAll
            12 -> MessageAction.Forward
            13 -> MessageAction.Print
            14 -> MessageAction.ViewHeaders
            15 -> MessageAction.ViewHtml
            16 -> MessageAction.ViewInLightMode
            17 -> MessageAction.ViewInDarkMode
            18 -> MessageAction.ReportPhishing
            19 -> MessageAction.More
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageAction) = when(value) {
        is MessageAction.MarkRead -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.MarkUnread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.Star -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.Unstar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.LabelAs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.MoveTo -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.MoveToSystemFolder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is MessageAction.NotSpam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is MessageAction.PermanentDelete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.Reply -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ReplyAll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.Forward -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.Print -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ViewHeaders -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ViewHtml -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ViewInLightMode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ViewInDarkMode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.ReportPhishing -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageAction.More -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: MessageAction, buf: ByteBuffer) {
        when(value) {
            is MessageAction.MarkRead -> {
                buf.putInt(1)
                Unit
            }
            is MessageAction.MarkUnread -> {
                buf.putInt(2)
                Unit
            }
            is MessageAction.Star -> {
                buf.putInt(3)
                Unit
            }
            is MessageAction.Unstar -> {
                buf.putInt(4)
                Unit
            }
            is MessageAction.LabelAs -> {
                buf.putInt(5)
                Unit
            }
            is MessageAction.MoveTo -> {
                buf.putInt(6)
                Unit
            }
            is MessageAction.MoveToSystemFolder -> {
                buf.putInt(7)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is MessageAction.NotSpam -> {
                buf.putInt(8)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is MessageAction.PermanentDelete -> {
                buf.putInt(9)
                Unit
            }
            is MessageAction.Reply -> {
                buf.putInt(10)
                Unit
            }
            is MessageAction.ReplyAll -> {
                buf.putInt(11)
                Unit
            }
            is MessageAction.Forward -> {
                buf.putInt(12)
                Unit
            }
            is MessageAction.Print -> {
                buf.putInt(13)
                Unit
            }
            is MessageAction.ViewHeaders -> {
                buf.putInt(14)
                Unit
            }
            is MessageAction.ViewHtml -> {
                buf.putInt(15)
                Unit
            }
            is MessageAction.ViewInLightMode -> {
                buf.putInt(16)
                Unit
            }
            is MessageAction.ViewInDarkMode -> {
                buf.putInt(17)
                Unit
            }
            is MessageAction.ReportPhishing -> {
                buf.putInt(18)
                Unit
            }
            is MessageAction.More -> {
                buf.putInt(19)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageBanner {
    
    object BlockedSender : MessageBanner()
    
    
    data class PhishingAttempt(
        /**
         * Whether the system or the user marked it as phishing.
         */
        val `auto`: kotlin.Boolean) : MessageBanner() {
        companion object
    }
    
    data class Spam(
        /**
         * Whether the system or the user marked it as phishing.
         */
        val `auto`: kotlin.Boolean) : MessageBanner() {
        companion object
    }
    
    data class Expiry(
        /**
         * The Unix timestamp indicating when the message expires.
         */
        val `timestamp`: UnixTimestamp) : MessageBanner() {
        companion object
    }
    
    data class AutoDelete(
        /**
         * The Unix timestamp indicating when the message will be deleted.
         */
        val `timestamp`: UnixTimestamp) : MessageBanner() {
        companion object
    }
    
    data class UnsubscribeNewsletter(
        val `alreadyUnsubscribed`: kotlin.Boolean) : MessageBanner() {
        companion object
    }
    
    data class ScheduledSend(
        /**
         * The Unix timestamp indicating when the message is scheduled to be sent.
         */
        val `timestamp`: UnixTimestamp) : MessageBanner() {
        companion object
    }
    
    data class Snoozed(
        /**
         * The Unix timestamp indicating when the message will reappear.
         */
        val `timestamp`: UnixTimestamp) : MessageBanner() {
        companion object
    }
    
    object EmbeddedImages : MessageBanner()
    
    
    object RemoteContent : MessageBanner()
    
    
    object UnableToDecrypt : MessageBanner()
    
    
    object DomainAuthFail : MessageBanner()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageBanner : FfiConverterRustBuffer<MessageBanner>{
    override fun read(buf: ByteBuffer): MessageBanner {
        return when(buf.getInt()) {
            1 -> MessageBanner.BlockedSender
            2 -> MessageBanner.PhishingAttempt(
                FfiConverterBoolean.read(buf),
                )
            3 -> MessageBanner.Spam(
                FfiConverterBoolean.read(buf),
                )
            4 -> MessageBanner.Expiry(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            5 -> MessageBanner.AutoDelete(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            6 -> MessageBanner.UnsubscribeNewsletter(
                FfiConverterBoolean.read(buf),
                )
            7 -> MessageBanner.ScheduledSend(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            8 -> MessageBanner.Snoozed(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            9 -> MessageBanner.EmbeddedImages
            10 -> MessageBanner.RemoteContent
            11 -> MessageBanner.UnableToDecrypt
            12 -> MessageBanner.DomainAuthFail
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageBanner) = when(value) {
        is MessageBanner.BlockedSender -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageBanner.PhishingAttempt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`auto`)
            )
        }
        is MessageBanner.Spam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`auto`)
            )
        }
        is MessageBanner.Expiry -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.`timestamp`)
            )
        }
        is MessageBanner.AutoDelete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.`timestamp`)
            )
        }
        is MessageBanner.UnsubscribeNewsletter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`alreadyUnsubscribed`)
            )
        }
        is MessageBanner.ScheduledSend -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.`timestamp`)
            )
        }
        is MessageBanner.Snoozed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.`timestamp`)
            )
        }
        is MessageBanner.EmbeddedImages -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageBanner.RemoteContent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageBanner.UnableToDecrypt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageBanner.DomainAuthFail -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: MessageBanner, buf: ByteBuffer) {
        when(value) {
            is MessageBanner.BlockedSender -> {
                buf.putInt(1)
                Unit
            }
            is MessageBanner.PhishingAttempt -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`auto`, buf)
                Unit
            }
            is MessageBanner.Spam -> {
                buf.putInt(3)
                FfiConverterBoolean.write(value.`auto`, buf)
                Unit
            }
            is MessageBanner.Expiry -> {
                buf.putInt(4)
                FfiConverterTypeUnixTimestamp.write(value.`timestamp`, buf)
                Unit
            }
            is MessageBanner.AutoDelete -> {
                buf.putInt(5)
                FfiConverterTypeUnixTimestamp.write(value.`timestamp`, buf)
                Unit
            }
            is MessageBanner.UnsubscribeNewsletter -> {
                buf.putInt(6)
                FfiConverterBoolean.write(value.`alreadyUnsubscribed`, buf)
                Unit
            }
            is MessageBanner.ScheduledSend -> {
                buf.putInt(7)
                FfiConverterTypeUnixTimestamp.write(value.`timestamp`, buf)
                Unit
            }
            is MessageBanner.Snoozed -> {
                buf.putInt(8)
                FfiConverterTypeUnixTimestamp.write(value.`timestamp`, buf)
                Unit
            }
            is MessageBanner.EmbeddedImages -> {
                buf.putInt(9)
                Unit
            }
            is MessageBanner.RemoteContent -> {
                buf.putInt(10)
                Unit
            }
            is MessageBanner.UnableToDecrypt -> {
                buf.putInt(11)
                Unit
            }
            is MessageBanner.DomainAuthFail -> {
                buf.putInt(12)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MessageButtons(val value: kotlin.UByte) {
    
    READ_FIRST(0u),
    UNREAD_FIRST(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageButtons: FfiConverterRustBuffer<MessageButtons> {
    override fun read(buf: ByteBuffer) = try {
        MessageButtons.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageButtons) = 4UL

    override fun write(value: MessageButtons, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MessageMetadataSortMode {
    
    TIME,
    SNOOZE_TIME,
    SIZE,
    ID;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageMetadataSortMode: FfiConverterRustBuffer<MessageMetadataSortMode> {
    override fun read(buf: ByteBuffer) = try {
        MessageMetadataSortMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageMetadataSortMode) = 4UL

    override fun write(value: MessageMetadataSortMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MessageMimeType(val value: kotlin.UByte) {
    
    TEXT_HTML(0u),
    TEXT_PLAIN(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageMimeType: FfiConverterRustBuffer<MessageMimeType> {
    override fun read(buf: ByteBuffer) = try {
        MessageMimeType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageMimeType) = 4UL

    override fun write(value: MessageMimeType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MessageRecipientDisplayMode {
    
    RECIPIENTS,
    SENDER;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageRecipientDisplayMode: FfiConverterRustBuffer<MessageRecipientDisplayMode> {
    override fun read(buf: ByteBuffer) = try {
        MessageRecipientDisplayMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageRecipientDisplayMode) = 4UL

    override fun write(value: MessageRecipientDisplayMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MessageResult {
    
    data class Ok(
        val v1: Message?) : MessageResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MessageResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageResult : FfiConverterRustBuffer<MessageResult>{
    override fun read(buf: ByteBuffer): MessageResult {
        return when(buf.getInt()) {
            1 -> MessageResult.Ok(
                FfiConverterOptionalTypeMessage.read(buf),
                )
            2 -> MessageResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageResult) = when(value) {
        is MessageResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeMessage.allocationSize(value.v1)
            )
        }
        is MessageResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageResult, buf: ByteBuffer) {
        when(value) {
            is MessageResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeMessage.write(value.v1, buf)
                Unit
            }
            is MessageResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerChangeFilterResult {
    
    object Ok : MessageScrollerChangeFilterResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerChangeFilterResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerChangeFilterResult : FfiConverterRustBuffer<MessageScrollerChangeFilterResult>{
    override fun read(buf: ByteBuffer): MessageScrollerChangeFilterResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerChangeFilterResult.Ok
            2 -> MessageScrollerChangeFilterResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerChangeFilterResult) = when(value) {
        is MessageScrollerChangeFilterResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerChangeFilterResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerChangeFilterResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerChangeFilterResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerChangeFilterResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerChangeIncludeResult {
    
    object Ok : MessageScrollerChangeIncludeResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerChangeIncludeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerChangeIncludeResult : FfiConverterRustBuffer<MessageScrollerChangeIncludeResult>{
    override fun read(buf: ByteBuffer): MessageScrollerChangeIncludeResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerChangeIncludeResult.Ok
            2 -> MessageScrollerChangeIncludeResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerChangeIncludeResult) = when(value) {
        is MessageScrollerChangeIncludeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerChangeIncludeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerChangeIncludeResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerChangeIncludeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerChangeIncludeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerCursorResult: Disposable  {
    
    data class Ok(
        val v1: MailMessageCursor) : MessageScrollerCursorResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerCursorResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MessageScrollerCursorResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MessageScrollerCursorResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerCursorResult : FfiConverterRustBuffer<MessageScrollerCursorResult>{
    override fun read(buf: ByteBuffer): MessageScrollerCursorResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerCursorResult.Ok(
                FfiConverterTypeMailMessageCursor.read(buf),
                )
            2 -> MessageScrollerCursorResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerCursorResult) = when(value) {
        is MessageScrollerCursorResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailMessageCursor.allocationSize(value.v1)
            )
        }
        is MessageScrollerCursorResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerCursorResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerCursorResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailMessageCursor.write(value.v1, buf)
                Unit
            }
            is MessageScrollerCursorResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerFetchMoreResult {
    
    object Ok : MessageScrollerFetchMoreResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerFetchMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerFetchMoreResult : FfiConverterRustBuffer<MessageScrollerFetchMoreResult>{
    override fun read(buf: ByteBuffer): MessageScrollerFetchMoreResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerFetchMoreResult.Ok
            2 -> MessageScrollerFetchMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerFetchMoreResult) = when(value) {
        is MessageScrollerFetchMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerFetchMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerFetchMoreResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerFetchMoreResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerFetchMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerFetchNewResult {
    
    object Ok : MessageScrollerFetchNewResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerFetchNewResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerFetchNewResult : FfiConverterRustBuffer<MessageScrollerFetchNewResult>{
    override fun read(buf: ByteBuffer): MessageScrollerFetchNewResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerFetchNewResult.Ok
            2 -> MessageScrollerFetchNewResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerFetchNewResult) = when(value) {
        is MessageScrollerFetchNewResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerFetchNewResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerFetchNewResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerFetchNewResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerFetchNewResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerForceRefreshResult {
    
    object Ok : MessageScrollerForceRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerForceRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerForceRefreshResult : FfiConverterRustBuffer<MessageScrollerForceRefreshResult>{
    override fun read(buf: ByteBuffer): MessageScrollerForceRefreshResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerForceRefreshResult.Ok
            2 -> MessageScrollerForceRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerForceRefreshResult) = when(value) {
        is MessageScrollerForceRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerForceRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerForceRefreshResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerForceRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerForceRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerGetItemsResult {
    
    object Ok : MessageScrollerGetItemsResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerGetItemsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerGetItemsResult : FfiConverterRustBuffer<MessageScrollerGetItemsResult>{
    override fun read(buf: ByteBuffer): MessageScrollerGetItemsResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerGetItemsResult.Ok
            2 -> MessageScrollerGetItemsResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerGetItemsResult) = when(value) {
        is MessageScrollerGetItemsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerGetItemsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerGetItemsResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerGetItemsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerGetItemsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerHasMoreResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : MessageScrollerHasMoreResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerHasMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerHasMoreResult : FfiConverterRustBuffer<MessageScrollerHasMoreResult>{
    override fun read(buf: ByteBuffer): MessageScrollerHasMoreResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerHasMoreResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> MessageScrollerHasMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerHasMoreResult) = when(value) {
        is MessageScrollerHasMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is MessageScrollerHasMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerHasMoreResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerHasMoreResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is MessageScrollerHasMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Like [`ConversationScrollerListUpdate`], but for messages.
 */
sealed class MessageScrollerListUpdate {
    
    data class None(
        val `scrollerId`: kotlin.String) : MessageScrollerListUpdate() {
        companion object
    }
    
    data class Append(
        val `scrollerId`: kotlin.String, 
        val `items`: List<Message>) : MessageScrollerListUpdate() {
        companion object
    }
    
    data class ReplaceFrom(
        val `scrollerId`: kotlin.String, 
        val `idx`: kotlin.ULong, 
        val `items`: List<Message>) : MessageScrollerListUpdate() {
        companion object
    }
    
    data class ReplaceBefore(
        val `scrollerId`: kotlin.String, 
        val `idx`: kotlin.ULong, 
        val `items`: List<Message>) : MessageScrollerListUpdate() {
        companion object
    }
    
    data class ReplaceRange(
        val `scrollerId`: kotlin.String, 
        val `from`: kotlin.ULong, 
        val `to`: kotlin.ULong, 
        val `items`: List<Message>) : MessageScrollerListUpdate() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerListUpdate : FfiConverterRustBuffer<MessageScrollerListUpdate>{
    override fun read(buf: ByteBuffer): MessageScrollerListUpdate {
        return when(buf.getInt()) {
            1 -> MessageScrollerListUpdate.None(
                FfiConverterString.read(buf),
                )
            2 -> MessageScrollerListUpdate.Append(
                FfiConverterString.read(buf),
                FfiConverterSequenceTypeMessage.read(buf),
                )
            3 -> MessageScrollerListUpdate.ReplaceFrom(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeMessage.read(buf),
                )
            4 -> MessageScrollerListUpdate.ReplaceBefore(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeMessage.read(buf),
                )
            5 -> MessageScrollerListUpdate.ReplaceRange(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeMessage.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerListUpdate) = when(value) {
        is MessageScrollerListUpdate.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
            )
        }
        is MessageScrollerListUpdate.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterSequenceTypeMessage.allocationSize(value.`items`)
            )
        }
        is MessageScrollerListUpdate.ReplaceFrom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`idx`)
                + FfiConverterSequenceTypeMessage.allocationSize(value.`items`)
            )
        }
        is MessageScrollerListUpdate.ReplaceBefore -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`idx`)
                + FfiConverterSequenceTypeMessage.allocationSize(value.`items`)
            )
        }
        is MessageScrollerListUpdate.ReplaceRange -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`scrollerId`)
                + FfiConverterULong.allocationSize(value.`from`)
                + FfiConverterULong.allocationSize(value.`to`)
                + FfiConverterSequenceTypeMessage.allocationSize(value.`items`)
            )
        }
    }

    override fun write(value: MessageScrollerListUpdate, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerListUpdate.None -> {
                buf.putInt(1)
                FfiConverterString.write(value.`scrollerId`, buf)
                Unit
            }
            is MessageScrollerListUpdate.Append -> {
                buf.putInt(2)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterSequenceTypeMessage.write(value.`items`, buf)
                Unit
            }
            is MessageScrollerListUpdate.ReplaceFrom -> {
                buf.putInt(3)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`idx`, buf)
                FfiConverterSequenceTypeMessage.write(value.`items`, buf)
                Unit
            }
            is MessageScrollerListUpdate.ReplaceBefore -> {
                buf.putInt(4)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`idx`, buf)
                FfiConverterSequenceTypeMessage.write(value.`items`, buf)
                Unit
            }
            is MessageScrollerListUpdate.ReplaceRange -> {
                buf.putInt(5)
                FfiConverterString.write(value.`scrollerId`, buf)
                FfiConverterULong.write(value.`from`, buf)
                FfiConverterULong.write(value.`to`, buf)
                FfiConverterSequenceTypeMessage.write(value.`items`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerRefreshResult {
    
    object Ok : MessageScrollerRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerRefreshResult : FfiConverterRustBuffer<MessageScrollerRefreshResult>{
    override fun read(buf: ByteBuffer): MessageScrollerRefreshResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerRefreshResult.Ok
            2 -> MessageScrollerRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerRefreshResult) = when(value) {
        is MessageScrollerRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageScrollerRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerRefreshResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is MessageScrollerRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MessageScrollerStatusUpdate {
    
    FETCH_NEW_START,
    FETCH_NEW_END;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerStatusUpdate: FfiConverterRustBuffer<MessageScrollerStatusUpdate> {
    override fun read(buf: ByteBuffer) = try {
        MessageScrollerStatusUpdate.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageScrollerStatusUpdate) = 4UL

    override fun write(value: MessageScrollerStatusUpdate, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MessageScrollerSupportsIncludeFilterResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : MessageScrollerSupportsIncludeFilterResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerSupportsIncludeFilterResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerSupportsIncludeFilterResult : FfiConverterRustBuffer<MessageScrollerSupportsIncludeFilterResult>{
    override fun read(buf: ByteBuffer): MessageScrollerSupportsIncludeFilterResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerSupportsIncludeFilterResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> MessageScrollerSupportsIncludeFilterResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerSupportsIncludeFilterResult) = when(value) {
        is MessageScrollerSupportsIncludeFilterResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is MessageScrollerSupportsIncludeFilterResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerSupportsIncludeFilterResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerSupportsIncludeFilterResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is MessageScrollerSupportsIncludeFilterResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerTotalResult {
    
    data class Ok(
        val v1: kotlin.ULong) : MessageScrollerTotalResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : MessageScrollerTotalResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerTotalResult : FfiConverterRustBuffer<MessageScrollerTotalResult>{
    override fun read(buf: ByteBuffer): MessageScrollerTotalResult {
        return when(buf.getInt()) {
            1 -> MessageScrollerTotalResult.Ok(
                FfiConverterULong.read(buf),
                )
            2 -> MessageScrollerTotalResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerTotalResult) = when(value) {
        is MessageScrollerTotalResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is MessageScrollerTotalResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageScrollerTotalResult, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerTotalResult.Ok -> {
                buf.putInt(1)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is MessageScrollerTotalResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageScrollerUpdate {
    
    data class List(
        val v1: MessageScrollerListUpdate) : MessageScrollerUpdate() {
        companion object
    }
    
    data class Status(
        val v1: MessageScrollerStatusUpdate) : MessageScrollerUpdate() {
        companion object
    }
    
    data class Error(
        val `error`: MailScrollerError) : MessageScrollerUpdate() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageScrollerUpdate : FfiConverterRustBuffer<MessageScrollerUpdate>{
    override fun read(buf: ByteBuffer): MessageScrollerUpdate {
        return when(buf.getInt()) {
            1 -> MessageScrollerUpdate.List(
                FfiConverterTypeMessageScrollerListUpdate.read(buf),
                )
            2 -> MessageScrollerUpdate.Status(
                FfiConverterTypeMessageScrollerStatusUpdate.read(buf),
                )
            3 -> MessageScrollerUpdate.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageScrollerUpdate) = when(value) {
        is MessageScrollerUpdate.List -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageScrollerListUpdate.allocationSize(value.v1)
            )
        }
        is MessageScrollerUpdate.Status -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageScrollerStatusUpdate.allocationSize(value.v1)
            )
        }
        is MessageScrollerUpdate.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: MessageScrollerUpdate, buf: ByteBuffer) {
        when(value) {
            is MessageScrollerUpdate.List -> {
                buf.putInt(1)
                FfiConverterTypeMessageScrollerListUpdate.write(value.v1, buf)
                Unit
            }
            is MessageScrollerUpdate.Status -> {
                buf.putInt(2)
                FfiConverterTypeMessageScrollerStatusUpdate.write(value.v1, buf)
                Unit
            }
            is MessageScrollerUpdate.Error -> {
                buf.putInt(3)
                FfiConverterTypeMailScrollerError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A set of tokens.
 *
 * This type represents the tokens held by the client.
 * Depending on the state of the client's auth session, it can be either
 * a single refresh token (which must be refreshed before use) or an access
 * token (and associated refresh token and scopes).
 */
sealed class MigrationTokens {
    
    /**
     * A single refresh token.
     *
     * This token must be refreshed before use;
     * once refreshed, it becomes an access token.
     */
    data class Refresh(
        /**
         * The refresh token's value.
         */
        val `refreshToken`: kotlin.String) : MigrationTokens() {
        companion object
    }
    
    /**
     * An access token.
     *
     * This token can be used to make authenticated requests to the Proton API.
     * It is associated with a refresh token, used to get a new access token
     * when the current one expires, and a set of scopes, which define the
     * permissions granted by the token.
     */
    data class Access(
        /**
         * The access token.
         */
        val `accessToken`: kotlin.String, 
        /**
         * The refresh token.
         */
        val `refreshToken`: kotlin.String) : MigrationTokens() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMigrationTokens : FfiConverterRustBuffer<MigrationTokens>{
    override fun read(buf: ByteBuffer): MigrationTokens {
        return when(buf.getInt()) {
            1 -> MigrationTokens.Refresh(
                FfiConverterString.read(buf),
                )
            2 -> MigrationTokens.Access(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MigrationTokens) = when(value) {
        is MigrationTokens.Refresh -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`refreshToken`)
            )
        }
        is MigrationTokens.Access -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`accessToken`)
                + FfiConverterString.allocationSize(value.`refreshToken`)
            )
        }
    }

    override fun write(value: MigrationTokens, buf: ByteBuffer) {
        when(value) {
            is MigrationTokens.Refresh -> {
                buf.putInt(1)
                FfiConverterString.write(value.`refreshToken`, buf)
                Unit
            }
            is MigrationTokens.Access -> {
                buf.putInt(2)
                FfiConverterString.write(value.`accessToken`, buf)
                FfiConverterString.write(value.`refreshToken`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MimeType(val value: kotlin.UByte) {
    
    APPLICATION_JSON(1u),
    APPLICATION_PDF(2u),
    MESSAGE_RFC822(3u),
    MULTIPART_MIXED(4u),
    MULTIPART_RELATED(5u),
    TEXT_HTML(6u),
    TEXT_PLAIN(7u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMimeType: FfiConverterRustBuffer<MimeType> {
    override fun read(buf: ByteBuffer) = try {
        MimeType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MimeType) = 4UL

    override fun write(value: MimeType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MimeTypeCategory {
    
    AUDIO,
    CALENDAR,
    CODE,
    COMPRESSED,
    DEFAULT,
    EXCEL,
    FONT,
    IMAGE,
    KEY,
    KEYNOTE,
    NUMBERS,
    PAGES,
    PDF,
    POWERPOINT,
    TEXT,
    VIDEO,
    WORD,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMimeTypeCategory: FfiConverterRustBuffer<MimeTypeCategory> {
    override fun read(buf: ByteBuffer) = try {
        MimeTypeCategory.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MimeTypeCategory) = 4UL

    override fun write(value: MimeTypeCategory, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MobileAction {
    
    ARCHIVE,
    FORWARD,
    LABEL,
    MOVE,
    PRINT,
    REPLY,
    REPORT_PHISHING,
    SNOOZE,
    SPAM,
    TOGGLE_LIGHT,
    TOGGLE_READ,
    TOGGLE_STAR,
    TRASH,
    VIEW_HEADERS,
    VIEW_HTML;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMobileAction: FfiConverterRustBuffer<MobileAction> {
    override fun read(buf: ByteBuffer) = try {
        MobileAction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MobileAction) = 4UL

    override fun write(value: MobileAction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MobileActionsResult {
    
    data class Ok(
        val v1: List<MobileAction>) : MobileActionsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MobileActionsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMobileActionsResult : FfiConverterRustBuffer<MobileActionsResult>{
    override fun read(buf: ByteBuffer): MobileActionsResult {
        return when(buf.getInt()) {
            1 -> MobileActionsResult.Ok(
                FfiConverterSequenceTypeMobileAction.read(buf),
                )
            2 -> MobileActionsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MobileActionsResult) = when(value) {
        is MobileActionsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeMobileAction.allocationSize(value.v1)
            )
        }
        is MobileActionsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MobileActionsResult, buf: ByteBuffer) {
        when(value) {
            is MobileActionsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeMobileAction.write(value.v1, buf)
                Unit
            }
            is MobileActionsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class MobileSignatureStatus {
    
    ENABLED,
    DISABLED,
    NEEDS_PAID_VERSION;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMobileSignatureStatus: FfiConverterRustBuffer<MobileSignatureStatus> {
    override fun read(buf: ByteBuffer) = try {
        MobileSignatureStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MobileSignatureStatus) = 4UL

    override fun write(value: MobileSignatureStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ModalVariant {
    
    COMPARISON;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeModalVariant: FfiConverterRustBuffer<ModalVariant> {
    override fun read(buf: ByteBuffer) = try {
        ModalVariant.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ModalVariant) = 4UL

    override fun write(value: ModalVariant, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * This enum represents the system labels that are valid target for Move actions.
 * Their values correspond to the remote ids of the labels in the core API database.
 */

enum class MovableSystemFolder(val value: kotlin.UByte) {
    
    INBOX(0u),
    TRASH(3u),
    SPAM(4u),
    ARCHIVE(6u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMovableSystemFolder: FfiConverterRustBuffer<MovableSystemFolder> {
    override fun read(buf: ByteBuffer) = try {
        MovableSystemFolder.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MovableSystemFolder) = 4UL

    override fun write(value: MovableSystemFolder, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * This enum represents the action of moving a message or conversation to a folder.

 */
sealed class MoveAction {
    
    /**
     * Move to a system folder (e.g. Inbox, Sent, Archive, Trash).
     */
    data class SystemFolder(
        val v1: MovableSystemFolderAction) : MoveAction() {
        companion object
    }
    
    /**
     * Move to a custom folder.
     */
    data class CustomFolder(
        val v1: CustomFolderAction) : MoveAction() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMoveAction : FfiConverterRustBuffer<MoveAction>{
    override fun read(buf: ByteBuffer): MoveAction {
        return when(buf.getInt()) {
            1 -> MoveAction.SystemFolder(
                FfiConverterTypeMovableSystemFolderAction.read(buf),
                )
            2 -> MoveAction.CustomFolder(
                FfiConverterTypeCustomFolderAction.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MoveAction) = when(value) {
        is MoveAction.SystemFolder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMovableSystemFolderAction.allocationSize(value.v1)
            )
        }
        is MoveAction.CustomFolder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCustomFolderAction.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MoveAction, buf: ByteBuffer) {
        when(value) {
            is MoveAction.SystemFolder -> {
                buf.putInt(1)
                FfiConverterTypeMovableSystemFolderAction.write(value.v1, buf)
                Unit
            }
            is MoveAction.CustomFolder -> {
                buf.putInt(2)
                FfiConverterTypeCustomFolderAction.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MoveConversationsResult: Disposable  {
    
    data class Ok(
        val v1: Undo?) : MoveConversationsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MoveConversationsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MoveConversationsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MoveConversationsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMoveConversationsResult : FfiConverterRustBuffer<MoveConversationsResult>{
    override fun read(buf: ByteBuffer): MoveConversationsResult {
        return when(buf.getInt()) {
            1 -> MoveConversationsResult.Ok(
                FfiConverterOptionalTypeUndo.read(buf),
                )
            2 -> MoveConversationsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MoveConversationsResult) = when(value) {
        is MoveConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeUndo.allocationSize(value.v1)
            )
        }
        is MoveConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MoveConversationsResult, buf: ByteBuffer) {
        when(value) {
            is MoveConversationsResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeUndo.write(value.v1, buf)
                Unit
            }
            is MoveConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MoveMessagesResult: Disposable  {
    
    data class Ok(
        val v1: Undo?) : MoveMessagesResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : MoveMessagesResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MoveMessagesResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MoveMessagesResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMoveMessagesResult : FfiConverterRustBuffer<MoveMessagesResult>{
    override fun read(buf: ByteBuffer): MoveMessagesResult {
        return when(buf.getInt()) {
            1 -> MoveMessagesResult.Ok(
                FfiConverterOptionalTypeUndo.read(buf),
                )
            2 -> MoveMessagesResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MoveMessagesResult) = when(value) {
        is MoveMessagesResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeUndo.allocationSize(value.v1)
            )
        }
        is MoveMessagesResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MoveMessagesResult, buf: ByteBuffer) {
        when(value) {
            is MoveMessagesResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeUndo.write(value.v1, buf)
                Unit
            }
            is MoveMessagesResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewAllMailMailboxResult: Disposable  {
    
    data class Ok(
        val v1: Mailbox) : NewAllMailMailboxResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : NewAllMailMailboxResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewAllMailMailboxResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewAllMailMailboxResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewAllMailMailboxResult : FfiConverterRustBuffer<NewAllMailMailboxResult>{
    override fun read(buf: ByteBuffer): NewAllMailMailboxResult {
        return when(buf.getInt()) {
            1 -> NewAllMailMailboxResult.Ok(
                FfiConverterTypeMailbox.read(buf),
                )
            2 -> NewAllMailMailboxResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewAllMailMailboxResult) = when(value) {
        is NewAllMailMailboxResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailbox.allocationSize(value.v1)
            )
        }
        is NewAllMailMailboxResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewAllMailMailboxResult, buf: ByteBuffer) {
        when(value) {
            is NewAllMailMailboxResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailbox.write(value.v1, buf)
                Unit
            }
            is NewAllMailMailboxResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewChallengeLoaderResult: Disposable  {
    
    data class Ok(
        val v1: ChallengeLoader) : NewChallengeLoaderResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : NewChallengeLoaderResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewChallengeLoaderResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewChallengeLoaderResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewChallengeLoaderResult : FfiConverterRustBuffer<NewChallengeLoaderResult>{
    override fun read(buf: ByteBuffer): NewChallengeLoaderResult {
        return when(buf.getInt()) {
            1 -> NewChallengeLoaderResult.Ok(
                FfiConverterTypeChallengeLoader.read(buf),
                )
            2 -> NewChallengeLoaderResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewChallengeLoaderResult) = when(value) {
        is NewChallengeLoaderResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeChallengeLoader.allocationSize(value.v1)
            )
        }
        is NewChallengeLoaderResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewChallengeLoaderResult, buf: ByteBuffer) {
        when(value) {
            is NewChallengeLoaderResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeChallengeLoader.write(value.v1, buf)
                Unit
            }
            is NewChallengeLoaderResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewDraftResult: Disposable  {
    
    data class Ok(
        val v1: Draft) : NewDraftResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftOpenError) : NewDraftResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewDraftResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewDraftResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewDraftResult : FfiConverterRustBuffer<NewDraftResult>{
    override fun read(buf: ByteBuffer): NewDraftResult {
        return when(buf.getInt()) {
            1 -> NewDraftResult.Ok(
                FfiConverterTypeDraft.read(buf),
                )
            2 -> NewDraftResult.Error(
                FfiConverterTypeDraftOpenError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewDraftResult) = when(value) {
        is NewDraftResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraft.allocationSize(value.v1)
            )
        }
        is NewDraftResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftOpenError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewDraftResult, buf: ByteBuffer) {
        when(value) {
            is NewDraftResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraft.write(value.v1, buf)
                Unit
            }
            is NewDraftResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftOpenError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewDraftSendWatcherResult: Disposable  {
    
    data class Ok(
        val v1: DraftSendResultWatcher) : NewDraftSendWatcherResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : NewDraftSendWatcherResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewDraftSendWatcherResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewDraftSendWatcherResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewDraftSendWatcherResult : FfiConverterRustBuffer<NewDraftSendWatcherResult>{
    override fun read(buf: ByteBuffer): NewDraftSendWatcherResult {
        return when(buf.getInt()) {
            1 -> NewDraftSendWatcherResult.Ok(
                FfiConverterTypeDraftSendResultWatcher.read(buf),
                )
            2 -> NewDraftSendWatcherResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewDraftSendWatcherResult) = when(value) {
        is NewDraftSendWatcherResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSendResultWatcher.allocationSize(value.v1)
            )
        }
        is NewDraftSendWatcherResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewDraftSendWatcherResult, buf: ByteBuffer) {
        when(value) {
            is NewDraftSendWatcherResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeDraftSendResultWatcher.write(value.v1, buf)
                Unit
            }
            is NewDraftSendWatcherResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewInboxMailboxResult: Disposable  {
    
    data class Ok(
        val v1: Mailbox) : NewInboxMailboxResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : NewInboxMailboxResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewInboxMailboxResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewInboxMailboxResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewInboxMailboxResult : FfiConverterRustBuffer<NewInboxMailboxResult>{
    override fun read(buf: ByteBuffer): NewInboxMailboxResult {
        return when(buf.getInt()) {
            1 -> NewInboxMailboxResult.Ok(
                FfiConverterTypeMailbox.read(buf),
                )
            2 -> NewInboxMailboxResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewInboxMailboxResult) = when(value) {
        is NewInboxMailboxResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailbox.allocationSize(value.v1)
            )
        }
        is NewInboxMailboxResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewInboxMailboxResult, buf: ByteBuffer) {
        when(value) {
            is NewInboxMailboxResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailbox.write(value.v1, buf)
                Unit
            }
            is NewInboxMailboxResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewMailboxResult: Disposable  {
    
    data class Ok(
        val v1: Mailbox) : NewMailboxResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : NewMailboxResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NewMailboxResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is NewMailboxResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewMailboxResult : FfiConverterRustBuffer<NewMailboxResult>{
    override fun read(buf: ByteBuffer): NewMailboxResult {
        return when(buf.getInt()) {
            1 -> NewMailboxResult.Ok(
                FfiConverterTypeMailbox.read(buf),
                )
            2 -> NewMailboxResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewMailboxResult) = when(value) {
        is NewMailboxResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailbox.allocationSize(value.v1)
            )
        }
        is NewMailboxResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewMailboxResult, buf: ByteBuffer) {
        when(value) {
            is NewMailboxResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailbox.write(value.v1, buf)
                Unit
            }
            is NewMailboxResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NextMailCursorConversation {
    
    object None : NextMailCursorConversation()
    
    
    data class Some(
        val v1: Conversation) : NextMailCursorConversation() {
        companion object
    }
    
    object Maybe : NextMailCursorConversation()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNextMailCursorConversation : FfiConverterRustBuffer<NextMailCursorConversation>{
    override fun read(buf: ByteBuffer): NextMailCursorConversation {
        return when(buf.getInt()) {
            1 -> NextMailCursorConversation.None
            2 -> NextMailCursorConversation.Some(
                FfiConverterTypeConversation.read(buf),
                )
            3 -> NextMailCursorConversation.Maybe
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NextMailCursorConversation) = when(value) {
        is NextMailCursorConversation.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NextMailCursorConversation.Some -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConversation.allocationSize(value.v1)
            )
        }
        is NextMailCursorConversation.Maybe -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: NextMailCursorConversation, buf: ByteBuffer) {
        when(value) {
            is NextMailCursorConversation.None -> {
                buf.putInt(1)
                Unit
            }
            is NextMailCursorConversation.Some -> {
                buf.putInt(2)
                FfiConverterTypeConversation.write(value.v1, buf)
                Unit
            }
            is NextMailCursorConversation.Maybe -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NextMailCursorMessage {
    
    object None : NextMailCursorMessage()
    
    
    data class Some(
        val v1: Message) : NextMailCursorMessage() {
        companion object
    }
    
    object Maybe : NextMailCursorMessage()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNextMailCursorMessage : FfiConverterRustBuffer<NextMailCursorMessage>{
    override fun read(buf: ByteBuffer): NextMailCursorMessage {
        return when(buf.getInt()) {
            1 -> NextMailCursorMessage.None
            2 -> NextMailCursorMessage.Some(
                FfiConverterTypeMessage.read(buf),
                )
            3 -> NextMailCursorMessage.Maybe
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NextMailCursorMessage) = when(value) {
        is NextMailCursorMessage.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NextMailCursorMessage.Some -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessage.allocationSize(value.v1)
            )
        }
        is NextMailCursorMessage.Maybe -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: NextMailCursorMessage, buf: ByteBuffer) {
        when(value) {
            is NextMailCursorMessage.None -> {
                buf.putInt(1)
                Unit
            }
            is NextMailCursorMessage.Some -> {
                buf.putInt(2)
                FfiConverterTypeMessage.write(value.v1, buf)
                Unit
            }
            is NextMailCursorMessage.Maybe -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class NextMessageOnMove(val value: kotlin.UByte) {
    
    DISABLED_EXPLICIT(0u),
    DISABLED_IMPLICIT(1u),
    ENABLED_EXPLICIT(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNextMessageOnMove: FfiConverterRustBuffer<NextMessageOnMove> {
    override fun read(buf: ByteBuffer) = try {
        NextMessageOnMove.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NextMessageOnMove) = 4UL

    override fun write(value: NextMessageOnMove, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class NonDefaultWeekStart(val value: kotlin.UByte) {
    
    MONDAY(1u),
    SATURDAY(6u),
    SUNDAY(7u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNonDefaultWeekStart: FfiConverterRustBuffer<NonDefaultWeekStart> {
    override fun read(buf: ByteBuffer) = try {
        NonDefaultWeekStart.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NonDefaultWeekStart) = 4UL

    override fun write(value: NonDefaultWeekStart, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * What is the kind of the data. OS key chains might support multiple
 * entries. This enum might be seen as a key in a `HashMap`.

 */

enum class OsKeyChainEntryKind {
    
    /**
     * Session key used to encrypt and decrypt sensitive data

     */
    ENCRYPTION_KEY,
    /**
     * Shared key between all accounts, used to decrypt push notifications

     */
    DEVICE_KEY,
    /**
     * App protection - PIN hash

     */
    PIN_HASH;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeOSKeyChainEntryKind: FfiConverterRustBuffer<OsKeyChainEntryKind> {
    override fun read(buf: ByteBuffer) = try {
        OsKeyChainEntryKind.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: OsKeyChainEntryKind) = 4UL

    override fun write(value: OsKeyChainEntryKind, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Errors for keychain operations.
 */
sealed class OsKeyChainException: kotlin.Exception() {
    
    /**
     * OS operation failed.
     */
    class Os(
        
        val v1: kotlin.String
        ) : OsKeyChainException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    /**
     * Some other error occurred.
     */
    class Other(
        
        val v1: kotlin.String
        ) : OsKeyChainException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<OsKeyChainException> {
        override fun lift(error_buf: RustBuffer.ByValue): OsKeyChainException = FfiConverterTypeOSKeyChainError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeOSKeyChainError : FfiConverterRustBuffer<OsKeyChainException> {
    override fun read(buf: ByteBuffer): OsKeyChainException {
        

        return when(buf.getInt()) {
            1 -> OsKeyChainException.Os(
                FfiConverterString.read(buf),
                )
            2 -> OsKeyChainException.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OsKeyChainException): ULong {
        return when(value) {
            is OsKeyChainException.Os -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is OsKeyChainException.Other -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: OsKeyChainException, buf: ByteBuffer) {
        when(value) {
            is OsKeyChainException.Os -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is OsKeyChainException.Other -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class OpenConversationOrigin {
    
    DEFAULT,
    PUSH_NOTIFICATION;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeOpenConversationOrigin: FfiConverterRustBuffer<OpenConversationOrigin> {
    override fun read(buf: ByteBuffer) = try {
        OpenConversationOrigin.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: OpenConversationOrigin) = 4UL

    override fun write(value: OpenConversationOrigin, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class OpenDraftResult: Disposable  {
    
    data class Ok(
        val v1: OpenDraft) : OpenDraftResult() {
        companion object
    }
    
    data class Error(
        val v1: DraftOpenError) : OpenDraftResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is OpenDraftResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is OpenDraftResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOpenDraftResult : FfiConverterRustBuffer<OpenDraftResult>{
    override fun read(buf: ByteBuffer): OpenDraftResult {
        return when(buf.getInt()) {
            1 -> OpenDraftResult.Ok(
                FfiConverterTypeOpenDraft.read(buf),
                )
            2 -> OpenDraftResult.Error(
                FfiConverterTypeDraftOpenError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OpenDraftResult) = when(value) {
        is OpenDraftResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeOpenDraft.allocationSize(value.v1)
            )
        }
        is OpenDraftResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftOpenError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: OpenDraftResult, buf: ByteBuffer) {
        when(value) {
            is OpenDraftResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeOpenDraft.write(value.v1, buf)
                Unit
            }
            is OpenDraftResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftOpenError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class Origin {
    
    APP,
    IOS_SHARE_EXT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeOrigin: FfiConverterRustBuffer<Origin> {
    override fun read(buf: ByteBuffer) = try {
        Origin.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Origin) = 4UL

    override fun write(value: Origin, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class OsNetworkStatus {
    
    ONLINE,
    OFFLINE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeOsNetworkStatus: FfiConverterRustBuffer<OsNetworkStatus> {
    override fun read(buf: ByteBuffer) = try {
        OsNetworkStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: OsNetworkStatus) = 4UL

    override fun write(value: OsNetworkStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Specific Reason for error occurrence within the application.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * in handling application related operations in order to provide a way to descirbe
 * common reasons across the application execution errors.
 */
sealed class OtherErrorReason {
    
    object InvalidParameter : OtherErrorReason()
    
    
    data class Other(
        val v1: kotlin.String) : OtherErrorReason() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOtherErrorReason : FfiConverterRustBuffer<OtherErrorReason>{
    override fun read(buf: ByteBuffer): OtherErrorReason {
        return when(buf.getInt()) {
            1 -> OtherErrorReason.InvalidParameter
            2 -> OtherErrorReason.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OtherErrorReason) = when(value) {
        is OtherErrorReason.InvalidParameter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherErrorReason.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: OtherErrorReason, buf: ByteBuffer) {
        when(value) {
            is OtherErrorReason.InvalidParameter -> {
                buf.putInt(1)
                Unit
            }
            is OtherErrorReason.Other -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ParsedHeaderValue {
    
    data class Array(
        val v1: List<kotlin.String>) : ParsedHeaderValue() {
        companion object
    }
    
    data class String(
        val v1: kotlin.String) : ParsedHeaderValue() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeParsedHeaderValue : FfiConverterRustBuffer<ParsedHeaderValue>{
    override fun read(buf: ByteBuffer): ParsedHeaderValue {
        return when(buf.getInt()) {
            1 -> ParsedHeaderValue.Array(
                FfiConverterSequenceString.read(buf),
                )
            2 -> ParsedHeaderValue.String(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ParsedHeaderValue) = when(value) {
        is ParsedHeaderValue.Array -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is ParsedHeaderValue.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ParsedHeaderValue, buf: ByteBuffer) {
        when(value) {
            is ParsedHeaderValue.Array -> {
                buf.putInt(1)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is ParsedHeaderValue.String -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PaymentMethodDetails {
    
    data class Card(
        val v1: PaymentMethodCardDetails) : PaymentMethodDetails() {
        companion object
    }
    
    data class Paypal(
        val v1: PaymentMethodPaypalDetails) : PaymentMethodDetails() {
        companion object
    }
    
    data class DirectDebit(
        val v1: PaymentMethodDirectDebitDetails) : PaymentMethodDetails() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethodDetails : FfiConverterRustBuffer<PaymentMethodDetails>{
    override fun read(buf: ByteBuffer): PaymentMethodDetails {
        return when(buf.getInt()) {
            1 -> PaymentMethodDetails.Card(
                FfiConverterTypePaymentMethodCardDetails.read(buf),
                )
            2 -> PaymentMethodDetails.Paypal(
                FfiConverterTypePaymentMethodPaypalDetails.read(buf),
                )
            3 -> PaymentMethodDetails.DirectDebit(
                FfiConverterTypePaymentMethodDirectDebitDetails.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentMethodDetails) = when(value) {
        is PaymentMethodDetails.Card -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentMethodCardDetails.allocationSize(value.v1)
            )
        }
        is PaymentMethodDetails.Paypal -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentMethodPaypalDetails.allocationSize(value.v1)
            )
        }
        is PaymentMethodDetails.DirectDebit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentMethodDirectDebitDetails.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PaymentMethodDetails, buf: ByteBuffer) {
        when(value) {
            is PaymentMethodDetails.Card -> {
                buf.putInt(1)
                FfiConverterTypePaymentMethodCardDetails.write(value.v1, buf)
                Unit
            }
            is PaymentMethodDetails.Paypal -> {
                buf.putInt(2)
                FfiConverterTypePaymentMethodPaypalDetails.write(value.v1, buf)
                Unit
            }
            is PaymentMethodDetails.DirectDebit -> {
                buf.putInt(3)
                FfiConverterTypePaymentMethodDirectDebitDetails.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PaymentObservabilityMetric {
    
    data class IapSubscribe(
        val v1: PaymentObservabilityResponse) : PaymentObservabilityMetric() {
        companion object
    }
    
    data class SendPaymentToken(
        val v1: PaymentObservabilityResponse) : PaymentObservabilityMetric() {
        companion object
    }
    
    data class CreateSubscription(
        val v1: PaymentObservabilityResponse) : PaymentObservabilityMetric() {
        companion object
    }
    
    data class GetSubscription(
        val v1: PaymentObservabilityResponse) : PaymentObservabilityMetric() {
        companion object
    }
    
    data class GetPlans(
        val v1: PaymentObservabilityResponse) : PaymentObservabilityMetric() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentObservabilityMetric : FfiConverterRustBuffer<PaymentObservabilityMetric>{
    override fun read(buf: ByteBuffer): PaymentObservabilityMetric {
        return when(buf.getInt()) {
            1 -> PaymentObservabilityMetric.IapSubscribe(
                FfiConverterTypePaymentObservabilityResponse.read(buf),
                )
            2 -> PaymentObservabilityMetric.SendPaymentToken(
                FfiConverterTypePaymentObservabilityResponse.read(buf),
                )
            3 -> PaymentObservabilityMetric.CreateSubscription(
                FfiConverterTypePaymentObservabilityResponse.read(buf),
                )
            4 -> PaymentObservabilityMetric.GetSubscription(
                FfiConverterTypePaymentObservabilityResponse.read(buf),
                )
            5 -> PaymentObservabilityMetric.GetPlans(
                FfiConverterTypePaymentObservabilityResponse.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentObservabilityMetric) = when(value) {
        is PaymentObservabilityMetric.IapSubscribe -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentObservabilityResponse.allocationSize(value.v1)
            )
        }
        is PaymentObservabilityMetric.SendPaymentToken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentObservabilityResponse.allocationSize(value.v1)
            )
        }
        is PaymentObservabilityMetric.CreateSubscription -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentObservabilityResponse.allocationSize(value.v1)
            )
        }
        is PaymentObservabilityMetric.GetSubscription -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentObservabilityResponse.allocationSize(value.v1)
            )
        }
        is PaymentObservabilityMetric.GetPlans -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePaymentObservabilityResponse.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PaymentObservabilityMetric, buf: ByteBuffer) {
        when(value) {
            is PaymentObservabilityMetric.IapSubscribe -> {
                buf.putInt(1)
                FfiConverterTypePaymentObservabilityResponse.write(value.v1, buf)
                Unit
            }
            is PaymentObservabilityMetric.SendPaymentToken -> {
                buf.putInt(2)
                FfiConverterTypePaymentObservabilityResponse.write(value.v1, buf)
                Unit
            }
            is PaymentObservabilityMetric.CreateSubscription -> {
                buf.putInt(3)
                FfiConverterTypePaymentObservabilityResponse.write(value.v1, buf)
                Unit
            }
            is PaymentObservabilityMetric.GetSubscription -> {
                buf.putInt(4)
                FfiConverterTypePaymentObservabilityResponse.write(value.v1, buf)
                Unit
            }
            is PaymentObservabilityMetric.GetPlans -> {
                buf.putInt(5)
                FfiConverterTypePaymentObservabilityResponse.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class PaymentObservabilityResponse {
    
    SUCCESS,
    HTTP4XX,
    HTTP5XX,
    SERIALIZATION_ERROR,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentObservabilityResponse: FfiConverterRustBuffer<PaymentObservabilityResponse> {
    override fun read(buf: ByteBuffer) = try {
        PaymentObservabilityResponse.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentObservabilityResponse) = 4UL

    override fun write(value: PaymentObservabilityResponse, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PaymentReceipt {
    
    data class AppleRecurring(
        val `details`: AppleRecurringReceiptDetails) : PaymentReceipt() {
        companion object
    }
    
    data class Google(
        val `details`: GoogleRecurringReceiptDetails) : PaymentReceipt() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentReceipt : FfiConverterRustBuffer<PaymentReceipt>{
    override fun read(buf: ByteBuffer): PaymentReceipt {
        return when(buf.getInt()) {
            1 -> PaymentReceipt.AppleRecurring(
                FfiConverterTypeAppleRecurringReceiptDetails.read(buf),
                )
            2 -> PaymentReceipt.Google(
                FfiConverterTypeGoogleRecurringReceiptDetails.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentReceipt) = when(value) {
        is PaymentReceipt.AppleRecurring -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAppleRecurringReceiptDetails.allocationSize(value.`details`)
            )
        }
        is PaymentReceipt.Google -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeGoogleRecurringReceiptDetails.allocationSize(value.`details`)
            )
        }
    }

    override fun write(value: PaymentReceipt, buf: ByteBuffer) {
        when(value) {
            is PaymentReceipt.AppleRecurring -> {
                buf.putInt(1)
                FfiConverterTypeAppleRecurringReceiptDetails.write(value.`details`, buf)
                Unit
            }
            is PaymentReceipt.Google -> {
                buf.putInt(2)
                FfiConverterTypeGoogleRecurringReceiptDetails.write(value.`details`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class PaymentVendorState {
    
    /**
     * Vendor is disabled.
     */
    DISABLED,
    /**
     * Vendor is enabled.
     */
    ENABLED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentVendorState: FfiConverterRustBuffer<PaymentVendorState> {
    override fun read(buf: ByteBuffer) = try {
        PaymentVendorState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentVendorState) = 4UL

    override fun write(value: PaymentVendorState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PgpScheme(val value: kotlin.UByte) {
    
    INLINE(8u),
    MIME(16u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePgpScheme: FfiConverterRustBuffer<PgpScheme> {
    override fun read(buf: ByteBuffer) = try {
        PgpScheme.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PgpScheme) = 4UL

    override fun write(value: PgpScheme, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PinAuthError {
    
    data class Reason(
        val v1: PinAuthErrorReason) : PinAuthError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : PinAuthError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePinAuthError : FfiConverterRustBuffer<PinAuthError>{
    override fun read(buf: ByteBuffer): PinAuthError {
        return when(buf.getInt()) {
            1 -> PinAuthError.Reason(
                FfiConverterTypePinAuthErrorReason.read(buf),
                )
            2 -> PinAuthError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PinAuthError) = when(value) {
        is PinAuthError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePinAuthErrorReason.allocationSize(value.v1)
            )
        }
        is PinAuthError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PinAuthError, buf: ByteBuffer) {
        when(value) {
            is PinAuthError.Reason -> {
                buf.putInt(1)
                FfiConverterTypePinAuthErrorReason.write(value.v1, buf)
                Unit
            }
            is PinAuthError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason for error occurrence while authenticating user with PIN

 */

enum class PinAuthErrorReason {
    
    TOO_MANY_ATTEMPTS,
    TOO_FREQUENT_ATTEMPTS,
    INCORRECT_PIN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePinAuthErrorReason: FfiConverterRustBuffer<PinAuthErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        PinAuthErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PinAuthErrorReason) = 4UL

    override fun write(value: PinAuthErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PinSetError {
    
    data class Reason(
        val v1: PinSetErrorReason) : PinSetError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : PinSetError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePinSetError : FfiConverterRustBuffer<PinSetError>{
    override fun read(buf: ByteBuffer): PinSetError {
        return when(buf.getInt()) {
            1 -> PinSetError.Reason(
                FfiConverterTypePinSetErrorReason.read(buf),
                )
            2 -> PinSetError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PinSetError) = when(value) {
        is PinSetError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePinSetErrorReason.allocationSize(value.v1)
            )
        }
        is PinSetError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PinSetError, buf: ByteBuffer) {
        when(value) {
            is PinSetError.Reason -> {
                buf.putInt(1)
                FfiConverterTypePinSetErrorReason.write(value.v1, buf)
                Unit
            }
            is PinSetError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason for error occurrence while creating user's PIN

 */

enum class PinSetErrorReason {
    
    TOO_SHORT,
    TOO_LONG,
    MALFORMED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePinSetErrorReason: FfiConverterRustBuffer<PinSetErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        PinSetErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PinSetErrorReason) = 4UL

    override fun write(value: PinSetErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Represents a plan decoration.
 */
sealed class PlanDecoration {
    
    data class Starred(
        val `iconName`: kotlin.String) : PlanDecoration() {
        companion object
    }
    
    data class Badge(
        val `text`: kotlin.String, 
        val `anchor`: kotlin.String, 
        val `planId`: kotlin.String) : PlanDecoration() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanDecoration : FfiConverterRustBuffer<PlanDecoration>{
    override fun read(buf: ByteBuffer): PlanDecoration {
        return when(buf.getInt()) {
            1 -> PlanDecoration.Starred(
                FfiConverterString.read(buf),
                )
            2 -> PlanDecoration.Badge(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PlanDecoration) = when(value) {
        is PlanDecoration.Starred -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`iconName`)
            )
        }
        is PlanDecoration.Badge -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`text`)
                + FfiConverterString.allocationSize(value.`anchor`)
                + FfiConverterString.allocationSize(value.`planId`)
            )
        }
    }

    override fun write(value: PlanDecoration, buf: ByteBuffer) {
        when(value) {
            is PlanDecoration.Starred -> {
                buf.putInt(1)
                FfiConverterString.write(value.`iconName`, buf)
                Unit
            }
            is PlanDecoration.Badge -> {
                buf.putInt(2)
                FfiConverterString.write(value.`text`, buf)
                FfiConverterString.write(value.`anchor`, buf)
                FfiConverterString.write(value.`planId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Represents a plan entitlement.
 */
sealed class PlanEntitlement {
    
    data class Description(
        val `text`: kotlin.String, 
        val `iconName`: kotlin.String, 
        val `hint`: kotlin.String?) : PlanEntitlement() {
        companion object
    }
    
    data class Progress(
        val `text`: kotlin.String, 
        val `title`: kotlin.String?, 
        val `min`: kotlin.ULong, 
        val `max`: kotlin.ULong, 
        val `current`: kotlin.ULong, 
        val `iconName`: kotlin.String?) : PlanEntitlement() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePlanEntitlement : FfiConverterRustBuffer<PlanEntitlement>{
    override fun read(buf: ByteBuffer): PlanEntitlement {
        return when(buf.getInt()) {
            1 -> PlanEntitlement.Description(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            2 -> PlanEntitlement.Progress(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PlanEntitlement) = when(value) {
        is PlanEntitlement.Description -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`text`)
                + FfiConverterString.allocationSize(value.`iconName`)
                + FfiConverterOptionalString.allocationSize(value.`hint`)
            )
        }
        is PlanEntitlement.Progress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`text`)
                + FfiConverterOptionalString.allocationSize(value.`title`)
                + FfiConverterULong.allocationSize(value.`min`)
                + FfiConverterULong.allocationSize(value.`max`)
                + FfiConverterULong.allocationSize(value.`current`)
                + FfiConverterOptionalString.allocationSize(value.`iconName`)
            )
        }
    }

    override fun write(value: PlanEntitlement, buf: ByteBuffer) {
        when(value) {
            is PlanEntitlement.Description -> {
                buf.putInt(1)
                FfiConverterString.write(value.`text`, buf)
                FfiConverterString.write(value.`iconName`, buf)
                FfiConverterOptionalString.write(value.`hint`, buf)
                Unit
            }
            is PlanEntitlement.Progress -> {
                buf.putInt(2)
                FfiConverterString.write(value.`text`, buf)
                FfiConverterOptionalString.write(value.`title`, buf)
                FfiConverterULong.write(value.`min`, buf)
                FfiConverterULong.write(value.`max`, buf)
                FfiConverterULong.write(value.`current`, buf)
                FfiConverterOptionalString.write(value.`iconName`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A plan type.
 */

enum class PlanType {
    
    SUB_PLAN,
    PRIMARY_PLAN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePlanType: FfiConverterRustBuffer<PlanType> {
    override fun read(buf: ByteBuffer) = try {
        PlanType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PlanType) = 4UL

    override fun write(value: PlanType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Represents a plan vendor's name.
 */

enum class PlanVendorName {
    
    GOOGLE,
    APPLE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePlanVendorName: FfiConverterRustBuffer<PlanVendorName> {
    override fun read(buf: ByteBuffer) = try {
        PlanVendorName.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PlanVendorName) = 4UL

    override fun write(value: PlanVendorName, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PrivacyLockColor {
    
    BLACK,
    GREEN,
    BLUE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePrivacyLockColor: FfiConverterRustBuffer<PrivacyLockColor> {
    override fun read(buf: ByteBuffer) = try {
        PrivacyLockColor.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PrivacyLockColor) = 4UL

    override fun write(value: PrivacyLockColor, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PrivacyLockIcon {
    
    CLOSED_LOCK,
    CLOSED_LOCK_WITH_TICK,
    CLOSED_LOCK_WITH_PEN,
    CLOSED_LOCK_WARNING,
    OPEN_LOCK_WITH_PEN,
    OPEN_LOCK_WITH_TICK,
    OPEN_LOCK_WARNING;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePrivacyLockIcon: FfiConverterRustBuffer<PrivacyLockIcon> {
    override fun read(buf: ByteBuffer) = try {
        PrivacyLockIcon.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PrivacyLockIcon) = 4UL

    override fun write(value: PrivacyLockIcon, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PrivacyLockTooltip {
    
    SEND_E2E,
    SEND_E2E_EXTERNAL,
    SEND_E2E_EO,
    SEND_E2E_VERIFIED_RECIPIENT,
    SEND_SIGN_ONLY,
    SEND_ZERO_ACCESS_ENCRYPTION_DISABLED,
    ZERO_ACCESS,
    ZERO_ACCESS_SENT_BY_PROTON,
    RECEIVE_E2E,
    RECEIVE_E2E_EXTERNAL,
    RECEIVE_E2E_VERIFIED_RECIPIENT,
    RECEIVE_E2E_VERIFICATION_FAILED,
    RECEIVE_E2E_VERIFICATION_FAILED_NO_SIGNATURE,
    RECEIVE_SIGN_ONLY_VERIFIED_RECIPIENT,
    RECEIVE_SIGN_ONLY_VERIFICATION_FAILED,
    SENT_E2E_VERIFIED_RECIPIENTS,
    SENT_PROTON_VERIFIED_RECIPIENTS,
    SENT_E2E,
    SENT_RECIPIENT_E2E_VERIFIED_RECIPIENT,
    SENT_RECIPIENT_PROTON_MAIL_VERIFIED_RECIPIENT,
    SENT_RECIPIENT_E2E,
    SENT_RECIPIENT_PROTON_MAIL,
    SENT_RECIPIENT_E2E_PGP_VERIFIED_RECIPIENT,
    SENT_RECIPIENT_PROTON_MAIL_PGP_VERIFIED_RECIPIENT,
    SENT_RECIPIENT_E2E_PGP_RECIPIENT,
    SENT_RECIPIENT_PROTON_MAIL_PGP_RECIPIENT,
    SENT_RECIPIENT_PGP_SIGNED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePrivacyLockTooltip: FfiConverterRustBuffer<PrivacyLockTooltip> {
    override fun read(buf: ByteBuffer) = try {
        PrivacyLockTooltip.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PrivacyLockTooltip) = 4UL

    override fun write(value: PrivacyLockTooltip, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ProtonError {
    
    data class OtherReason(
        val v1: OtherErrorReason) : ProtonError() {
        companion object
    }
    
    data class ServerError(
        val v1: UserApiServiceError) : ProtonError() {
        companion object
    }
    
    object Network : ProtonError()
    
    
    data class Unexpected(
        val v1: UnexpectedError) : ProtonError() {
        companion object
    }
    
    object NonProcessableActions : ProtonError()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeProtonError : FfiConverterRustBuffer<ProtonError>{
    override fun read(buf: ByteBuffer): ProtonError {
        return when(buf.getInt()) {
            1 -> ProtonError.OtherReason(
                FfiConverterTypeOtherErrorReason.read(buf),
                )
            2 -> ProtonError.ServerError(
                FfiConverterTypeUserApiServiceError.read(buf),
                )
            3 -> ProtonError.Network
            4 -> ProtonError.Unexpected(
                FfiConverterTypeUnexpectedError.read(buf),
                )
            5 -> ProtonError.NonProcessableActions
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ProtonError) = when(value) {
        is ProtonError.OtherReason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeOtherErrorReason.allocationSize(value.v1)
            )
        }
        is ProtonError.ServerError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserApiServiceError.allocationSize(value.v1)
            )
        }
        is ProtonError.Network -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ProtonError.Unexpected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnexpectedError.allocationSize(value.v1)
            )
        }
        is ProtonError.NonProcessableActions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ProtonError, buf: ByteBuffer) {
        when(value) {
            is ProtonError.OtherReason -> {
                buf.putInt(1)
                FfiConverterTypeOtherErrorReason.write(value.v1, buf)
                Unit
            }
            is ProtonError.ServerError -> {
                buf.putInt(2)
                FfiConverterTypeUserApiServiceError.write(value.v1, buf)
                Unit
            }
            is ProtonError.Network -> {
                buf.putInt(3)
                Unit
            }
            is ProtonError.Unexpected -> {
                buf.putInt(4)
                FfiConverterTypeUnexpectedError.write(value.v1, buf)
                Unit
            }
            is ProtonError.NonProcessableActions -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Quick actions available for mail related push notifications.
 * It operates on remote ids since local ids are unknown at this point.

 */
sealed class PushNotificationQuickAction {
    
    data class MarkAsRead(
        val `remoteId`: RemoteId) : PushNotificationQuickAction() {
        companion object
    }
    
    data class MoveToArchive(
        val `remoteId`: RemoteId) : PushNotificationQuickAction() {
        companion object
    }
    
    data class MoveToTrash(
        val `remoteId`: RemoteId) : PushNotificationQuickAction() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePushNotificationQuickAction : FfiConverterRustBuffer<PushNotificationQuickAction>{
    override fun read(buf: ByteBuffer): PushNotificationQuickAction {
        return when(buf.getInt()) {
            1 -> PushNotificationQuickAction.MarkAsRead(
                FfiConverterTypeRemoteId.read(buf),
                )
            2 -> PushNotificationQuickAction.MoveToArchive(
                FfiConverterTypeRemoteId.read(buf),
                )
            3 -> PushNotificationQuickAction.MoveToTrash(
                FfiConverterTypeRemoteId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PushNotificationQuickAction) = when(value) {
        is PushNotificationQuickAction.MarkAsRead -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRemoteId.allocationSize(value.`remoteId`)
            )
        }
        is PushNotificationQuickAction.MoveToArchive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRemoteId.allocationSize(value.`remoteId`)
            )
        }
        is PushNotificationQuickAction.MoveToTrash -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRemoteId.allocationSize(value.`remoteId`)
            )
        }
    }

    override fun write(value: PushNotificationQuickAction, buf: ByteBuffer) {
        when(value) {
            is PushNotificationQuickAction.MarkAsRead -> {
                buf.putInt(1)
                FfiConverterTypeRemoteId.write(value.`remoteId`, buf)
                Unit
            }
            is PushNotificationQuickAction.MoveToArchive -> {
                buf.putInt(2)
                FfiConverterTypeRemoteId.write(value.`remoteId`, buf)
                Unit
            }
            is PushNotificationQuickAction.MoveToTrash -> {
                buf.putInt(3)
                FfiConverterTypeRemoteId.write(value.`remoteId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ReadFilter(val value: kotlin.UByte) {
    
    ALL(0u),
    UNREAD(1u),
    READ(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeReadFilter: FfiConverterRustBuffer<ReadFilter> {
    override fun read(buf: ByteBuffer) = try {
        ReadFilter.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ReadFilter) = 4UL

    override fun write(value: ReadFilter, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RecipientInvalidReason {
    
    FORMAT,
    DOES_NOT_EXIST,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRecipientInvalidReason: FfiConverterRustBuffer<RecipientInvalidReason> {
    override fun read(buf: ByteBuffer) = try {
        RecipientInvalidReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RecipientInvalidReason) = 4UL

    override fun write(value: RecipientInvalidReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Errors which occur when removing recipient from the draft
 */
sealed class RemoveRecipientError {
    
    /**
     * No errors occurred
     */
    object Ok : RemoveRecipientError()
    
    
    /**
     * Empty group name
     */
    object EmptyGroupName : RemoveRecipientError()
    
    
    /**
     * Failed to queue save action for draft.
     */
    data class SaveFailed(
        val v1: DraftSaveError) : RemoveRecipientError() {
        companion object
    }
    
    /**
     * Another error occurred
     */
    object Other : RemoveRecipientError()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRemoveRecipientError : FfiConverterRustBuffer<RemoveRecipientError>{
    override fun read(buf: ByteBuffer): RemoveRecipientError {
        return when(buf.getInt()) {
            1 -> RemoveRecipientError.Ok
            2 -> RemoveRecipientError.EmptyGroupName
            3 -> RemoveRecipientError.SaveFailed(
                FfiConverterTypeDraftSaveError.read(buf),
                )
            4 -> RemoveRecipientError.Other
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RemoveRecipientError) = when(value) {
        is RemoveRecipientError.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RemoveRecipientError.EmptyGroupName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RemoveRecipientError.SaveFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveError.allocationSize(value.v1)
            )
        }
        is RemoveRecipientError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: RemoveRecipientError, buf: ByteBuffer) {
        when(value) {
            is RemoveRecipientError.Ok -> {
                buf.putInt(1)
                Unit
            }
            is RemoveRecipientError.EmptyGroupName -> {
                buf.putInt(2)
                Unit
            }
            is RemoveRecipientError.SaveFailed -> {
                buf.putInt(3)
                FfiConverterTypeDraftSaveError.write(value.v1, buf)
                Unit
            }
            is RemoveRecipientError.Other -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ResolveMessageIdResult {
    
    data class Ok(
        val v1: Id) : ResolveMessageIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ResolveMessageIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeResolveMessageIdResult : FfiConverterRustBuffer<ResolveMessageIdResult>{
    override fun read(buf: ByteBuffer): ResolveMessageIdResult {
        return when(buf.getInt()) {
            1 -> ResolveMessageIdResult.Ok(
                FfiConverterTypeId.read(buf),
                )
            2 -> ResolveMessageIdResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResolveMessageIdResult) = when(value) {
        is ResolveMessageIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeId.allocationSize(value.v1)
            )
        }
        is ResolveMessageIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ResolveMessageIdResult, buf: ByteBuffer) {
        when(value) {
            is ResolveMessageIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeId.write(value.v1, buf)
                Unit
            }
            is ResolveMessageIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ResolveSystemLabelByIdResult {
    
    data class Ok(
        val v1: SystemLabel?) : ResolveSystemLabelByIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : ResolveSystemLabelByIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeResolveSystemLabelByIdResult : FfiConverterRustBuffer<ResolveSystemLabelByIdResult>{
    override fun read(buf: ByteBuffer): ResolveSystemLabelByIdResult {
        return when(buf.getInt()) {
            1 -> ResolveSystemLabelByIdResult.Ok(
                FfiConverterOptionalTypeSystemLabel.read(buf),
                )
            2 -> ResolveSystemLabelByIdResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResolveSystemLabelByIdResult) = when(value) {
        is ResolveSystemLabelByIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeSystemLabel.allocationSize(value.v1)
            )
        }
        is ResolveSystemLabelByIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ResolveSystemLabelByIdResult, buf: ByteBuffer) {
        when(value) {
            is ResolveSystemLabelByIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeSystemLabel.write(value.v1, buf)
                Unit
            }
            is ResolveSystemLabelByIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ResolveSystemLabelIdResult {
    
    data class Ok(
        val v1: Id?) : ResolveSystemLabelIdResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : ResolveSystemLabelIdResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeResolveSystemLabelIdResult : FfiConverterRustBuffer<ResolveSystemLabelIdResult>{
    override fun read(buf: ByteBuffer): ResolveSystemLabelIdResult {
        return when(buf.getInt()) {
            1 -> ResolveSystemLabelIdResult.Ok(
                FfiConverterOptionalTypeId.read(buf),
                )
            2 -> ResolveSystemLabelIdResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResolveSystemLabelIdResult) = when(value) {
        is ResolveSystemLabelIdResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeId.allocationSize(value.v1)
            )
        }
        is ResolveSystemLabelIdResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ResolveSystemLabelIdResult, buf: ByteBuffer) {
        when(value) {
            is ResolveSystemLabelIdResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeId.write(value.v1, buf)
                Unit
            }
            is ResolveSystemLabelIdResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ResolverException: kotlin.Exception() {
    
    class Network(
        
        val v1: kotlin.String
        ) : ResolverException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Other(
        
        val v1: kotlin.String
        ) : ResolverException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ResolverException> {
        override fun lift(error_buf: RustBuffer.ByValue): ResolverException = FfiConverterTypeResolverError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeResolverError : FfiConverterRustBuffer<ResolverException> {
    override fun read(buf: ByteBuffer): ResolverException {
        

        return when(buf.getInt()) {
            1 -> ResolverException.Network(
                FfiConverterString.read(buf),
                )
            2 -> ResolverException.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResolverException): ULong {
        return when(value) {
            is ResolverException.Network -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is ResolverException.Other -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ResolverException, buf: ByteBuffer) {
        when(value) {
            is ResolverException.Network -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ResolverException.Other -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class Role {
    
    object None : Role()
    
    
    object Member : Role()
    
    
    object Admin : Role()
    
    
    data class Unknown(
        val v1: kotlin.UInt) : Role() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRole : FfiConverterRustBuffer<Role>{
    override fun read(buf: ByteBuffer): Role {
        return when(buf.getInt()) {
            1 -> Role.None
            2 -> Role.Member
            3 -> Role.Admin
            4 -> Role.Unknown(
                FfiConverterUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Role) = when(value) {
        is Role.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is Role.Member -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is Role.Admin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is Role.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Role, buf: ByteBuffer) {
        when(value) {
            is Role.None -> {
                buf.putInt(1)
                Unit
            }
            is Role.Member -> {
                buf.putInt(2)
                Unit
            }
            is Role.Admin -> {
                buf.putInt(3)
                Unit
            }
            is Role.Unknown -> {
                buf.putInt(4)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RsvpAnswer {
    
    MAYBE,
    NO,
    YES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpAnswer: FfiConverterRustBuffer<RsvpAnswer> {
    override fun read(buf: ByteBuffer) = try {
        RsvpAnswer.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpAnswer) = 4UL

    override fun write(value: RsvpAnswer, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RsvpAttendance {
    
    /**
     * User might reply to this invitation.
     */
    OPTIONAL,
    /**
     * User must reply to this invitation.
     */
    REQUIRED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpAttendance: FfiConverterRustBuffer<RsvpAttendance> {
    override fun read(buf: ByteBuffer) = try {
        RsvpAttendance.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpAttendance) = 4UL

    override fun write(value: RsvpAttendance, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RsvpAttendeeStatus {
    
    UNANSWERED,
    MAYBE,
    NO,
    YES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpAttendeeStatus: FfiConverterRustBuffer<RsvpAttendeeStatus> {
    override fun read(buf: ByteBuffer) = try {
        RsvpAttendeeStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpAttendeeStatus) = 4UL

    override fun write(value: RsvpAttendeeStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class RsvpEventGetResult {
    
    data class Ok(
        val v1: RsvpEvent) : RsvpEventGetResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : RsvpEventGetResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpEventGetResult : FfiConverterRustBuffer<RsvpEventGetResult>{
    override fun read(buf: ByteBuffer): RsvpEventGetResult {
        return when(buf.getInt()) {
            1 -> RsvpEventGetResult.Ok(
                FfiConverterTypeRsvpEvent.read(buf),
                )
            2 -> RsvpEventGetResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RsvpEventGetResult) = when(value) {
        is RsvpEventGetResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRsvpEvent.allocationSize(value.v1)
            )
        }
        is RsvpEventGetResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: RsvpEventGetResult, buf: ByteBuffer) {
        when(value) {
            is RsvpEventGetResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeRsvpEvent.write(value.v1, buf)
                Unit
            }
            is RsvpEventGetResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RsvpOccurrence {
    
    /**
     * Full-day event.
     */
    DATE,
    /**
     * Part-day event.
     */
    DATE_TIME;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpOccurrence: FfiConverterRustBuffer<RsvpOccurrence> {
    override fun read(buf: ByteBuffer) = try {
        RsvpOccurrence.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpOccurrence) = 4UL

    override fun write(value: RsvpOccurrence, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RsvpProgress {
    
    /**
     * Event has not started yet.
     */
    PENDING,
    /**
     * Event is happening right now.
     */
    ONGOING,
    /**
     * Event has ended.
     */
    ENDED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpProgress: FfiConverterRustBuffer<RsvpProgress> {
    override fun read(buf: ByteBuffer) = try {
        RsvpProgress.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpProgress) = 4UL

    override fun write(value: RsvpProgress, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class RsvpState {
    
    /**
     * RSVP is an invite that can be answered.
     */
    data class AnswerableInvite(
        val `progress`: RsvpProgress, 
        val `attendance`: RsvpAttendance) : RsvpState() {
        companion object
    }
    
    /**
     * RSVP is an invite that cannot be answered anymore.
     */
    data class UnanswerableInvite(
        val `reason`: RsvpUnanswerableReason) : RsvpState() {
        companion object
    }
    
    /**
     * RSVP is an invite for a now-cancelled event.
     */
    data class CancelledInvite(
        val `isOutdated`: kotlin.Boolean) : RsvpState() {
        companion object
    }
    
    /**
     * RSVP is a reminder.
     */
    data class Reminder(
        val `progress`: RsvpProgress) : RsvpState() {
        companion object
    }
    
    /**
     * RSVP is a reminder for a now-cancelled event.
     *
     * (the terminology is mildly off here, it's not the reminder that got
     * cancelled - it's the reminder's event.)
     */
    object CancelledReminder : RsvpState()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRsvpState : FfiConverterRustBuffer<RsvpState>{
    override fun read(buf: ByteBuffer): RsvpState {
        return when(buf.getInt()) {
            1 -> RsvpState.AnswerableInvite(
                FfiConverterTypeRsvpProgress.read(buf),
                FfiConverterTypeRsvpAttendance.read(buf),
                )
            2 -> RsvpState.UnanswerableInvite(
                FfiConverterTypeRsvpUnanswerableReason.read(buf),
                )
            3 -> RsvpState.CancelledInvite(
                FfiConverterBoolean.read(buf),
                )
            4 -> RsvpState.Reminder(
                FfiConverterTypeRsvpProgress.read(buf),
                )
            5 -> RsvpState.CancelledReminder
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RsvpState) = when(value) {
        is RsvpState.AnswerableInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRsvpProgress.allocationSize(value.`progress`)
                + FfiConverterTypeRsvpAttendance.allocationSize(value.`attendance`)
            )
        }
        is RsvpState.UnanswerableInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRsvpUnanswerableReason.allocationSize(value.`reason`)
            )
        }
        is RsvpState.CancelledInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`isOutdated`)
            )
        }
        is RsvpState.Reminder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRsvpProgress.allocationSize(value.`progress`)
            )
        }
        is RsvpState.CancelledReminder -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: RsvpState, buf: ByteBuffer) {
        when(value) {
            is RsvpState.AnswerableInvite -> {
                buf.putInt(1)
                FfiConverterTypeRsvpProgress.write(value.`progress`, buf)
                FfiConverterTypeRsvpAttendance.write(value.`attendance`, buf)
                Unit
            }
            is RsvpState.UnanswerableInvite -> {
                buf.putInt(2)
                FfiConverterTypeRsvpUnanswerableReason.write(value.`reason`, buf)
                Unit
            }
            is RsvpState.CancelledInvite -> {
                buf.putInt(3)
                FfiConverterBoolean.write(value.`isOutdated`, buf)
                Unit
            }
            is RsvpState.Reminder -> {
                buf.putInt(4)
                FfiConverterTypeRsvpProgress.write(value.`progress`, buf)
                Unit
            }
            is RsvpState.CancelledReminder -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RsvpUnanswerableReason {
    
    /**
     * User is the organizer of this event.
     */
    USER_IS_ORGANIZER,
    /**
     * User hasn't been actually invited to this event (aka "party crasher").
     */
    USER_IS_NOT_INVITED,
    /**
     * User is looking at a stale `invite.ics`.
     */
    INVITE_IS_OUTDATED,
    /**
     * Invite's event doesn't exist in Proton Calendar (e.g. user has the
     * auto-import feature disabled or the event has been manually deleted).
     *
     * This is just a limitation of the current implementation - it cannot yet
     * create new events in Proton Calendar, the event must already be there
     * for user to be able to respond to it.
     */
    EVENT_DOES_NOT_EXIST,
    /**
     * User's address is either disabled or otherwise cannot be used to send
     * the reply.
     */
    ADDRESS_IS_INCORRECT,
    /**
     * There's no internet connection.
     */
    NETWORK_FAILURE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRsvpUnanswerableReason: FfiConverterRustBuffer<RsvpUnanswerableReason> {
    override fun read(buf: ByteBuffer) = try {
        RsvpUnanswerableReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RsvpUnanswerableReason) = 4UL

    override fun write(value: RsvpUnanswerableReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ScrollConversationsForLabelResult: Disposable  {
    
    data class Ok(
        val v1: ConversationScroller) : ScrollConversationsForLabelResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ScrollConversationsForLabelResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ScrollConversationsForLabelResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is ScrollConversationsForLabelResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScrollConversationsForLabelResult : FfiConverterRustBuffer<ScrollConversationsForLabelResult>{
    override fun read(buf: ByteBuffer): ScrollConversationsForLabelResult {
        return when(buf.getInt()) {
            1 -> ScrollConversationsForLabelResult.Ok(
                FfiConverterTypeConversationScroller.read(buf),
                )
            2 -> ScrollConversationsForLabelResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScrollConversationsForLabelResult) = when(value) {
        is ScrollConversationsForLabelResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConversationScroller.allocationSize(value.v1)
            )
        }
        is ScrollConversationsForLabelResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ScrollConversationsForLabelResult, buf: ByteBuffer) {
        when(value) {
            is ScrollConversationsForLabelResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeConversationScroller.write(value.v1, buf)
                Unit
            }
            is ScrollConversationsForLabelResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ScrollMessagesForLabelResult: Disposable  {
    
    data class Ok(
        val v1: MessageScroller) : ScrollMessagesForLabelResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ScrollMessagesForLabelResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ScrollMessagesForLabelResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is ScrollMessagesForLabelResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScrollMessagesForLabelResult : FfiConverterRustBuffer<ScrollMessagesForLabelResult>{
    override fun read(buf: ByteBuffer): ScrollMessagesForLabelResult {
        return when(buf.getInt()) {
            1 -> ScrollMessagesForLabelResult.Ok(
                FfiConverterTypeMessageScroller.read(buf),
                )
            2 -> ScrollMessagesForLabelResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScrollMessagesForLabelResult) = when(value) {
        is ScrollMessagesForLabelResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageScroller.allocationSize(value.v1)
            )
        }
        is ScrollMessagesForLabelResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ScrollMessagesForLabelResult, buf: ByteBuffer) {
        when(value) {
            is ScrollMessagesForLabelResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMessageScroller.write(value.v1, buf)
                Unit
            }
            is ScrollMessagesForLabelResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ScrollerSearchResult: Disposable  {
    
    data class Ok(
        val v1: SearchScroller) : ScrollerSearchResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : ScrollerSearchResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ScrollerSearchResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is ScrollerSearchResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScrollerSearchResult : FfiConverterRustBuffer<ScrollerSearchResult>{
    override fun read(buf: ByteBuffer): ScrollerSearchResult {
        return when(buf.getInt()) {
            1 -> ScrollerSearchResult.Ok(
                FfiConverterTypeSearchScroller.read(buf),
                )
            2 -> ScrollerSearchResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScrollerSearchResult) = when(value) {
        is ScrollerSearchResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSearchScroller.allocationSize(value.v1)
            )
        }
        is ScrollerSearchResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ScrollerSearchResult, buf: ByteBuffer) {
        when(value) {
            is ScrollerSearchResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSearchScroller.write(value.v1, buf)
                Unit
            }
            is ScrollerSearchResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerChangeIncludeResult {
    
    object Ok : SearchScrollerChangeIncludeResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerChangeIncludeResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerChangeIncludeResult : FfiConverterRustBuffer<SearchScrollerChangeIncludeResult>{
    override fun read(buf: ByteBuffer): SearchScrollerChangeIncludeResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerChangeIncludeResult.Ok
            2 -> SearchScrollerChangeIncludeResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerChangeIncludeResult) = when(value) {
        is SearchScrollerChangeIncludeResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerChangeIncludeResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerChangeIncludeResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerChangeIncludeResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerChangeIncludeResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerChangeKeywordsResult {
    
    object Ok : SearchScrollerChangeKeywordsResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerChangeKeywordsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerChangeKeywordsResult : FfiConverterRustBuffer<SearchScrollerChangeKeywordsResult>{
    override fun read(buf: ByteBuffer): SearchScrollerChangeKeywordsResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerChangeKeywordsResult.Ok
            2 -> SearchScrollerChangeKeywordsResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerChangeKeywordsResult) = when(value) {
        is SearchScrollerChangeKeywordsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerChangeKeywordsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerChangeKeywordsResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerChangeKeywordsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerChangeKeywordsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerCursorResult: Disposable  {
    
    data class Ok(
        val v1: MailMessageCursor) : SearchScrollerCursorResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerCursorResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SearchScrollerCursorResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SearchScrollerCursorResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerCursorResult : FfiConverterRustBuffer<SearchScrollerCursorResult>{
    override fun read(buf: ByteBuffer): SearchScrollerCursorResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerCursorResult.Ok(
                FfiConverterTypeMailMessageCursor.read(buf),
                )
            2 -> SearchScrollerCursorResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerCursorResult) = when(value) {
        is SearchScrollerCursorResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailMessageCursor.allocationSize(value.v1)
            )
        }
        is SearchScrollerCursorResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerCursorResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerCursorResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeMailMessageCursor.write(value.v1, buf)
                Unit
            }
            is SearchScrollerCursorResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerFetchMoreResult {
    
    object Ok : SearchScrollerFetchMoreResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerFetchMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerFetchMoreResult : FfiConverterRustBuffer<SearchScrollerFetchMoreResult>{
    override fun read(buf: ByteBuffer): SearchScrollerFetchMoreResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerFetchMoreResult.Ok
            2 -> SearchScrollerFetchMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerFetchMoreResult) = when(value) {
        is SearchScrollerFetchMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerFetchMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerFetchMoreResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerFetchMoreResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerFetchMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerForceRefreshResult {
    
    object Ok : SearchScrollerForceRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerForceRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerForceRefreshResult : FfiConverterRustBuffer<SearchScrollerForceRefreshResult>{
    override fun read(buf: ByteBuffer): SearchScrollerForceRefreshResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerForceRefreshResult.Ok
            2 -> SearchScrollerForceRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerForceRefreshResult) = when(value) {
        is SearchScrollerForceRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerForceRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerForceRefreshResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerForceRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerForceRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerGetItemsResult {
    
    object Ok : SearchScrollerGetItemsResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerGetItemsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerGetItemsResult : FfiConverterRustBuffer<SearchScrollerGetItemsResult>{
    override fun read(buf: ByteBuffer): SearchScrollerGetItemsResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerGetItemsResult.Ok
            2 -> SearchScrollerGetItemsResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerGetItemsResult) = when(value) {
        is SearchScrollerGetItemsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerGetItemsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerGetItemsResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerGetItemsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerGetItemsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerHasMoreResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : SearchScrollerHasMoreResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerHasMoreResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerHasMoreResult : FfiConverterRustBuffer<SearchScrollerHasMoreResult>{
    override fun read(buf: ByteBuffer): SearchScrollerHasMoreResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerHasMoreResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> SearchScrollerHasMoreResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerHasMoreResult) = when(value) {
        is SearchScrollerHasMoreResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is SearchScrollerHasMoreResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerHasMoreResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerHasMoreResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is SearchScrollerHasMoreResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerRefreshResult {
    
    object Ok : SearchScrollerRefreshResult()
    
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerRefreshResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerRefreshResult : FfiConverterRustBuffer<SearchScrollerRefreshResult>{
    override fun read(buf: ByteBuffer): SearchScrollerRefreshResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerRefreshResult.Ok
            2 -> SearchScrollerRefreshResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerRefreshResult) = when(value) {
        is SearchScrollerRefreshResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SearchScrollerRefreshResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerRefreshResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerRefreshResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SearchScrollerRefreshResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerSupportsIncludeFilterResult {
    
    data class Ok(
        val v1: kotlin.Boolean) : SearchScrollerSupportsIncludeFilterResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerSupportsIncludeFilterResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerSupportsIncludeFilterResult : FfiConverterRustBuffer<SearchScrollerSupportsIncludeFilterResult>{
    override fun read(buf: ByteBuffer): SearchScrollerSupportsIncludeFilterResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerSupportsIncludeFilterResult.Ok(
                FfiConverterBoolean.read(buf),
                )
            2 -> SearchScrollerSupportsIncludeFilterResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerSupportsIncludeFilterResult) = when(value) {
        is SearchScrollerSupportsIncludeFilterResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.v1)
            )
        }
        is SearchScrollerSupportsIncludeFilterResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerSupportsIncludeFilterResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerSupportsIncludeFilterResult.Ok -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.v1, buf)
                Unit
            }
            is SearchScrollerSupportsIncludeFilterResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SearchScrollerTotalResult {
    
    data class Ok(
        val v1: kotlin.ULong) : SearchScrollerTotalResult() {
        companion object
    }
    
    data class Error(
        val v1: MailScrollerError) : SearchScrollerTotalResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSearchScrollerTotalResult : FfiConverterRustBuffer<SearchScrollerTotalResult>{
    override fun read(buf: ByteBuffer): SearchScrollerTotalResult {
        return when(buf.getInt()) {
            1 -> SearchScrollerTotalResult.Ok(
                FfiConverterULong.read(buf),
                )
            2 -> SearchScrollerTotalResult.Error(
                FfiConverterTypeMailScrollerError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SearchScrollerTotalResult) = when(value) {
        is SearchScrollerTotalResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is SearchScrollerTotalResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMailScrollerError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SearchScrollerTotalResult, buf: ByteBuffer) {
        when(value) {
            is SearchScrollerTotalResult.Ok -> {
                buf.putInt(1)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is SearchScrollerTotalResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeMailScrollerError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Specific Reason for error occurrence within Session.
 *
 * This enum is used to represent the specific reason for an error that occurred
 * in handling session related operations in order to provide only the necessary
 * information to the user. This error type in common library is named `ContextErrorReason`
 * as context is nomenclature used in the common library.
 */
sealed class SessionReason {
    
    object UnknownLabel : SessionReason()
    
    
    object DuplicateSession : SessionReason()
    
    
    object UserSessionNotInitialized : SessionReason()
    
    
    /**
     * Mobile dev used a method that is supported only in one origin.
     * Example: Method that can be called only in the main application process, was called from iOS share extension.
     */
    data class MethodCalledInWrongOrigin(
        val `expected`: Origin, 
        val `actual`: Origin) : SessionReason() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionReason : FfiConverterRustBuffer<SessionReason>{
    override fun read(buf: ByteBuffer): SessionReason {
        return when(buf.getInt()) {
            1 -> SessionReason.UnknownLabel
            2 -> SessionReason.DuplicateSession
            3 -> SessionReason.UserSessionNotInitialized
            4 -> SessionReason.MethodCalledInWrongOrigin(
                FfiConverterTypeOrigin.read(buf),
                FfiConverterTypeOrigin.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SessionReason) = when(value) {
        is SessionReason.UnknownLabel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SessionReason.DuplicateSession -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SessionReason.UserSessionNotInitialized -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SessionReason.MethodCalledInWrongOrigin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeOrigin.allocationSize(value.`expected`)
                + FfiConverterTypeOrigin.allocationSize(value.`actual`)
            )
        }
    }

    override fun write(value: SessionReason, buf: ByteBuffer) {
        when(value) {
            is SessionReason.UnknownLabel -> {
                buf.putInt(1)
                Unit
            }
            is SessionReason.DuplicateSession -> {
                buf.putInt(2)
                Unit
            }
            is SessionReason.UserSessionNotInitialized -> {
                buf.putInt(3)
                Unit
            }
            is SessionReason.MethodCalledInWrongOrigin -> {
                buf.putInt(4)
                FfiConverterTypeOrigin.write(value.`expected`, buf)
                FfiConverterTypeOrigin.write(value.`actual`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ShowImages(val value: kotlin.UByte) {
    
    DO_NOT_AUTO_LOAD(0u),
    AUTO_LOAD_REMOTE(1u),
    AUTO_LOAD_EMBEDDED(2u),
    AUTO_LOAD_BOTH(3u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeShowImages: FfiConverterRustBuffer<ShowImages> {
    override fun read(buf: ByteBuffer) = try {
        ShowImages.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ShowImages) = 4UL

    override fun write(value: ShowImages, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ShowMoved(val value: kotlin.UByte) {
    
    DO_NOT_KEEP(0u),
    KEEP_IN_DRAFTS(1u),
    KEEP_IN_SENT(2u),
    KEEP_BOTH(3u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeShowMoved: FfiConverterRustBuffer<ShowMoved> {
    override fun read(buf: ByteBuffer) = try {
        ShowMoved.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ShowMoved) = 4UL

    override fun write(value: ShowMoved, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SidebarAllCustomFoldersResult {
    
    data class Ok(
        val v1: List<SidebarCustomFolder>) : SidebarAllCustomFoldersResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : SidebarAllCustomFoldersResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarAllCustomFoldersResult : FfiConverterRustBuffer<SidebarAllCustomFoldersResult>{
    override fun read(buf: ByteBuffer): SidebarAllCustomFoldersResult {
        return when(buf.getInt()) {
            1 -> SidebarAllCustomFoldersResult.Ok(
                FfiConverterSequenceTypeSidebarCustomFolder.read(buf),
                )
            2 -> SidebarAllCustomFoldersResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SidebarAllCustomFoldersResult) = when(value) {
        is SidebarAllCustomFoldersResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarCustomFolder.allocationSize(value.v1)
            )
        }
        is SidebarAllCustomFoldersResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SidebarAllCustomFoldersResult, buf: ByteBuffer) {
        when(value) {
            is SidebarAllCustomFoldersResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarCustomFolder.write(value.v1, buf)
                Unit
            }
            is SidebarAllCustomFoldersResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SidebarCustomFoldersResult {
    
    data class Ok(
        val v1: List<SidebarCustomFolder>) : SidebarCustomFoldersResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : SidebarCustomFoldersResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarCustomFoldersResult : FfiConverterRustBuffer<SidebarCustomFoldersResult>{
    override fun read(buf: ByteBuffer): SidebarCustomFoldersResult {
        return when(buf.getInt()) {
            1 -> SidebarCustomFoldersResult.Ok(
                FfiConverterSequenceTypeSidebarCustomFolder.read(buf),
                )
            2 -> SidebarCustomFoldersResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SidebarCustomFoldersResult) = when(value) {
        is SidebarCustomFoldersResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarCustomFolder.allocationSize(value.v1)
            )
        }
        is SidebarCustomFoldersResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SidebarCustomFoldersResult, buf: ByteBuffer) {
        when(value) {
            is SidebarCustomFoldersResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarCustomFolder.write(value.v1, buf)
                Unit
            }
            is SidebarCustomFoldersResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SidebarCustomLabelsResult {
    
    data class Ok(
        val v1: List<SidebarCustomLabel>) : SidebarCustomLabelsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : SidebarCustomLabelsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarCustomLabelsResult : FfiConverterRustBuffer<SidebarCustomLabelsResult>{
    override fun read(buf: ByteBuffer): SidebarCustomLabelsResult {
        return when(buf.getInt()) {
            1 -> SidebarCustomLabelsResult.Ok(
                FfiConverterSequenceTypeSidebarCustomLabel.read(buf),
                )
            2 -> SidebarCustomLabelsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SidebarCustomLabelsResult) = when(value) {
        is SidebarCustomLabelsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarCustomLabel.allocationSize(value.v1)
            )
        }
        is SidebarCustomLabelsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SidebarCustomLabelsResult, buf: ByteBuffer) {
        when(value) {
            is SidebarCustomLabelsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarCustomLabel.write(value.v1, buf)
                Unit
            }
            is SidebarCustomLabelsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SidebarSystemLabelsResult {
    
    data class Ok(
        val v1: List<SidebarSystemLabel>) : SidebarSystemLabelsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : SidebarSystemLabelsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarSystemLabelsResult : FfiConverterRustBuffer<SidebarSystemLabelsResult>{
    override fun read(buf: ByteBuffer): SidebarSystemLabelsResult {
        return when(buf.getInt()) {
            1 -> SidebarSystemLabelsResult.Ok(
                FfiConverterSequenceTypeSidebarSystemLabel.read(buf),
                )
            2 -> SidebarSystemLabelsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SidebarSystemLabelsResult) = when(value) {
        is SidebarSystemLabelsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSidebarSystemLabel.allocationSize(value.v1)
            )
        }
        is SidebarSystemLabelsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SidebarSystemLabelsResult, buf: ByteBuffer) {
        when(value) {
            is SidebarSystemLabelsResult.Ok -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSidebarSystemLabel.write(value.v1, buf)
                Unit
            }
            is SidebarSystemLabelsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SidebarWatchLabelsResult: Disposable  {
    
    data class Ok(
        val v1: WatchHandle) : SidebarWatchLabelsResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : SidebarWatchLabelsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SidebarWatchLabelsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SidebarWatchLabelsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSidebarWatchLabelsResult : FfiConverterRustBuffer<SidebarWatchLabelsResult>{
    override fun read(buf: ByteBuffer): SidebarWatchLabelsResult {
        return when(buf.getInt()) {
            1 -> SidebarWatchLabelsResult.Ok(
                FfiConverterTypeWatchHandle.read(buf),
                )
            2 -> SidebarWatchLabelsResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SidebarWatchLabelsResult) = when(value) {
        is SidebarWatchLabelsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchHandle.allocationSize(value.v1)
            )
        }
        is SidebarWatchLabelsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SidebarWatchLabelsResult, buf: ByteBuffer) {
        when(value) {
            is SidebarWatchLabelsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchHandle.write(value.v1, buf)
                Unit
            }
            is SidebarWatchLabelsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class SignatureVerification {
    
    /**
     * Successfully verified the signature
     */
    OK,
    /**
     * No signature found
     */
    NOT_SIGNED,
    /**
     * No matching key found.
     */
    NO_VERIFIER,
    /**
     * Signature verification failure.
     */
    FAILED,
    /**
     * Signature context did not match verification context.
     */
    BAD_CONTEXT,
    /**
     * Unknown error occurred.
     */
    RUNTIME_ERROR;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSignatureVerification: FfiConverterRustBuffer<SignatureVerification> {
    override fun read(buf: ByteBuffer) = try {
        SignatureVerification.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SignatureVerification) = 4UL

    override fun write(value: SignatureVerification, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SignupScreenId {
    
    CHOOSE_EXTERNAL_EMAIL,
    CHOOSE_INTERNAL_EMAIL,
    CHOOSE_USERNAME,
    CREATE_PASSWORD,
    SET_RECOVERY_METHOD,
    CONGRATULATIONS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSignupScreenId: FfiConverterRustBuffer<SignupScreenId> {
    override fun read(buf: ByteBuffer) = try {
        SignupScreenId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SignupScreenId) = 4UL

    override fun write(value: SignupScreenId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SnoozeConversationsResult {
    
    object Ok : SnoozeConversationsResult()
    
    
    data class Error(
        val v1: SnoozeError) : SnoozeConversationsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSnoozeConversationsResult : FfiConverterRustBuffer<SnoozeConversationsResult>{
    override fun read(buf: ByteBuffer): SnoozeConversationsResult {
        return when(buf.getInt()) {
            1 -> SnoozeConversationsResult.Ok
            2 -> SnoozeConversationsResult.Error(
                FfiConverterTypeSnoozeError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SnoozeConversationsResult) = when(value) {
        is SnoozeConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SnoozeConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSnoozeError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SnoozeConversationsResult, buf: ByteBuffer) {
        when(value) {
            is SnoozeConversationsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is SnoozeConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSnoozeError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SnoozeError {
    
    data class Reason(
        val v1: SnoozeErrorReason) : SnoozeError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : SnoozeError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSnoozeError : FfiConverterRustBuffer<SnoozeError>{
    override fun read(buf: ByteBuffer): SnoozeError {
        return when(buf.getInt()) {
            1 -> SnoozeError.Reason(
                FfiConverterTypeSnoozeErrorReason.read(buf),
                )
            2 -> SnoozeError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SnoozeError) = when(value) {
        is SnoozeError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSnoozeErrorReason.allocationSize(value.v1)
            )
        }
        is SnoozeError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SnoozeError, buf: ByteBuffer) {
        when(value) {
            is SnoozeError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeSnoozeErrorReason.write(value.v1, buf)
                Unit
            }
            is SnoozeError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class SnoozeErrorReason {
    
    SNOOZE_TIME_IN_THE_PAST,
    INVALID_SNOOZE_LOCATION;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSnoozeErrorReason: FfiConverterRustBuffer<SnoozeErrorReason> {
    override fun read(buf: ByteBuffer) = try {
        SnoozeErrorReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SnoozeErrorReason) = 4UL

    override fun write(value: SnoozeErrorReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SnoozeTime {
    
    data class Tomorrow(
        val v1: UnixTimestamp) : SnoozeTime() {
        companion object
    }
    
    data class LaterThisWeek(
        val v1: UnixTimestamp) : SnoozeTime() {
        companion object
    }
    
    data class ThisWeekend(
        val v1: UnixTimestamp) : SnoozeTime() {
        companion object
    }
    
    data class NextWeek(
        val v1: UnixTimestamp) : SnoozeTime() {
        companion object
    }
    
    object Custom : SnoozeTime()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSnoozeTime : FfiConverterRustBuffer<SnoozeTime>{
    override fun read(buf: ByteBuffer): SnoozeTime {
        return when(buf.getInt()) {
            1 -> SnoozeTime.Tomorrow(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            2 -> SnoozeTime.LaterThisWeek(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            3 -> SnoozeTime.ThisWeekend(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            4 -> SnoozeTime.NextWeek(
                FfiConverterTypeUnixTimestamp.read(buf),
                )
            5 -> SnoozeTime.Custom
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SnoozeTime) = when(value) {
        is SnoozeTime.Tomorrow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.v1)
            )
        }
        is SnoozeTime.LaterThisWeek -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.v1)
            )
        }
        is SnoozeTime.ThisWeekend -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.v1)
            )
        }
        is SnoozeTime.NextWeek -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnixTimestamp.allocationSize(value.v1)
            )
        }
        is SnoozeTime.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: SnoozeTime, buf: ByteBuffer) {
        when(value) {
            is SnoozeTime.Tomorrow -> {
                buf.putInt(1)
                FfiConverterTypeUnixTimestamp.write(value.v1, buf)
                Unit
            }
            is SnoozeTime.LaterThisWeek -> {
                buf.putInt(2)
                FfiConverterTypeUnixTimestamp.write(value.v1, buf)
                Unit
            }
            is SnoozeTime.ThisWeekend -> {
                buf.putInt(3)
                FfiConverterTypeUnixTimestamp.write(value.v1, buf)
                Unit
            }
            is SnoozeTime.NextWeek -> {
                buf.putInt(4)
                FfiConverterTypeUnixTimestamp.write(value.v1, buf)
                Unit
            }
            is SnoozeTime.Custom -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class SpamAction(val value: kotlin.UByte) {
    
    DO_NOTHING(0u),
    UNSUBSCRIBE_WITH_ONE_CLICK(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSpamAction: FfiConverterRustBuffer<SpamAction> {
    override fun read(buf: ByteBuffer) = try {
        SpamAction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SpamAction) = 4UL

    override fun write(value: SpamAction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SpamOrTrash {
    
    SPAM,
    TRASH;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSpamOrTrash: FfiConverterRustBuffer<SpamOrTrash> {
    override fun read(buf: ByteBuffer) = try {
        SpamOrTrash.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SpamOrTrash) = 4UL

    override fun write(value: SpamOrTrash, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Represents the state of an account.
 */
sealed class StoredAccountState {
    
    /**
     * The account is not yet ready to be used.
     */
    object NotReady : StoredAccountState()
    
    
    /**
     * The account has at least one fully logged-in session;
     * the variant holds the (remote) IDs of the fullly logged-in sessions.
     */
    data class LoggedIn(
        val v1: List<kotlin.String>) : StoredAccountState() {
        companion object
    }
    
    /**
     * The account has authenticated sessions but they are missing the key secret.
     * The variant holds the (remote) IDs of the sessions that are missing the key secret.
     */
    data class NeedMbp(
        val v1: List<kotlin.String>) : StoredAccountState() {
        companion object
    }
    
    /**
     * The account has partially authenticated sessions that require a second factor.
     * The variant holds the (remote) IDs of the sessions that require a second factor.
     */
    data class NeedTfa(
        val v1: List<kotlin.String>) : StoredAccountState() {
        companion object
    }
    
    /**
     * The account has a temporary password that must be set before it can be used.
     * The variant holds the (remote) IDs of the sessions that require a new password.
     */
    data class NeedNewPass(
        val v1: List<kotlin.String>) : StoredAccountState() {
        companion object
    }
    
    /**
     * The account has no active sessions.
     */
    object LoggedOut : StoredAccountState()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStoredAccountState : FfiConverterRustBuffer<StoredAccountState>{
    override fun read(buf: ByteBuffer): StoredAccountState {
        return when(buf.getInt()) {
            1 -> StoredAccountState.NotReady
            2 -> StoredAccountState.LoggedIn(
                FfiConverterSequenceString.read(buf),
                )
            3 -> StoredAccountState.NeedMbp(
                FfiConverterSequenceString.read(buf),
                )
            4 -> StoredAccountState.NeedTfa(
                FfiConverterSequenceString.read(buf),
                )
            5 -> StoredAccountState.NeedNewPass(
                FfiConverterSequenceString.read(buf),
                )
            6 -> StoredAccountState.LoggedOut
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StoredAccountState) = when(value) {
        is StoredAccountState.NotReady -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StoredAccountState.LoggedIn -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is StoredAccountState.NeedMbp -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is StoredAccountState.NeedTfa -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is StoredAccountState.NeedNewPass -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.v1)
            )
        }
        is StoredAccountState.LoggedOut -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: StoredAccountState, buf: ByteBuffer) {
        when(value) {
            is StoredAccountState.NotReady -> {
                buf.putInt(1)
                Unit
            }
            is StoredAccountState.LoggedIn -> {
                buf.putInt(2)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is StoredAccountState.NeedMbp -> {
                buf.putInt(3)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is StoredAccountState.NeedTfa -> {
                buf.putInt(4)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is StoredAccountState.NeedNewPass -> {
                buf.putInt(5)
                FfiConverterSequenceString.write(value.v1, buf)
                Unit
            }
            is StoredAccountState.LoggedOut -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Represents the state of a session.
 */

enum class StoredSessionState {
    
    /**
     * The session is fully authenticated and ready to use.
     */
    AUTHENTICATED,
    /**
     * The session has authenticated but is missing the key secret.
     */
    NEED_KEY,
    /**
     * The session has partially authenticated and requires a second factor.
     */
    NEED_TFA;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeStoredSessionState: FfiConverterRustBuffer<StoredSessionState> {
    override fun read(buf: ByteBuffer) = try {
        StoredSessionState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: StoredSessionState) = 4UL

    override fun write(value: StoredSessionState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SwipeAction {
    
    NO_ACTION,
    TRASH,
    SPAM,
    STAR,
    ARCHIVE,
    MARK_AS_READ,
    LABEL_AS,
    MOVE_TO;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSwipeAction: FfiConverterRustBuffer<SwipeAction> {
    override fun read(buf: ByteBuffer) = try {
        SwipeAction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SwipeAction) = 4UL

    override fun write(value: SwipeAction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SwipeActionMoveToTarget {
    
    data class MoveToSystemLabel(
        val `label`: SystemLabel, 
        val `id`: Id) : SwipeActionMoveToTarget() {
        companion object
    }
    
    /**
     * Swipe action requires extra popup for user to choose the target
     */
    object MoveToUnknownLabel : SwipeActionMoveToTarget()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSwipeActionMoveToTarget : FfiConverterRustBuffer<SwipeActionMoveToTarget>{
    override fun read(buf: ByteBuffer): SwipeActionMoveToTarget {
        return when(buf.getInt()) {
            1 -> SwipeActionMoveToTarget.MoveToSystemLabel(
                FfiConverterTypeSystemLabel.read(buf),
                FfiConverterTypeId.read(buf),
                )
            2 -> SwipeActionMoveToTarget.MoveToUnknownLabel
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SwipeActionMoveToTarget) = when(value) {
        is SwipeActionMoveToTarget.MoveToSystemLabel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSystemLabel.allocationSize(value.`label`)
                + FfiConverterTypeId.allocationSize(value.`id`)
            )
        }
        is SwipeActionMoveToTarget.MoveToUnknownLabel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: SwipeActionMoveToTarget, buf: ByteBuffer) {
        when(value) {
            is SwipeActionMoveToTarget.MoveToSystemLabel -> {
                buf.putInt(1)
                FfiConverterTypeSystemLabel.write(value.`label`, buf)
                FfiConverterTypeId.write(value.`id`, buf)
                Unit
            }
            is SwipeActionMoveToTarget.MoveToUnknownLabel -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * This enum represents the system labels that are available in ProtonMail.
 * Their values corresponds to the remote ids of the labels in the core API database.
 */

enum class SystemLabel(val value: kotlin.UByte) {
    
    INBOX(0u),
    ALL_DRAFTS(1u),
    ALL_SENT(2u),
    TRASH(3u),
    SPAM(4u),
    ALL_MAIL(5u),
    ARCHIVE(6u),
    SENT(7u),
    DRAFTS(8u),
    OUTBOX(9u),
    STARRED(10u),
    SCHEDULED(12u),
    BLOCKED(14u),
    ALMOST_ALL_MAIL(15u),
    SNOOZED(16u),
    PINNED(17u),
    CATEGORY_SOCIAL(20u),
    CATEGORY_PROMOTIONS(21u),
    CATERGORY_UPDATES(22u),
    CATEGORY_FORUMS(23u),
    CATEGORY_DEFAULT(24u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSystemLabel: FfiConverterRustBuffer<SystemLabel> {
    override fun read(buf: ByteBuffer) = try {
        SystemLabel.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SystemLabel) = 4UL

    override fun write(value: SystemLabel, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * TODO: Document this enum.
 */

enum class TfaStatus(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    NONE(0u),
    /**
     * TODO: Document this variant.
     */
    TOTP(1u),
    /**
     * TODO: Document this variant.
     */
    FIDO2(2u),
    /**
     * TODO: Document this variant.
     */
    TOTP_OR_FIDO2(3u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTfaStatus: FfiConverterRustBuffer<TfaStatus> {
    override fun read(buf: ByteBuffer) = try {
        TfaStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TfaStatus) = 4UL

    override fun write(value: TfaStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * TODO: Document this enum.
 */

enum class TimeFormat(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    DEFAULT(0u),
    /**
     * TODO: Document this variant.
     */
    H24(1u),
    /**
     * TODO: Document this variant.
     */
    H12(2u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTimeFormat: FfiConverterRustBuffer<TimeFormat> {
    override fun read(buf: ByteBuffer) = try {
        TimeFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TimeFormat) = 4UL

    override fun write(value: TimeFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class TrackerInfoWithStatus {
    
    object Pending : TrackerInfoWithStatus()
    
    
    /**
     * User disabled using Image Proxy
     */
    object Disabled : TrackerInfoWithStatus()
    
    
    data class Detected(
        val v1: TrackerInfo) : TrackerInfoWithStatus() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTrackerInfoWithStatus : FfiConverterRustBuffer<TrackerInfoWithStatus>{
    override fun read(buf: ByteBuffer): TrackerInfoWithStatus {
        return when(buf.getInt()) {
            1 -> TrackerInfoWithStatus.Pending
            2 -> TrackerInfoWithStatus.Disabled
            3 -> TrackerInfoWithStatus.Detected(
                FfiConverterTypeTrackerInfo.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TrackerInfoWithStatus) = when(value) {
        is TrackerInfoWithStatus.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TrackerInfoWithStatus.Disabled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TrackerInfoWithStatus.Detected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTrackerInfo.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TrackerInfoWithStatus, buf: ByteBuffer) {
        when(value) {
            is TrackerInfoWithStatus.Pending -> {
                buf.putInt(1)
                Unit
            }
            is TrackerInfoWithStatus.Disabled -> {
                buf.putInt(2)
                Unit
            }
            is TrackerInfoWithStatus.Detected -> {
                buf.putInt(3)
                FfiConverterTypeTrackerInfo.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class UndoUndoResult {
    
    object Ok : UndoUndoResult()
    
    
    data class Error(
        val v1: ActionError) : UndoUndoResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUndoUndoResult : FfiConverterRustBuffer<UndoUndoResult>{
    override fun read(buf: ByteBuffer): UndoUndoResult {
        return when(buf.getInt()) {
            1 -> UndoUndoResult.Ok
            2 -> UndoUndoResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UndoUndoResult) = when(value) {
        is UndoUndoResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UndoUndoResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UndoUndoResult, buf: ByteBuffer) {
        when(value) {
            is UndoUndoResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is UndoUndoResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Categories for Unexpected error
 */

enum class UnexpectedError {
    
    /**
     * Error related to API values (not API error)
     */
    API,
    /**
     * Error related to cryptography
     */
    CRYPTO,
    /**
     * Error related to internal app configuration
     */
    CONFIG,
    /**
     * Error related to the database
     */
    DATABASE,
    /**
     * Error related to an operation on file system
     */
    FILE_SYSTEM,
    /**
     * Error related to an internal operation
     */
    INTERNAL,
    /**
     * Some argument is invalid
     */
    INVALID_ARGUMENT,
    /**
     * Error related with memory
     */
    MEMORY,
    /**
     * Error related with network
     */
    NETWORK,
    /**
     * Error related to an OS operation
     */
    OS,
    /**
     * Error related to the event queue
     */
    QUEUE,
    /**
     * Error related to the composing draft
     */
    DRAFT,
    /**
     * Error mapping failed, this is serious issue and has to be addressed asap
     */
    ERROR_MAPPING,
    /**
     * Error with no identified operation
     */
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeUnexpectedError: FfiConverterRustBuffer<UnexpectedError> {
    override fun read(buf: ByteBuffer) = try {
        UnexpectedError.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UnexpectedError) = 4UL

    override fun write(value: UnexpectedError, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class UnsnoozeConversationsResult {
    
    object Ok : UnsnoozeConversationsResult()
    
    
    data class Error(
        val v1: SnoozeError) : UnsnoozeConversationsResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUnsnoozeConversationsResult : FfiConverterRustBuffer<UnsnoozeConversationsResult>{
    override fun read(buf: ByteBuffer): UnsnoozeConversationsResult {
        return when(buf.getInt()) {
            1 -> UnsnoozeConversationsResult.Ok
            2 -> UnsnoozeConversationsResult.Error(
                FfiConverterTypeSnoozeError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UnsnoozeConversationsResult) = when(value) {
        is UnsnoozeConversationsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UnsnoozeConversationsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSnoozeError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UnsnoozeConversationsResult, buf: ByteBuffer) {
        when(value) {
            is UnsnoozeConversationsResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is UnsnoozeConversationsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeSnoozeError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class UpdateNextMessageOnMoveResult {
    
    object Ok : UpdateNextMessageOnMoveResult()
    
    
    data class Error(
        val v1: UserSessionError) : UpdateNextMessageOnMoveResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUpdateNextMessageOnMoveResult : FfiConverterRustBuffer<UpdateNextMessageOnMoveResult>{
    override fun read(buf: ByteBuffer): UpdateNextMessageOnMoveResult {
        return when(buf.getInt()) {
            1 -> UpdateNextMessageOnMoveResult.Ok
            2 -> UpdateNextMessageOnMoveResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UpdateNextMessageOnMoveResult) = when(value) {
        is UpdateNextMessageOnMoveResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UpdateNextMessageOnMoveResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UpdateNextMessageOnMoveResult, buf: ByteBuffer) {
        when(value) {
            is UpdateNextMessageOnMoveResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is UpdateNextMessageOnMoveResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class UpsellEligibility {
    
    object NotEligible : UpsellEligibility()
    
    
    data class Eligible(
        val v1: UpsellType) : UpsellEligibility() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUpsellEligibility : FfiConverterRustBuffer<UpsellEligibility>{
    override fun read(buf: ByteBuffer): UpsellEligibility {
        return when(buf.getInt()) {
            1 -> UpsellEligibility.NotEligible
            2 -> UpsellEligibility.Eligible(
                FfiConverterTypeUpsellType.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UpsellEligibility) = when(value) {
        is UpsellEligibility.NotEligible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UpsellEligibility.Eligible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUpsellType.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UpsellEligibility, buf: ByteBuffer) {
        when(value) {
            is UpsellEligibility.NotEligible -> {
                buf.putInt(1)
                Unit
            }
            is UpsellEligibility.Eligible -> {
                buf.putInt(2)
                FfiConverterTypeUpsellType.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class UpsellEntryPoint {
    
    AUTO_DELETE_MESSAGES,
    CONTACT_GROUPS,
    DOLLAR_PROMO,
    FOLDERS_CREATION,
    LABELS_CREATION,
    MAILBOX_TOP_BAR,
    MAILBOX_TOP_BAR_PROMO,
    NAVBAR_UPSELL,
    MOBILE_SIGNATURE_EDIT,
    POST_ONBOARDING,
    SCHEDULE_SEND,
    SNOOZE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeUpsellEntryPoint: FfiConverterRustBuffer<UpsellEntryPoint> {
    override fun read(buf: ByteBuffer) = try {
        UpsellEntryPoint.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UpsellEntryPoint) = 4UL

    override fun write(value: UpsellEntryPoint, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class UpsellType {
    
    object Standard : UpsellType()
    
    
    data class BlackFriday(
        val v1: BlackFridayWave) : UpsellType() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUpsellType : FfiConverterRustBuffer<UpsellType>{
    override fun read(buf: ByteBuffer): UpsellType {
        return when(buf.getInt()) {
            1 -> UpsellType.Standard
            2 -> UpsellType.BlackFriday(
                FfiConverterTypeBlackFridayWave.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UpsellType) = when(value) {
        is UpsellType.Standard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UpsellType.BlackFriday -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBlackFridayWave.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UpsellType, buf: ByteBuffer) {
        when(value) {
            is UpsellType.Standard -> {
                buf.putInt(1)
                Unit
            }
            is UpsellType.BlackFriday -> {
                buf.putInt(2)
                FfiConverterTypeBlackFridayWave.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class UserMnemonicStatus(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    DISABLED(0u),
    /**
     * TODO: Document this variant.
     */
    ENABLED_BUT_NOT_SET(1u),
    /**
     * TODO: Document this variant.
     */
    ENABLED_NEEDS_REACTIVATION(2u),
    /**
     * TODO: Document this variant.
     */
    ENABLED_AND_SET(3u),
    /**
     * TODO: Document this variant.
     */
    UNKNOWN(4u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeUserMnemonicStatus: FfiConverterRustBuffer<UserMnemonicStatus> {
    override fun read(buf: ByteBuffer) = try {
        UserMnemonicStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UserMnemonicStatus) = 4UL

    override fun write(value: UserMnemonicStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class UserSessionError {
    
    data class Reason(
        val v1: SessionReason) : UserSessionError() {
        companion object
    }
    
    data class Other(
        val v1: ProtonError) : UserSessionError() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserSessionError : FfiConverterRustBuffer<UserSessionError>{
    override fun read(buf: ByteBuffer): UserSessionError {
        return when(buf.getInt()) {
            1 -> UserSessionError.Reason(
                FfiConverterTypeSessionReason.read(buf),
                )
            2 -> UserSessionError.Other(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UserSessionError) = when(value) {
        is UserSessionError.Reason -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSessionReason.allocationSize(value.v1)
            )
        }
        is UserSessionError.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UserSessionError, buf: ByteBuffer) {
        when(value) {
            is UserSessionError.Reason -> {
                buf.putInt(1)
                FfiConverterTypeSessionReason.write(value.v1, buf)
                Unit
            }
            is UserSessionError.Other -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */
sealed class UserType {
    
    /**
     * TODO: Document this variant.
     */
    object Proton : UserType()
    
    
    /**
     * TODO: Document this variant.
     */
    object Managed : UserType()
    
    
    /**
     * TODO: Document this variant.
     */
    object External : UserType()
    
    
    /**
     * Credentialless user
     */
    object CredentialLess : UserType()
    
    
    /**
     * TODO: Document this variant.
     */
    data class Unknown(
        val v1: kotlin.UByte) : UserType() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserType : FfiConverterRustBuffer<UserType>{
    override fun read(buf: ByteBuffer): UserType {
        return when(buf.getInt()) {
            1 -> UserType.Proton
            2 -> UserType.Managed
            3 -> UserType.External
            4 -> UserType.CredentialLess
            5 -> UserType.Unknown(
                FfiConverterUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UserType) = when(value) {
        is UserType.Proton -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UserType.Managed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UserType.External -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UserType.CredentialLess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is UserType.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UserType, buf: ByteBuffer) {
        when(value) {
            is UserType.Proton -> {
                buf.putInt(1)
                Unit
            }
            is UserType.Managed -> {
                buf.putInt(2)
                Unit
            }
            is UserType.External -> {
                buf.putInt(3)
                Unit
            }
            is UserType.CredentialLess -> {
                buf.putInt(4)
                Unit
            }
            is UserType.Unknown -> {
                buf.putInt(5)
                FfiConverterUByte.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VCardUrlValue {
    
    data class Http(
        val v1: kotlin.String) : VCardUrlValue() {
        companion object
    }
    
    data class NotHttp(
        val v1: kotlin.String) : VCardUrlValue() {
        companion object
    }
    
    data class Text(
        val v1: kotlin.String) : VCardUrlValue() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVCardUrlValue : FfiConverterRustBuffer<VCardUrlValue>{
    override fun read(buf: ByteBuffer): VCardUrlValue {
        return when(buf.getInt()) {
            1 -> VCardUrlValue.Http(
                FfiConverterString.read(buf),
                )
            2 -> VCardUrlValue.NotHttp(
                FfiConverterString.read(buf),
                )
            3 -> VCardUrlValue.Text(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VCardUrlValue) = when(value) {
        is VCardUrlValue.Http -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is VCardUrlValue.NotHttp -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is VCardUrlValue.Text -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VCardUrlValue, buf: ByteBuffer) {
        when(value) {
            is VCardUrlValue.Http -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VCardUrlValue.NotHttp -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VCardUrlValue.Text -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VcardPropType {
    
    object Home : VcardPropType()
    
    
    object Work : VcardPropType()
    
    
    object Text : VcardPropType()
    
    
    object Voice : VcardPropType()
    
    
    object Fax : VcardPropType()
    
    
    object Cell : VcardPropType()
    
    
    object Video : VcardPropType()
    
    
    object Pager : VcardPropType()
    
    
    object TextPhone : VcardPropType()
    
    
    data class String(
        val v1: kotlin.String) : VcardPropType() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVcardPropType : FfiConverterRustBuffer<VcardPropType>{
    override fun read(buf: ByteBuffer): VcardPropType {
        return when(buf.getInt()) {
            1 -> VcardPropType.Home
            2 -> VcardPropType.Work
            3 -> VcardPropType.Text
            4 -> VcardPropType.Voice
            5 -> VcardPropType.Fax
            6 -> VcardPropType.Cell
            7 -> VcardPropType.Video
            8 -> VcardPropType.Pager
            9 -> VcardPropType.TextPhone
            10 -> VcardPropType.String(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VcardPropType) = when(value) {
        is VcardPropType.Home -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Work -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Text -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Voice -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Fax -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Cell -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Video -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.Pager -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.TextPhone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VcardPropType.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VcardPropType, buf: ByteBuffer) {
        when(value) {
            is VcardPropType.Home -> {
                buf.putInt(1)
                Unit
            }
            is VcardPropType.Work -> {
                buf.putInt(2)
                Unit
            }
            is VcardPropType.Text -> {
                buf.putInt(3)
                Unit
            }
            is VcardPropType.Voice -> {
                buf.putInt(4)
                Unit
            }
            is VcardPropType.Fax -> {
                buf.putInt(5)
                Unit
            }
            is VcardPropType.Cell -> {
                buf.putInt(6)
                Unit
            }
            is VcardPropType.Video -> {
                buf.putInt(7)
                Unit
            }
            is VcardPropType.Pager -> {
                buf.putInt(8)
                Unit
            }
            is VcardPropType.TextPhone -> {
                buf.putInt(9)
                Unit
            }
            is VcardPropType.String -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ViewLayout(val value: kotlin.UByte) {
    
    COLUMN(0u),
    ROW(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeViewLayout: FfiConverterRustBuffer<ViewLayout> {
    override fun read(buf: ByteBuffer) = try {
        ViewLayout.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ViewLayout) = 4UL

    override fun write(value: ViewLayout, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ViewMode(val value: kotlin.UByte) {
    
    CONVERSATIONS(0u),
    MESSAGES(1u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeViewMode: FfiConverterRustBuffer<ViewMode> {
    override fun read(buf: ByteBuffer) = try {
        ViewMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ViewMode) = 4UL

    override fun write(value: ViewMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class VoidActionResult {
    
    object Ok : VoidActionResult()
    
    
    data class Error(
        val v1: ActionError) : VoidActionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidActionResult : FfiConverterRustBuffer<VoidActionResult>{
    override fun read(buf: ByteBuffer): VoidActionResult {
        return when(buf.getInt()) {
            1 -> VoidActionResult.Ok
            2 -> VoidActionResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidActionResult) = when(value) {
        is VoidActionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidActionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidActionResult, buf: ByteBuffer) {
        when(value) {
            is VoidActionResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidActionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidAnswerRsvpResult {
    
    object Ok : VoidAnswerRsvpResult()
    
    
    data class Error(
        val v1: ProtonError) : VoidAnswerRsvpResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidAnswerRsvpResult : FfiConverterRustBuffer<VoidAnswerRsvpResult>{
    override fun read(buf: ByteBuffer): VoidAnswerRsvpResult {
        return when(buf.getInt()) {
            1 -> VoidAnswerRsvpResult.Ok
            2 -> VoidAnswerRsvpResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidAnswerRsvpResult) = when(value) {
        is VoidAnswerRsvpResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidAnswerRsvpResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidAnswerRsvpResult, buf: ByteBuffer) {
        when(value) {
            is VoidAnswerRsvpResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidAnswerRsvpResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftAttachmentDispositionSwapResult {
    
    object Ok : VoidDraftAttachmentDispositionSwapResult()
    
    
    data class Error(
        val v1: DraftAttachmentDispositionSwapError) : VoidDraftAttachmentDispositionSwapResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftAttachmentDispositionSwapResult : FfiConverterRustBuffer<VoidDraftAttachmentDispositionSwapResult>{
    override fun read(buf: ByteBuffer): VoidDraftAttachmentDispositionSwapResult {
        return when(buf.getInt()) {
            1 -> VoidDraftAttachmentDispositionSwapResult.Ok
            2 -> VoidDraftAttachmentDispositionSwapResult.Error(
                FfiConverterTypeDraftAttachmentDispositionSwapError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftAttachmentDispositionSwapResult) = when(value) {
        is VoidDraftAttachmentDispositionSwapResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftAttachmentDispositionSwapResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftAttachmentDispositionSwapError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftAttachmentDispositionSwapResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftAttachmentDispositionSwapResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftAttachmentDispositionSwapResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftAttachmentDispositionSwapError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftDiscardResult {
    
    object Ok : VoidDraftDiscardResult()
    
    
    data class Error(
        val v1: DraftDiscardError) : VoidDraftDiscardResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftDiscardResult : FfiConverterRustBuffer<VoidDraftDiscardResult>{
    override fun read(buf: ByteBuffer): VoidDraftDiscardResult {
        return when(buf.getInt()) {
            1 -> VoidDraftDiscardResult.Ok
            2 -> VoidDraftDiscardResult.Error(
                FfiConverterTypeDraftDiscardError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftDiscardResult) = when(value) {
        is VoidDraftDiscardResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftDiscardResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftDiscardError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftDiscardResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftDiscardResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftDiscardResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftDiscardError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftExpirationResult {
    
    object Ok : VoidDraftExpirationResult()
    
    
    data class Error(
        val v1: DraftExpirationError) : VoidDraftExpirationResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftExpirationResult : FfiConverterRustBuffer<VoidDraftExpirationResult>{
    override fun read(buf: ByteBuffer): VoidDraftExpirationResult {
        return when(buf.getInt()) {
            1 -> VoidDraftExpirationResult.Ok
            2 -> VoidDraftExpirationResult.Error(
                FfiConverterTypeDraftExpirationError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftExpirationResult) = when(value) {
        is VoidDraftExpirationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftExpirationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftExpirationError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftExpirationResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftExpirationResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftExpirationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftExpirationError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftPasswordResult {
    
    object Ok : VoidDraftPasswordResult()
    
    
    data class Error(
        val v1: DraftPasswordError) : VoidDraftPasswordResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftPasswordResult : FfiConverterRustBuffer<VoidDraftPasswordResult>{
    override fun read(buf: ByteBuffer): VoidDraftPasswordResult {
        return when(buf.getInt()) {
            1 -> VoidDraftPasswordResult.Ok
            2 -> VoidDraftPasswordResult.Error(
                FfiConverterTypeDraftPasswordError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftPasswordResult) = when(value) {
        is VoidDraftPasswordResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftPasswordResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftPasswordError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftPasswordResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftPasswordResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftPasswordResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftPasswordError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftSaveResult {
    
    object Ok : VoidDraftSaveResult()
    
    
    data class Error(
        val v1: DraftSaveError) : VoidDraftSaveResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftSaveResult : FfiConverterRustBuffer<VoidDraftSaveResult>{
    override fun read(buf: ByteBuffer): VoidDraftSaveResult {
        return when(buf.getInt()) {
            1 -> VoidDraftSaveResult.Ok
            2 -> VoidDraftSaveResult.Error(
                FfiConverterTypeDraftSaveError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftSaveResult) = when(value) {
        is VoidDraftSaveResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftSaveResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSaveError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftSaveResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftSaveResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftSaveResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftSaveError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftSendResult {
    
    object Ok : VoidDraftSendResult()
    
    
    data class Error(
        val v1: DraftSendError) : VoidDraftSendResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftSendResult : FfiConverterRustBuffer<VoidDraftSendResult>{
    override fun read(buf: ByteBuffer): VoidDraftSendResult {
        return when(buf.getInt()) {
            1 -> VoidDraftSendResult.Ok
            2 -> VoidDraftSendResult.Error(
                FfiConverterTypeDraftSendError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftSendResult) = when(value) {
        is VoidDraftSendResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftSendResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftSendError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftSendResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftSendResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftSendResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftSendError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidDraftUndoSendResult {
    
    object Ok : VoidDraftUndoSendResult()
    
    
    data class Error(
        val v1: DraftUndoSendError) : VoidDraftUndoSendResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidDraftUndoSendResult : FfiConverterRustBuffer<VoidDraftUndoSendResult>{
    override fun read(buf: ByteBuffer): VoidDraftUndoSendResult {
        return when(buf.getInt()) {
            1 -> VoidDraftUndoSendResult.Ok
            2 -> VoidDraftUndoSendResult.Error(
                FfiConverterTypeDraftUndoSendError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidDraftUndoSendResult) = when(value) {
        is VoidDraftUndoSendResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidDraftUndoSendResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDraftUndoSendError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidDraftUndoSendResult, buf: ByteBuffer) {
        when(value) {
            is VoidDraftUndoSendResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidDraftUndoSendResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeDraftUndoSendError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidEventResult {
    
    object Ok : VoidEventResult()
    
    
    data class Error(
        val v1: EventError) : VoidEventResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidEventResult : FfiConverterRustBuffer<VoidEventResult>{
    override fun read(buf: ByteBuffer): VoidEventResult {
        return when(buf.getInt()) {
            1 -> VoidEventResult.Ok
            2 -> VoidEventResult.Error(
                FfiConverterTypeEventError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidEventResult) = when(value) {
        is VoidEventResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidEventResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEventError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidEventResult, buf: ByteBuffer) {
        when(value) {
            is VoidEventResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidEventResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeEventError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidProtonResult {
    
    object Ok : VoidProtonResult()
    
    
    data class Error(
        val v1: ProtonError) : VoidProtonResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidProtonResult : FfiConverterRustBuffer<VoidProtonResult>{
    override fun read(buf: ByteBuffer): VoidProtonResult {
        return when(buf.getInt()) {
            1 -> VoidProtonResult.Ok
            2 -> VoidProtonResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidProtonResult) = when(value) {
        is VoidProtonResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidProtonResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidProtonResult, buf: ByteBuffer) {
        when(value) {
            is VoidProtonResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidProtonResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class VoidSessionResult {
    
    object Ok : VoidSessionResult()
    
    
    data class Error(
        val v1: UserSessionError) : VoidSessionResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeVoidSessionResult : FfiConverterRustBuffer<VoidSessionResult>{
    override fun read(buf: ByteBuffer): VoidSessionResult {
        return when(buf.getInt()) {
            1 -> VoidSessionResult.Ok
            2 -> VoidSessionResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VoidSessionResult) = when(value) {
        is VoidSessionResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VoidSessionResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VoidSessionResult, buf: ByteBuffer) {
        when(value) {
            is VoidSessionResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is VoidSessionResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchContactListResult: Disposable  {
    
    data class Ok(
        val v1: WatchedContactList) : WatchContactListResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : WatchContactListResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WatchContactListResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WatchContactListResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchContactListResult : FfiConverterRustBuffer<WatchContactListResult>{
    override fun read(buf: ByteBuffer): WatchContactListResult {
        return when(buf.getInt()) {
            1 -> WatchContactListResult.Ok(
                FfiConverterTypeWatchedContactList.read(buf),
                )
            2 -> WatchContactListResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchContactListResult) = when(value) {
        is WatchContactListResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchedContactList.allocationSize(value.v1)
            )
        }
        is WatchContactListResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchContactListResult, buf: ByteBuffer) {
        when(value) {
            is WatchContactListResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchedContactList.write(value.v1, buf)
                Unit
            }
            is WatchContactListResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchConversationResult: Disposable  {
    
    data class Ok(
        val v1: WatchedConversation?) : WatchConversationResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : WatchConversationResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WatchConversationResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WatchConversationResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchConversationResult : FfiConverterRustBuffer<WatchConversationResult>{
    override fun read(buf: ByteBuffer): WatchConversationResult {
        return when(buf.getInt()) {
            1 -> WatchConversationResult.Ok(
                FfiConverterOptionalTypeWatchedConversation.read(buf),
                )
            2 -> WatchConversationResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchConversationResult) = when(value) {
        is WatchConversationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeWatchedConversation.allocationSize(value.v1)
            )
        }
        is WatchConversationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchConversationResult, buf: ByteBuffer) {
        when(value) {
            is WatchConversationResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeWatchedConversation.write(value.v1, buf)
                Unit
            }
            is WatchConversationResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchMailSettingsResult: Disposable  {
    
    data class Ok(
        val v1: SettingsWatcher) : WatchMailSettingsResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : WatchMailSettingsResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WatchMailSettingsResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WatchMailSettingsResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchMailSettingsResult : FfiConverterRustBuffer<WatchMailSettingsResult>{
    override fun read(buf: ByteBuffer): WatchMailSettingsResult {
        return when(buf.getInt()) {
            1 -> WatchMailSettingsResult.Ok(
                FfiConverterTypeSettingsWatcher.read(buf),
                )
            2 -> WatchMailSettingsResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchMailSettingsResult) = when(value) {
        is WatchMailSettingsResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSettingsWatcher.allocationSize(value.v1)
            )
        }
        is WatchMailSettingsResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchMailSettingsResult, buf: ByteBuffer) {
        when(value) {
            is WatchMailSettingsResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeSettingsWatcher.write(value.v1, buf)
                Unit
            }
            is WatchMailSettingsResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchMessageResult: Disposable  {
    
    data class Ok(
        val v1: WatchedMessage?) : WatchMessageResult() {
        companion object
    }
    
    data class Error(
        val v1: ActionError) : WatchMessageResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WatchMessageResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WatchMessageResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchMessageResult : FfiConverterRustBuffer<WatchMessageResult>{
    override fun read(buf: ByteBuffer): WatchMessageResult {
        return when(buf.getInt()) {
            1 -> WatchMessageResult.Ok(
                FfiConverterOptionalTypeWatchedMessage.read(buf),
                )
            2 -> WatchMessageResult.Error(
                FfiConverterTypeActionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchMessageResult) = when(value) {
        is WatchMessageResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeWatchedMessage.allocationSize(value.v1)
            )
        }
        is WatchMessageResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeActionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchMessageResult, buf: ByteBuffer) {
        when(value) {
            is WatchMessageResult.Ok -> {
                buf.putInt(1)
                FfiConverterOptionalTypeWatchedMessage.write(value.v1, buf)
                Unit
            }
            is WatchMessageResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeActionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchPrivacyInfoStreamNextAsyncResult {
    
    data class Ok(
        val v1: PrivacyInfo) : WatchPrivacyInfoStreamNextAsyncResult() {
        companion object
    }
    
    data class Error(
        val v1: ProtonError) : WatchPrivacyInfoStreamNextAsyncResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchPrivacyInfoStreamNextAsyncResult : FfiConverterRustBuffer<WatchPrivacyInfoStreamNextAsyncResult>{
    override fun read(buf: ByteBuffer): WatchPrivacyInfoStreamNextAsyncResult {
        return when(buf.getInt()) {
            1 -> WatchPrivacyInfoStreamNextAsyncResult.Ok(
                FfiConverterTypePrivacyInfo.read(buf),
                )
            2 -> WatchPrivacyInfoStreamNextAsyncResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchPrivacyInfoStreamNextAsyncResult) = when(value) {
        is WatchPrivacyInfoStreamNextAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrivacyInfo.allocationSize(value.v1)
            )
        }
        is WatchPrivacyInfoStreamNextAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchPrivacyInfoStreamNextAsyncResult, buf: ByteBuffer) {
        when(value) {
            is WatchPrivacyInfoStreamNextAsyncResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypePrivacyInfo.write(value.v1, buf)
                Unit
            }
            is WatchPrivacyInfoStreamNextAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchPrivacyInfoStreamResult: Disposable  {
    
    data class Ok(
        val v1: WatchPrivacyInfoStream) : WatchPrivacyInfoStreamResult() {
        companion object
    }
    
    data class Error(
        val v1: UserSessionError) : WatchPrivacyInfoStreamResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WatchPrivacyInfoStreamResult.Ok -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WatchPrivacyInfoStreamResult.Error -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchPrivacyInfoStreamResult : FfiConverterRustBuffer<WatchPrivacyInfoStreamResult>{
    override fun read(buf: ByteBuffer): WatchPrivacyInfoStreamResult {
        return when(buf.getInt()) {
            1 -> WatchPrivacyInfoStreamResult.Ok(
                FfiConverterTypeWatchPrivacyInfoStream.read(buf),
                )
            2 -> WatchPrivacyInfoStreamResult.Error(
                FfiConverterTypeUserSessionError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchPrivacyInfoStreamResult) = when(value) {
        is WatchPrivacyInfoStreamResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWatchPrivacyInfoStream.allocationSize(value.v1)
            )
        }
        is WatchPrivacyInfoStreamResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserSessionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchPrivacyInfoStreamResult, buf: ByteBuffer) {
        when(value) {
            is WatchPrivacyInfoStreamResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeWatchPrivacyInfoStream.write(value.v1, buf)
                Unit
            }
            is WatchPrivacyInfoStreamResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeUserSessionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchUserFeatureFlagsStreamNextAsyncResult {
    
    object Ok : WatchUserFeatureFlagsStreamNextAsyncResult()
    
    
    data class Error(
        val v1: ProtonError) : WatchUserFeatureFlagsStreamNextAsyncResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchUserFeatureFlagsStreamNextAsyncResult : FfiConverterRustBuffer<WatchUserFeatureFlagsStreamNextAsyncResult>{
    override fun read(buf: ByteBuffer): WatchUserFeatureFlagsStreamNextAsyncResult {
        return when(buf.getInt()) {
            1 -> WatchUserFeatureFlagsStreamNextAsyncResult.Ok
            2 -> WatchUserFeatureFlagsStreamNextAsyncResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchUserFeatureFlagsStreamNextAsyncResult) = when(value) {
        is WatchUserFeatureFlagsStreamNextAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WatchUserFeatureFlagsStreamNextAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchUserFeatureFlagsStreamNextAsyncResult, buf: ByteBuffer) {
        when(value) {
            is WatchUserFeatureFlagsStreamNextAsyncResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is WatchUserFeatureFlagsStreamNextAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WatchUserStreamNextAsyncResult {
    
    object Ok : WatchUserStreamNextAsyncResult()
    
    
    data class Error(
        val v1: ProtonError) : WatchUserStreamNextAsyncResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchUserStreamNextAsyncResult : FfiConverterRustBuffer<WatchUserStreamNextAsyncResult>{
    override fun read(buf: ByteBuffer): WatchUserStreamNextAsyncResult {
        return when(buf.getInt()) {
            1 -> WatchUserStreamNextAsyncResult.Ok
            2 -> WatchUserStreamNextAsyncResult.Error(
                FfiConverterTypeProtonError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WatchUserStreamNextAsyncResult) = when(value) {
        is WatchUserStreamNextAsyncResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WatchUserStreamNextAsyncResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeProtonError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WatchUserStreamNextAsyncResult, buf: ByteBuffer) {
        when(value) {
            is WatchUserStreamNextAsyncResult.Ok -> {
                buf.putInt(1)
                Unit
            }
            is WatchUserStreamNextAsyncResult.Error -> {
                buf.putInt(2)
                FfiConverterTypeProtonError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * TODO: Document this enum.
 */

enum class WeekStart(val value: kotlin.UByte) {
    
    /**
     * TODO: Document this variant.
     */
    DEFAULT(0u),
    /**
     * TODO: Document this variant.
     */
    MONDAY(1u),
    /**
     * TODO: Document this variant.
     */
    SATURDAY(6u),
    /**
     * TODO: Document this variant.
     */
    SUNDAY(7u);
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWeekStart: FfiConverterRustBuffer<WeekStart> {
    override fun read(buf: ByteBuffer) = try {
        WeekStart.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WeekStart) = 4UL

    override fun write(value: WeekStart, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







public interface ContactsLiveQueryCallback {
    
    fun `onUpdate`(`contacts`: List<GroupedContacts>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceContactsLiveQueryCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceContactsLiveQueryCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`contacts`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeContactsLiveQueryCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeGroupedContacts.lift(`contacts`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeContactsLiveQueryCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceContactsLiveQueryCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_contactslivequerycallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeContactsLiveQueryCallback: FfiConverterCallbackInterface<ContactsLiveQueryCallback>()





public interface ConversationScrollerLiveQueryCallback {
    
    fun `onUpdate`(`update`: ConversationScrollerUpdate)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceConversationScrollerLiveQueryCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceConversationScrollerLiveQueryCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeConversationScrollerLiveQueryCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeConversationScrollerUpdate.lift(`update`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeConversationScrollerLiveQueryCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceConversationScrollerLiveQueryCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_conversationscrollerlivequerycallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeConversationScrollerLiveQueryCallback: FfiConverterCallbackInterface<ConversationScrollerLiveQueryCallback>()





/**
 * A callback interface for live queries.
 *
 * This interface is used to notify the client when observed data has been
 * updated.

 */
public interface LiveQueryCallback {
    
    /**
     * Notify the client that the observed data has been updated.
     *
     * This method is called when the observed data has been updated. It does
     * not provide any information about the update, but the client can use
     * this as a signal to refresh its view of the data.

     */
    fun `onUpdate`()
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceLiveQueryCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceLiveQueryCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLiveQueryCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeLiveQueryCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceLiveQueryCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_livequerycallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeLiveQueryCallback: FfiConverterCallbackInterface<LiveQueryCallback>()





public interface MailboxBackgroundResult {
    
    fun `onBackgroundResult`(`error`: UserSessionError?)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceMailboxBackgroundResult {
    internal object `onBackgroundResult`: UniffiCallbackInterfaceMailboxBackgroundResultMethod0 {
        override fun callback(`uniffiHandle`: Long,`error`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeMailboxBackgroundResult.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onBackgroundResult`(
                    FfiConverterOptionalTypeUserSessionError.lift(`error`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeMailboxBackgroundResult.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceMailboxBackgroundResult.UniffiByValue(
        `onBackgroundResult`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_mailboxbackgroundresult(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeMailboxBackgroundResult: FfiConverterCallbackInterface<MailboxBackgroundResult>()





public interface MessageScrollerLiveQueryCallback {
    
    fun `onUpdate`(`update`: MessageScrollerUpdate)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceMessageScrollerLiveQueryCallback {
    internal object `onUpdate`: UniffiCallbackInterfaceMessageScrollerLiveQueryCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeMessageScrollerLiveQueryCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeMessageScrollerUpdate.lift(`update`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeMessageScrollerLiveQueryCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceMessageScrollerLiveQueryCallback.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_messagescrollerlivequerycallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeMessageScrollerLiveQueryCallback: FfiConverterCallbackInterface<MessageScrollerLiveQueryCallback>()





/**
 * Interface for accessing the OS keychain.
 */
public interface OsKeyChain {
    
    /**
     * Store the secret in the keychain.
     */
    fun `store`(`kind`: OsKeyChainEntryKind, `key`: kotlin.String)
    
    /**
     * Remote the secret from the keychain.
     */
    fun `delete`(`kind`: OsKeyChainEntryKind)
    
    /**
     * Retrieve the secret from the keychain.
     */
    fun `load`(`kind`: OsKeyChainEntryKind): kotlin.String?
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceOSKeyChain {
    internal object `store`: UniffiCallbackInterfaceOsKeyChainMethod0 {
        override fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeOSKeyChain.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`store`(
                    FfiConverterTypeOSKeyChainEntryKind.lift(`kind`),
                    FfiConverterString.lift(`key`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: OsKeyChainException -> FfiConverterTypeOSKeyChainError.lower(e) }
            )
        }
    }
    internal object `delete`: UniffiCallbackInterfaceOsKeyChainMethod1 {
        override fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeOSKeyChain.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`delete`(
                    FfiConverterTypeOSKeyChainEntryKind.lift(`kind`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: OsKeyChainException -> FfiConverterTypeOSKeyChainError.lower(e) }
            )
        }
    }
    internal object `load`: UniffiCallbackInterfaceOsKeyChainMethod2 {
        override fun callback(`uniffiHandle`: Long,`kind`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeOSKeyChain.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`load`(
                    FfiConverterTypeOSKeyChainEntryKind.lift(`kind`),
                )
            }
            val writeReturn = { value: kotlin.String? -> uniffiOutReturn.setValue(FfiConverterOptionalString.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: OsKeyChainException -> FfiConverterTypeOSKeyChainError.lower(e) }
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeOSKeyChain.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceOsKeyChain.UniffiByValue(
        `store`,
        `delete`,
        `load`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_proton_mail_uniffi_fn_init_callback_vtable_oskeychain(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeOSKeyChain: FfiConverterCallbackInterface<OsKeyChain>()




/**
 * @suppress
 */
public object FfiConverterOptionalUByte: FfiConverterRustBuffer<kotlin.UByte?> {
    override fun read(buf: ByteBuffer): kotlin.UByte? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUByte.read(buf)
    }

    override fun allocationSize(value: kotlin.UByte?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUByte.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UByte?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUByte.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalUShort: FfiConverterRustBuffer<kotlin.UShort?> {
    override fun read(buf: ByteBuffer): kotlin.UShort? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUShort.read(buf)
    }

    override fun allocationSize(value: kotlin.UShort?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUShort.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UShort?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUShort.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalUInt: FfiConverterRustBuffer<kotlin.UInt?> {
    override fun read(buf: ByteBuffer): kotlin.UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: kotlin.UInt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalInt: FfiConverterRustBuffer<kotlin.Int?> {
    override fun read(buf: ByteBuffer): kotlin.Int? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterInt.read(buf)
    }

    override fun allocationSize(value: kotlin.Int?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Int?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalLong: FfiConverterRustBuffer<kotlin.Long?> {
    override fun read(buf: ByteBuffer): kotlin.Long? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterLong.read(buf)
    }

    override fun allocationSize(value: kotlin.Long?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterLong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Long?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterLong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalBoolean: FfiConverterRustBuffer<kotlin.Boolean?> {
    override fun read(buf: ByteBuffer): kotlin.Boolean? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterBoolean.read(buf)
    }

    override fun allocationSize(value: kotlin.Boolean?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterBoolean.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Boolean?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterBoolean.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePasswordValidatorService: FfiConverterRustBuffer<PasswordValidatorService?> {
    override fun read(buf: ByteBuffer): PasswordValidatorService? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePasswordValidatorService.read(buf)
    }

    override fun allocationSize(value: PasswordValidatorService?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePasswordValidatorService.allocationSize(value)
        }
    }

    override fun write(value: PasswordValidatorService?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePasswordValidatorService.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeChallengeNotifier: FfiConverterRustBuffer<ChallengeNotifier?> {
    override fun read(buf: ByteBuffer): ChallengeNotifier? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeChallengeNotifier.read(buf)
    }

    override fun allocationSize(value: ChallengeNotifier?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeChallengeNotifier.allocationSize(value)
        }
    }

    override fun write(value: ChallengeNotifier?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeChallengeNotifier.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDeviceInfoProvider: FfiConverterRustBuffer<DeviceInfoProvider?> {
    override fun read(buf: ByteBuffer): DeviceInfoProvider? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDeviceInfoProvider.read(buf)
    }

    override fun allocationSize(value: DeviceInfoProvider?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDeviceInfoProvider.allocationSize(value)
        }
    }

    override fun write(value: DeviceInfoProvider?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDeviceInfoProvider.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeMailUserSession: FfiConverterRustBuffer<MailUserSession?> {
    override fun read(buf: ByteBuffer): MailUserSession? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMailUserSession.read(buf)
    }

    override fun allocationSize(value: MailUserSession?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMailUserSession.allocationSize(value)
        }
    }

    override fun write(value: MailUserSession?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMailUserSession.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeResolver: FfiConverterRustBuffer<Resolver?> {
    override fun read(buf: ByteBuffer): Resolver? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeResolver.read(buf)
    }

    override fun allocationSize(value: Resolver?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeResolver.allocationSize(value)
        }
    }

    override fun write(value: Resolver?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeResolver.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeRsvpEventService: FfiConverterRustBuffer<RsvpEventService?> {
    override fun read(buf: ByteBuffer): RsvpEventService? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRsvpEventService.read(buf)
    }

    override fun allocationSize(value: RsvpEventService?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRsvpEventService.allocationSize(value)
        }
    }

    override fun write(value: RsvpEventService?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRsvpEventService.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeRsvpEventServiceProvider: FfiConverterRustBuffer<RsvpEventServiceProvider?> {
    override fun read(buf: ByteBuffer): RsvpEventServiceProvider? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRsvpEventServiceProvider.read(buf)
    }

    override fun allocationSize(value: RsvpEventServiceProvider?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRsvpEventServiceProvider.allocationSize(value)
        }
    }

    override fun write(value: RsvpEventServiceProvider?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRsvpEventServiceProvider.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeStoredAccount: FfiConverterRustBuffer<StoredAccount?> {
    override fun read(buf: ByteBuffer): StoredAccount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeStoredAccount.read(buf)
    }

    override fun allocationSize(value: StoredAccount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeStoredAccount.allocationSize(value)
        }
    }

    override fun write(value: StoredAccount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeStoredAccount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeStoredSession: FfiConverterRustBuffer<StoredSession?> {
    override fun read(buf: ByteBuffer): StoredSession? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeStoredSession.read(buf)
    }

    override fun allocationSize(value: StoredSession?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeStoredSession.allocationSize(value)
        }
    }

    override fun write(value: StoredSession?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeStoredSession.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUndo: FfiConverterRustBuffer<Undo?> {
    override fun read(buf: ByteBuffer): Undo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUndo.read(buf)
    }

    override fun allocationSize(value: Undo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUndo.allocationSize(value)
        }
    }

    override fun write(value: Undo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUndo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeApiConfig: FfiConverterRustBuffer<ApiConfig?> {
    override fun read(buf: ByteBuffer): ApiConfig? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeApiConfig.read(buf)
    }

    override fun allocationSize(value: ApiConfig?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeApiConfig.allocationSize(value)
        }
    }

    override fun write(value: ApiConfig?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeApiConfig.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAutoDeleteBanner: FfiConverterRustBuffer<AutoDeleteBanner?> {
    override fun read(buf: ByteBuffer): AutoDeleteBanner? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAutoDeleteBanner.read(buf)
    }

    override fun allocationSize(value: AutoDeleteBanner?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAutoDeleteBanner.allocationSize(value)
        }
    }

    override fun write(value: AutoDeleteBanner?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAutoDeleteBanner.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeConversation: FfiConverterRustBuffer<Conversation?> {
    override fun read(buf: ByteBuffer): Conversation? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeConversation.read(buf)
    }

    override fun allocationSize(value: Conversation?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeConversation.allocationSize(value)
        }
    }

    override fun write(value: Conversation?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeConversation.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeConversationAndMessages: FfiConverterRustBuffer<ConversationAndMessages?> {
    override fun read(buf: ByteBuffer): ConversationAndMessages? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeConversationAndMessages.read(buf)
    }

    override fun allocationSize(value: ConversationAndMessages?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeConversationAndMessages.allocationSize(value)
        }
    }

    override fun write(value: ConversationAndMessages?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeConversationAndMessages.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDraftAddressValidationResult: FfiConverterRustBuffer<DraftAddressValidationResult?> {
    override fun read(buf: ByteBuffer): DraftAddressValidationResult? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDraftAddressValidationResult.read(buf)
    }

    override fun allocationSize(value: DraftAddressValidationResult?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDraftAddressValidationResult.allocationSize(value)
        }
    }

    override fun write(value: DraftAddressValidationResult?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDraftAddressValidationResult.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDraftPassword: FfiConverterRustBuffer<DraftPassword?> {
    override fun read(buf: ByteBuffer): DraftPassword? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDraftPassword.read(buf)
    }

    override fun allocationSize(value: DraftPassword?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDraftPassword.allocationSize(value)
        }
    }

    override fun write(value: DraftPassword?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDraftPassword.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDraftSendResult: FfiConverterRustBuffer<DraftSendResult?> {
    override fun read(buf: ByteBuffer): DraftSendResult? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDraftSendResult.read(buf)
    }

    override fun allocationSize(value: DraftSendResult?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDraftSendResult.allocationSize(value)
        }
    }

    override fun write(value: DraftSendResult?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDraftSendResult.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeId: FfiConverterRustBuffer<Id?> {
    override fun read(buf: ByteBuffer): Id? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeId.read(buf)
    }

    override fun allocationSize(value: Id?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeId.allocationSize(value)
        }
    }

    override fun write(value: Id?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeId.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeLabelColor: FfiConverterRustBuffer<LabelColor?> {
    override fun read(buf: ByteBuffer): LabelColor? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeLabelColor.read(buf)
    }

    override fun allocationSize(value: LabelColor?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeLabelColor.allocationSize(value)
        }
    }

    override fun write(value: LabelColor?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeLabelColor.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeMessage: FfiConverterRustBuffer<Message?> {
    override fun read(buf: ByteBuffer): Message? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMessage.read(buf)
    }

    override fun allocationSize(value: Message?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMessage.allocationSize(value)
        }
    }

    override fun write(value: Message?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMessage.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeMobileSettings: FfiConverterRustBuffer<MobileSettings?> {
    override fun read(buf: ByteBuffer): MobileSettings? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMobileSettings.read(buf)
    }

    override fun allocationSize(value: MobileSettings?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMobileSettings.allocationSize(value)
        }
    }

    override fun write(value: MobileSettings?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMobileSettings.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePrivacyLock: FfiConverterRustBuffer<PrivacyLock?> {
    override fun read(buf: ByteBuffer): PrivacyLock? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePrivacyLock.read(buf)
    }

    override fun allocationSize(value: PrivacyLock?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePrivacyLock.allocationSize(value)
        }
    }

    override fun write(value: PrivacyLock?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePrivacyLock.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeReferral: FfiConverterRustBuffer<Referral?> {
    override fun read(buf: ByteBuffer): Referral? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeReferral.read(buf)
    }

    override fun allocationSize(value: Referral?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeReferral.allocationSize(value)
        }
    }

    override fun write(value: Referral?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeReferral.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeRsvpCalendar: FfiConverterRustBuffer<RsvpCalendar?> {
    override fun read(buf: ByteBuffer): RsvpCalendar? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRsvpCalendar.read(buf)
    }

    override fun allocationSize(value: RsvpCalendar?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRsvpCalendar.allocationSize(value)
        }
    }

    override fun write(value: RsvpCalendar?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRsvpCalendar.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSecondFactorStatus: FfiConverterRustBuffer<SecondFactorStatus?> {
    override fun read(buf: ByteBuffer): SecondFactorStatus? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSecondFactorStatus.read(buf)
    }

    override fun allocationSize(value: SecondFactorStatus?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSecondFactorStatus.allocationSize(value)
        }
    }

    override fun write(value: SecondFactorStatus?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSecondFactorStatus.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSecondPasswordStatus: FfiConverterRustBuffer<SecondPasswordStatus?> {
    override fun read(buf: ByteBuffer): SecondPasswordStatus? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSecondPasswordStatus.read(buf)
    }

    override fun allocationSize(value: SecondPasswordStatus?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSecondPasswordStatus.allocationSize(value)
        }
    }

    override fun write(value: SecondPasswordStatus?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSecondPasswordStatus.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeStrippedUTMInfo: FfiConverterRustBuffer<StrippedUtmInfo?> {
    override fun read(buf: ByteBuffer): StrippedUtmInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeStrippedUTMInfo.read(buf)
    }

    override fun allocationSize(value: StrippedUtmInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeStrippedUTMInfo.allocationSize(value)
        }
    }

    override fun write(value: StrippedUtmInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeStrippedUTMInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeThemeOpts: FfiConverterRustBuffer<ThemeOpts?> {
    override fun read(buf: ByteBuffer): ThemeOpts? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeThemeOpts.read(buf)
    }

    override fun allocationSize(value: ThemeOpts?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeThemeOpts.allocationSize(value)
        }
    }

    override fun write(value: ThemeOpts?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeThemeOpts.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeWatchedConversation: FfiConverterRustBuffer<WatchedConversation?> {
    override fun read(buf: ByteBuffer): WatchedConversation? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeWatchedConversation.read(buf)
    }

    override fun allocationSize(value: WatchedConversation?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeWatchedConversation.allocationSize(value)
        }
    }

    override fun write(value: WatchedConversation?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeWatchedConversation.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeWatchedMessage: FfiConverterRustBuffer<WatchedMessage?> {
    override fun read(buf: ByteBuffer): WatchedMessage? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeWatchedMessage.read(buf)
    }

    override fun allocationSize(value: WatchedMessage?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeWatchedMessage.allocationSize(value)
        }
    }

    override fun write(value: WatchedMessage?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeWatchedMessage.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAppAppearance: FfiConverterRustBuffer<AppAppearance?> {
    override fun read(buf: ByteBuffer): AppAppearance? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAppAppearance.read(buf)
    }

    override fun allocationSize(value: AppAppearance?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAppAppearance.allocationSize(value)
        }
    }

    override fun write(value: AppAppearance?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAppAppearance.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAutoLock: FfiConverterRustBuffer<AutoLock?> {
    override fun read(buf: ByteBuffer): AutoLock? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAutoLock.read(buf)
    }

    override fun allocationSize(value: AutoLock?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAutoLock.allocationSize(value)
        }
    }

    override fun write(value: AutoLock?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAutoLock.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDecryptedEmailPushNotificationAction: FfiConverterRustBuffer<DecryptedEmailPushNotificationAction?> {
    override fun read(buf: ByteBuffer): DecryptedEmailPushNotificationAction? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDecryptedEmailPushNotificationAction.read(buf)
    }

    override fun allocationSize(value: DecryptedEmailPushNotificationAction?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDecryptedEmailPushNotificationAction.allocationSize(value)
        }
    }

    override fun write(value: DecryptedEmailPushNotificationAction?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDecryptedEmailPushNotificationAction.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeExclusiveLocation: FfiConverterRustBuffer<ExclusiveLocation?> {
    override fun read(buf: ByteBuffer): ExclusiveLocation? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeExclusiveLocation.read(buf)
    }

    override fun allocationSize(value: ExclusiveLocation?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeExclusiveLocation.allocationSize(value)
        }
    }

    override fun write(value: ExclusiveLocation?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeExclusiveLocation.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeHiddenMessagesBanner: FfiConverterRustBuffer<HiddenMessagesBanner?> {
    override fun read(buf: ByteBuffer): HiddenMessagesBanner? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeHiddenMessagesBanner.read(buf)
    }

    override fun allocationSize(value: HiddenMessagesBanner?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeHiddenMessagesBanner.allocationSize(value)
        }
    }

    override fun write(value: HiddenMessagesBanner?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeHiddenMessagesBanner.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeMailTheme: FfiConverterRustBuffer<MailTheme?> {
    override fun read(buf: ByteBuffer): MailTheme? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMailTheme.read(buf)
    }

    override fun allocationSize(value: MailTheme?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMailTheme.allocationSize(value)
        }
    }

    override fun write(value: MailTheme?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMailTheme.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeNextMessageOnMove: FfiConverterRustBuffer<NextMessageOnMove?> {
    override fun read(buf: ByteBuffer): NextMessageOnMove? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNextMessageOnMove.read(buf)
    }

    override fun allocationSize(value: NextMessageOnMove?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeNextMessageOnMove.allocationSize(value)
        }
    }

    override fun write(value: NextMessageOnMove?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNextMessageOnMove.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSpamAction: FfiConverterRustBuffer<SpamAction?> {
    override fun read(buf: ByteBuffer): SpamAction? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSpamAction.read(buf)
    }

    override fun allocationSize(value: SpamAction?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSpamAction.allocationSize(value)
        }
    }

    override fun write(value: SpamAction?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSpamAction.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeStoredAccountState: FfiConverterRustBuffer<StoredAccountState?> {
    override fun read(buf: ByteBuffer): StoredAccountState? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeStoredAccountState.read(buf)
    }

    override fun allocationSize(value: StoredAccountState?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeStoredAccountState.allocationSize(value)
        }
    }

    override fun write(value: StoredAccountState?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeStoredAccountState.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeStoredSessionState: FfiConverterRustBuffer<StoredSessionState?> {
    override fun read(buf: ByteBuffer): StoredSessionState? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeStoredSessionState.read(buf)
    }

    override fun allocationSize(value: StoredSessionState?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeStoredSessionState.allocationSize(value)
        }
    }

    override fun write(value: StoredSessionState?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeStoredSessionState.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSystemLabel: FfiConverterRustBuffer<SystemLabel?> {
    override fun read(buf: ByteBuffer): SystemLabel? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSystemLabel.read(buf)
    }

    override fun allocationSize(value: SystemLabel?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSystemLabel.allocationSize(value)
        }
    }

    override fun write(value: SystemLabel?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSystemLabel.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUserSessionError: FfiConverterRustBuffer<UserSessionError?> {
    override fun read(buf: ByteBuffer): UserSessionError? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUserSessionError.read(buf)
    }

    override fun allocationSize(value: UserSessionError?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUserSessionError.allocationSize(value)
        }
    }

    override fun write(value: UserSessionError?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUserSessionError.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceInt: FfiConverterRustBuffer<List<kotlin.Int>?> {
    override fun read(buf: ByteBuffer): List<kotlin.Int>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceInt.read(buf)
    }

    override fun allocationSize(value: List<kotlin.Int>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceInt.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.Int>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<kotlin.String>?> {
    override fun read(buf: ByteBuffer): List<kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeIpAddr: FfiConverterRustBuffer<List<IpAddr>?> {
    override fun read(buf: ByteBuffer): List<IpAddr>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeIpAddr.read(buf)
    }

    override fun allocationSize(value: List<IpAddr>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeIpAddr.allocationSize(value)
        }
    }

    override fun write(value: List<IpAddr>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeIpAddr.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalMapStringInt: FfiConverterRustBuffer<Map<kotlin.String, kotlin.Int>?> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.Int>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterMapStringInt.read(buf)
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.Int>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterMapStringInt.allocationSize(value)
        }
    }

    override fun write(value: Map<kotlin.String, kotlin.Int>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterMapStringInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUnixTimestamp: FfiConverterRustBuffer<UnixTimestamp?> {
    override fun read(buf: ByteBuffer): UnixTimestamp? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUnixTimestamp.read(buf)
    }

    override fun allocationSize(value: UnixTimestamp?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUnixTimestamp.allocationSize(value)
        }
    }

    override fun write(value: UnixTimestamp?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUnixTimestamp.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceUInt: FfiConverterRustBuffer<List<kotlin.UInt>> {
    override fun read(buf: ByteBuffer): List<kotlin.UInt> {
        val len = buf.getInt()
        return List<kotlin.UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UInt>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceInt: FfiConverterRustBuffer<List<kotlin.Int>> {
    override fun read(buf: ByteBuffer): List<kotlin.Int> {
        val len = buf.getInt()
        return List<kotlin.Int>(len) {
            FfiConverterInt.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.Int>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.Int>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterInt.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceBoolean: FfiConverterRustBuffer<List<kotlin.Boolean>> {
    override fun read(buf: ByteBuffer): List<kotlin.Boolean> {
        val len = buf.getInt()
        return List<kotlin.Boolean>(len) {
            FfiConverterBoolean.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.Boolean>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterBoolean.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.Boolean>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterBoolean.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeStoredAccount: FfiConverterRustBuffer<List<StoredAccount>> {
    override fun read(buf: ByteBuffer): List<StoredAccount> {
        val len = buf.getInt()
        return List<StoredAccount>(len) {
            FfiConverterTypeStoredAccount.read(buf)
        }
    }

    override fun allocationSize(value: List<StoredAccount>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeStoredAccount.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<StoredAccount>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeStoredAccount.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeStoredSession: FfiConverterRustBuffer<List<StoredSession>> {
    override fun read(buf: ByteBuffer): List<StoredSession> {
        val len = buf.getInt()
        return List<StoredSession>(len) {
            FfiConverterTypeStoredSession.read(buf)
        }
    }

    override fun allocationSize(value: List<StoredSession>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeStoredSession.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<StoredSession>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeStoredSession.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAttachmentMetadata: FfiConverterRustBuffer<List<AttachmentMetadata>> {
    override fun read(buf: ByteBuffer): List<AttachmentMetadata> {
        val len = buf.getInt()
        return List<AttachmentMetadata>(len) {
            FfiConverterTypeAttachmentMetadata.read(buf)
        }
    }

    override fun allocationSize(value: List<AttachmentMetadata>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAttachmentMetadata.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AttachmentMetadata>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAttachmentMetadata.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeComposerRecipientSingle: FfiConverterRustBuffer<List<ComposerRecipientSingle>> {
    override fun read(buf: ByteBuffer): List<ComposerRecipientSingle> {
        val len = buf.getInt()
        return List<ComposerRecipientSingle>(len) {
            FfiConverterTypeComposerRecipientSingle.read(buf)
        }
    }

    override fun allocationSize(value: List<ComposerRecipientSingle>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeComposerRecipientSingle.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ComposerRecipientSingle>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeComposerRecipientSingle.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactCard: FfiConverterRustBuffer<List<ContactCard>> {
    override fun read(buf: ByteBuffer): List<ContactCard> {
        val len = buf.getInt()
        return List<ContactCard>(len) {
            FfiConverterTypeContactCard.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactCard>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactCard.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactCard>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactCard.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactDetailAddress: FfiConverterRustBuffer<List<ContactDetailAddress>> {
    override fun read(buf: ByteBuffer): List<ContactDetailAddress> {
        val len = buf.getInt()
        return List<ContactDetailAddress>(len) {
            FfiConverterTypeContactDetailAddress.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactDetailAddress>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactDetailAddress.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactDetailAddress>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactDetailAddress.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactDetailsEmail: FfiConverterRustBuffer<List<ContactDetailsEmail>> {
    override fun read(buf: ByteBuffer): List<ContactDetailsEmail> {
        val len = buf.getInt()
        return List<ContactDetailsEmail>(len) {
            FfiConverterTypeContactDetailsEmail.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactDetailsEmail>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactDetailsEmail.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactDetailsEmail>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactDetailsEmail.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactDetailsTelephones: FfiConverterRustBuffer<List<ContactDetailsTelephones>> {
    override fun read(buf: ByteBuffer): List<ContactDetailsTelephones> {
        val len = buf.getInt()
        return List<ContactDetailsTelephones>(len) {
            FfiConverterTypeContactDetailsTelephones.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactDetailsTelephones>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactDetailsTelephones.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactDetailsTelephones>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactDetailsTelephones.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactEmail: FfiConverterRustBuffer<List<ContactEmail>> {
    override fun read(buf: ByteBuffer): List<ContactEmail> {
        val len = buf.getInt()
        return List<ContactEmail>(len) {
            FfiConverterTypeContactEmail.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactEmail>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactEmail.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactEmail>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactEmail.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactEmailItem: FfiConverterRustBuffer<List<ContactEmailItem>> {
    override fun read(buf: ByteBuffer): List<ContactEmailItem> {
        val len = buf.getInt()
        return List<ContactEmailItem>(len) {
            FfiConverterTypeContactEmailItem.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactEmailItem>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactEmailItem.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactEmailItem>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactEmailItem.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactGroup: FfiConverterRustBuffer<List<ContactGroup>> {
    override fun read(buf: ByteBuffer): List<ContactGroup> {
        val len = buf.getInt()
        return List<ContactGroup>(len) {
            FfiConverterTypeContactGroup.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactGroup>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactGroup.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactGroup>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactGroup.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactSuggestion: FfiConverterRustBuffer<List<ContactSuggestion>> {
    override fun read(buf: ByteBuffer): List<ContactSuggestion> {
        val len = buf.getInt()
        return List<ContactSuggestion>(len) {
            FfiConverterTypeContactSuggestion.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactSuggestion>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactSuggestion.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactSuggestion>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactSuggestion.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeConversation: FfiConverterRustBuffer<List<Conversation>> {
    override fun read(buf: ByteBuffer): List<Conversation> {
        val len = buf.getInt()
        return List<Conversation>(len) {
            FfiConverterTypeConversation.read(buf)
        }
    }

    override fun allocationSize(value: List<Conversation>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeConversation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Conversation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeConversation.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCustomFolderAction: FfiConverterRustBuffer<List<CustomFolderAction>> {
    override fun read(buf: ByteBuffer): List<CustomFolderAction> {
        val len = buf.getInt()
        return List<CustomFolderAction>(len) {
            FfiConverterTypeCustomFolderAction.read(buf)
        }
    }

    override fun allocationSize(value: List<CustomFolderAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCustomFolderAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CustomFolderAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCustomFolderAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeDeviceContact: FfiConverterRustBuffer<List<DeviceContact>> {
    override fun read(buf: ByteBuffer): List<DeviceContact> {
        val len = buf.getInt()
        return List<DeviceContact>(len) {
            FfiConverterTypeDeviceContact.read(buf)
        }
    }

    override fun allocationSize(value: List<DeviceContact>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeDeviceContact.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DeviceContact>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeDeviceContact.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeDraftAttachment: FfiConverterRustBuffer<List<DraftAttachment>> {
    override fun read(buf: ByteBuffer): List<DraftAttachment> {
        val len = buf.getInt()
        return List<DraftAttachment>(len) {
            FfiConverterTypeDraftAttachment.read(buf)
        }
    }

    override fun allocationSize(value: List<DraftAttachment>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeDraftAttachment.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DraftAttachment>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeDraftAttachment.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeDraftSendResult: FfiConverterRustBuffer<List<DraftSendResult>> {
    override fun read(buf: ByteBuffer): List<DraftSendResult> {
        val len = buf.getInt()
        return List<DraftSendResult>(len) {
            FfiConverterTypeDraftSendResult.read(buf)
        }
    }

    override fun allocationSize(value: List<DraftSendResult>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeDraftSendResult.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DraftSendResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeDraftSendResult.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFidoKey: FfiConverterRustBuffer<List<FidoKey>> {
    override fun read(buf: ByteBuffer): List<FidoKey> {
        val len = buf.getInt()
        return List<FidoKey>(len) {
            FfiConverterTypeFidoKey.read(buf)
        }
    }

    override fun allocationSize(value: List<FidoKey>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFidoKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FidoKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFidoKey.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeGroupedContacts: FfiConverterRustBuffer<List<GroupedContacts>> {
    override fun read(buf: ByteBuffer): List<GroupedContacts> {
        val len = buf.getInt()
        return List<GroupedContacts>(len) {
            FfiConverterTypeGroupedContacts.read(buf)
        }
    }

    override fun allocationSize(value: List<GroupedContacts>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeGroupedContacts.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<GroupedContacts>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeGroupedContacts.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeHeader: FfiConverterRustBuffer<List<Header>> {
    override fun read(buf: ByteBuffer): List<Header> {
        val len = buf.getInt()
        return List<Header>(len) {
            FfiConverterTypeHeader.read(buf)
        }
    }

    override fun allocationSize(value: List<Header>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeHeader.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Header>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeHeader.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeId: FfiConverterRustBuffer<List<Id>> {
    override fun read(buf: ByteBuffer): List<Id> {
        val len = buf.getInt()
        return List<Id>(len) {
            FfiConverterTypeId.read(buf)
        }
    }

    override fun allocationSize(value: List<Id>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeId.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Id>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeId.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeInlineCustomLabel: FfiConverterRustBuffer<List<InlineCustomLabel>> {
    override fun read(buf: ByteBuffer): List<InlineCustomLabel> {
        val len = buf.getInt()
        return List<InlineCustomLabel>(len) {
            FfiConverterTypeInlineCustomLabel.read(buf)
        }
    }

    override fun allocationSize(value: List<InlineCustomLabel>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeInlineCustomLabel.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<InlineCustomLabel>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeInlineCustomLabel.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeIosShareExtAttachment: FfiConverterRustBuffer<List<IosShareExtAttachment>> {
    override fun read(buf: ByteBuffer): List<IosShareExtAttachment> {
        val len = buf.getInt()
        return List<IosShareExtAttachment>(len) {
            FfiConverterTypeIosShareExtAttachment.read(buf)
        }
    }

    override fun allocationSize(value: List<IosShareExtAttachment>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeIosShareExtAttachment.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<IosShareExtAttachment>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeIosShareExtAttachment.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLabelAsAction: FfiConverterRustBuffer<List<LabelAsAction>> {
    override fun read(buf: ByteBuffer): List<LabelAsAction> {
        val len = buf.getInt()
        return List<LabelAsAction>(len) {
            FfiConverterTypeLabelAsAction.read(buf)
        }
    }

    override fun allocationSize(value: List<LabelAsAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLabelAsAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LabelAsAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLabelAsAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMessage: FfiConverterRustBuffer<List<Message>> {
    override fun read(buf: ByteBuffer): List<Message> {
        val len = buf.getInt()
        return List<Message>(len) {
            FfiConverterTypeMessage.read(buf)
        }
    }

    override fun allocationSize(value: List<Message>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessage.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Message>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessage.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMessageRecipient: FfiConverterRustBuffer<List<MessageRecipient>> {
    override fun read(buf: ByteBuffer): List<MessageRecipient> {
        val len = buf.getInt()
        return List<MessageRecipient>(len) {
            FfiConverterTypeMessageRecipient.read(buf)
        }
    }

    override fun allocationSize(value: List<MessageRecipient>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessageRecipient.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MessageRecipient>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessageRecipient.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMessageSender: FfiConverterRustBuffer<List<MessageSender>> {
    override fun read(buf: ByteBuffer): List<MessageSender> {
        val len = buf.getInt()
        return List<MessageSender>(len) {
            FfiConverterTypeMessageSender.read(buf)
        }
    }

    override fun allocationSize(value: List<MessageSender>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessageSender.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MessageSender>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessageSender.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlan: FfiConverterRustBuffer<List<Plan>> {
    override fun read(buf: ByteBuffer): List<Plan> {
        val len = buf.getInt()
        return List<Plan>(len) {
            FfiConverterTypePlan.read(buf)
        }
    }

    override fun allocationSize(value: List<Plan>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlan.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Plan>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlan.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlanInstance: FfiConverterRustBuffer<List<PlanInstance>> {
    override fun read(buf: ByteBuffer): List<PlanInstance> {
        val len = buf.getInt()
        return List<PlanInstance>(len) {
            FfiConverterTypePlanInstance.read(buf)
        }
    }

    override fun allocationSize(value: List<PlanInstance>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlanInstance.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PlanInstance>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlanInstance.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlanPrice: FfiConverterRustBuffer<List<PlanPrice>> {
    override fun read(buf: ByteBuffer): List<PlanPrice> {
        val len = buf.getInt()
        return List<PlanPrice>(len) {
            FfiConverterTypePlanPrice.read(buf)
        }
    }

    override fun allocationSize(value: List<PlanPrice>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlanPrice.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PlanPrice>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlanPrice.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeQuery: FfiConverterRustBuffer<List<Query>> {
    override fun read(buf: ByteBuffer): List<Query> {
        val len = buf.getInt()
        return List<Query>(len) {
            FfiConverterTypeQuery.read(buf)
        }
    }

    override fun allocationSize(value: List<Query>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeQuery.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Query>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeQuery.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRemoteId: FfiConverterRustBuffer<List<RemoteId>> {
    override fun read(buf: ByteBuffer): List<RemoteId> {
        val len = buf.getInt()
        return List<RemoteId>(len) {
            FfiConverterTypeRemoteId.read(buf)
        }
    }

    override fun allocationSize(value: List<RemoteId>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRemoteId.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RemoteId>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRemoteId.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRsvpAttendee: FfiConverterRustBuffer<List<RsvpAttendee>> {
    override fun read(buf: ByteBuffer): List<RsvpAttendee> {
        val len = buf.getInt()
        return List<RsvpAttendee>(len) {
            FfiConverterTypeRsvpAttendee.read(buf)
        }
    }

    override fun allocationSize(value: List<RsvpAttendee>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRsvpAttendee.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RsvpAttendee>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRsvpAttendee.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSidebarCustomFolder: FfiConverterRustBuffer<List<SidebarCustomFolder>> {
    override fun read(buf: ByteBuffer): List<SidebarCustomFolder> {
        val len = buf.getInt()
        return List<SidebarCustomFolder>(len) {
            FfiConverterTypeSidebarCustomFolder.read(buf)
        }
    }

    override fun allocationSize(value: List<SidebarCustomFolder>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSidebarCustomFolder.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SidebarCustomFolder>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSidebarCustomFolder.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSidebarCustomLabel: FfiConverterRustBuffer<List<SidebarCustomLabel>> {
    override fun read(buf: ByteBuffer): List<SidebarCustomLabel> {
        val len = buf.getInt()
        return List<SidebarCustomLabel>(len) {
            FfiConverterTypeSidebarCustomLabel.read(buf)
        }
    }

    override fun allocationSize(value: List<SidebarCustomLabel>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSidebarCustomLabel.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SidebarCustomLabel>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSidebarCustomLabel.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSidebarSystemLabel: FfiConverterRustBuffer<List<SidebarSystemLabel>> {
    override fun read(buf: ByteBuffer): List<SidebarSystemLabel> {
        val len = buf.getInt()
        return List<SidebarSystemLabel>(len) {
            FfiConverterTypeSidebarSystemLabel.read(buf)
        }
    }

    override fun allocationSize(value: List<SidebarSystemLabel>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSidebarSystemLabel.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SidebarSystemLabel>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSidebarSystemLabel.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSingleRecipientEntry: FfiConverterRustBuffer<List<SingleRecipientEntry>> {
    override fun read(buf: ByteBuffer): List<SingleRecipientEntry> {
        val len = buf.getInt()
        return List<SingleRecipientEntry>(len) {
            FfiConverterTypeSingleRecipientEntry.read(buf)
        }
    }

    override fun allocationSize(value: List<SingleRecipientEntry>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSingleRecipientEntry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SingleRecipientEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSingleRecipientEntry.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSubscription: FfiConverterRustBuffer<List<Subscription>> {
    override fun read(buf: ByteBuffer): List<Subscription> {
        val len = buf.getInt()
        return List<Subscription>(len) {
            FfiConverterTypeSubscription.read(buf)
        }
    }

    override fun allocationSize(value: List<Subscription>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSubscription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Subscription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSubscription.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTrackerDomain: FfiConverterRustBuffer<List<TrackerDomain>> {
    override fun read(buf: ByteBuffer): List<TrackerDomain> {
        val len = buf.getInt()
        return List<TrackerDomain>(len) {
            FfiConverterTypeTrackerDomain.read(buf)
        }
    }

    override fun allocationSize(value: List<TrackerDomain>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTrackerDomain.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TrackerDomain>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTrackerDomain.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeUTMLink: FfiConverterRustBuffer<List<UtmLink>> {
    override fun read(buf: ByteBuffer): List<UtmLink> {
        val len = buf.getInt()
        return List<UtmLink>(len) {
            FfiConverterTypeUTMLink.read(buf)
        }
    }

    override fun allocationSize(value: List<UtmLink>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUTMLink.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UtmLink>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUTMLink.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeVCardUrl: FfiConverterRustBuffer<List<VCardUrl>> {
    override fun read(buf: ByteBuffer): List<VCardUrl> {
        val len = buf.getInt()
        return List<VCardUrl>(len) {
            FfiConverterTypeVCardUrl.read(buf)
        }
    }

    override fun allocationSize(value: List<VCardUrl>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeVCardUrl.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<VCardUrl>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeVCardUrl.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeComposerRecipient: FfiConverterRustBuffer<List<ComposerRecipient>> {
    override fun read(buf: ByteBuffer): List<ComposerRecipient> {
        val len = buf.getInt()
        return List<ComposerRecipient>(len) {
            FfiConverterTypeComposerRecipient.read(buf)
        }
    }

    override fun allocationSize(value: List<ComposerRecipient>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeComposerRecipient.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ComposerRecipient>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeComposerRecipient.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactField: FfiConverterRustBuffer<List<ContactField>> {
    override fun read(buf: ByteBuffer): List<ContactField> {
        val len = buf.getInt()
        return List<ContactField>(len) {
            FfiConverterTypeContactField.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactField>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactField.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactField>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactField.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeContactItemType: FfiConverterRustBuffer<List<ContactItemType>> {
    override fun read(buf: ByteBuffer): List<ContactItemType> {
        val len = buf.getInt()
        return List<ContactItemType>(len) {
            FfiConverterTypeContactItemType.read(buf)
        }
    }

    override fun allocationSize(value: List<ContactItemType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeContactItemType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ContactItemType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeContactItemType.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeConversationAction: FfiConverterRustBuffer<List<ConversationAction>> {
    override fun read(buf: ByteBuffer): List<ConversationAction> {
        val len = buf.getInt()
        return List<ConversationAction>(len) {
            FfiConverterTypeConversationAction.read(buf)
        }
    }

    override fun allocationSize(value: List<ConversationAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeConversationAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ConversationAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeConversationAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeExclusiveLocation: FfiConverterRustBuffer<List<ExclusiveLocation>> {
    override fun read(buf: ByteBuffer): List<ExclusiveLocation> {
        val len = buf.getInt()
        return List<ExclusiveLocation>(len) {
            FfiConverterTypeExclusiveLocation.read(buf)
        }
    }

    override fun allocationSize(value: List<ExclusiveLocation>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeExclusiveLocation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ExclusiveLocation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeExclusiveLocation.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeIpAddr: FfiConverterRustBuffer<List<IpAddr>> {
    override fun read(buf: ByteBuffer): List<IpAddr> {
        val len = buf.getInt()
        return List<IpAddr>(len) {
            FfiConverterTypeIpAddr.read(buf)
        }
    }

    override fun allocationSize(value: List<IpAddr>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeIpAddr.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<IpAddr>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeIpAddr.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeListActions: FfiConverterRustBuffer<List<ListActions>> {
    override fun read(buf: ByteBuffer): List<ListActions> {
        val len = buf.getInt()
        return List<ListActions>(len) {
            FfiConverterTypeListActions.read(buf)
        }
    }

    override fun allocationSize(value: List<ListActions>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeListActions.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ListActions>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeListActions.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMessageAction: FfiConverterRustBuffer<List<MessageAction>> {
    override fun read(buf: ByteBuffer): List<MessageAction> {
        val len = buf.getInt()
        return List<MessageAction>(len) {
            FfiConverterTypeMessageAction.read(buf)
        }
    }

    override fun allocationSize(value: List<MessageAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessageAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MessageAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessageAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMessageBanner: FfiConverterRustBuffer<List<MessageBanner>> {
    override fun read(buf: ByteBuffer): List<MessageBanner> {
        val len = buf.getInt()
        return List<MessageBanner>(len) {
            FfiConverterTypeMessageBanner.read(buf)
        }
    }

    override fun allocationSize(value: List<MessageBanner>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessageBanner.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MessageBanner>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessageBanner.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMobileAction: FfiConverterRustBuffer<List<MobileAction>> {
    override fun read(buf: ByteBuffer): List<MobileAction> {
        val len = buf.getInt()
        return List<MobileAction>(len) {
            FfiConverterTypeMobileAction.read(buf)
        }
    }

    override fun allocationSize(value: List<MobileAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMobileAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MobileAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMobileAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeMoveAction: FfiConverterRustBuffer<List<MoveAction>> {
    override fun read(buf: ByteBuffer): List<MoveAction> {
        val len = buf.getInt()
        return List<MoveAction>(len) {
            FfiConverterTypeMoveAction.read(buf)
        }
    }

    override fun allocationSize(value: List<MoveAction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMoveAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MoveAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMoveAction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlanDecoration: FfiConverterRustBuffer<List<PlanDecoration>> {
    override fun read(buf: ByteBuffer): List<PlanDecoration> {
        val len = buf.getInt()
        return List<PlanDecoration>(len) {
            FfiConverterTypePlanDecoration.read(buf)
        }
    }

    override fun allocationSize(value: List<PlanDecoration>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlanDecoration.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PlanDecoration>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlanDecoration.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlanEntitlement: FfiConverterRustBuffer<List<PlanEntitlement>> {
    override fun read(buf: ByteBuffer): List<PlanEntitlement> {
        val len = buf.getInt()
        return List<PlanEntitlement>(len) {
            FfiConverterTypePlanEntitlement.read(buf)
        }
    }

    override fun allocationSize(value: List<PlanEntitlement>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlanEntitlement.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PlanEntitlement>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlanEntitlement.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSnoozeTime: FfiConverterRustBuffer<List<SnoozeTime>> {
    override fun read(buf: ByteBuffer): List<SnoozeTime> {
        val len = buf.getInt()
        return List<SnoozeTime>(len) {
            FfiConverterTypeSnoozeTime.read(buf)
        }
    }

    override fun allocationSize(value: List<SnoozeTime>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSnoozeTime.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SnoozeTime>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSnoozeTime.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeVcardPropType: FfiConverterRustBuffer<List<VcardPropType>> {
    override fun read(buf: ByteBuffer): List<VcardPropType> {
        val len = buf.getInt()
        return List<VcardPropType>(len) {
            FfiConverterTypeVcardPropType.read(buf)
        }
    }

    override fun allocationSize(value: List<VcardPropType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeVcardPropType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<VcardPropType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeVcardPropType.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapStringInt: FfiConverterRustBuffer<Map<kotlin.String, kotlin.Int>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.Int> {
        val len = buf.getInt()
        return buildMap<kotlin.String, kotlin.Int>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterInt.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.Int>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterInt.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.Int>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterInt.write(v, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapTypePlanVendorNameTypePlanVendor: FfiConverterRustBuffer<Map<PlanVendorName, PlanVendor>> {
    override fun read(buf: ByteBuffer): Map<PlanVendorName, PlanVendor> {
        val len = buf.getInt()
        return buildMap<PlanVendorName, PlanVendor>(len) {
            repeat(len) {
                val k = FfiConverterTypePlanVendorName.read(buf)
                val v = FfiConverterTypePlanVendor.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<PlanVendorName, PlanVendor>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypePlanVendorName.allocationSize(k) +
            FfiConverterTypePlanVendor.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<PlanVendorName, PlanVendor>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypePlanVendorName.write(k, buf)
            FfiConverterTypePlanVendor.write(v, buf)
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias UnixTimestamp = kotlin.ULong
public typealias FfiConverterTypeUnixTimestamp = FfiConverterULong






















    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableConversationActionsForActionSheet`(`mailbox`: Mailbox, `conversationId`: Id) : AllAvailableConversationActionsForActionSheetResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_conversation_actions_for_action_sheet(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`conversationId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableConversationActionsForActionSheetResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableConversationActionsForConversation`(`mailbox`: Mailbox, `conversationId`: Id) : AllAvailableConversationActionsForConversationResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_conversation_actions_for_conversation(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`conversationId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableConversationActionsForConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableListActionsForConversations`(`mailbox`: Mailbox, `conversationIds`: List<Id>) : AllAvailableListActionsForConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_list_actions_for_conversations(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`conversationIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableListActionsForConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableListActionsForMessages`(`mailbox`: Mailbox, `messageIds`: List<Id>) : AllAvailableListActionsForMessagesResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_list_actions_for_messages(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableListActionsForMessagesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableMessageActionsForActionSheet`(`mailbox`: Mailbox, `theme`: ThemeOpts, `messageId`: Id) : AllAvailableMessageActionsForActionSheetResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_message_actions_for_action_sheet(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeThemeOpts.lower(`theme`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableMessageActionsForActionSheetResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `allAvailableMessageActionsForMessage`(`mailbox`: Mailbox, `theme`: ThemeOpts, `messageId`: Id) : AllAvailableMessageActionsForMessageResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_all_available_message_actions_for_message(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeThemeOpts.lower(`theme`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAllAvailableMessageActionsForMessageResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `assignedSwipeActions`(`currentFolder`: Id, `session`: MailUserSession) : AssignedSwipeActionsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_assigned_swipe_actions(FfiConverterTypeId.lower(`currentFolder`),FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAssignedSwipeActionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `availableLabelAsActionsForConversations`(`mailbox`: Mailbox, `ids`: List<Id>) : AvailableLabelAsActionsForConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_available_label_as_actions_for_conversations(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAvailableLabelAsActionsForConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `availableLabelAsActionsForMessages`(`mailbox`: Mailbox, `ids`: List<Id>) : AvailableLabelAsActionsForMessagesResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_available_label_as_actions_for_messages(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAvailableLabelAsActionsForMessagesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `availableMoveToActionsForConversations`(`mailbox`: Mailbox, `ids`: List<Id>) : AvailableMoveToActionsForConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_available_move_to_actions_for_conversations(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAvailableMoveToActionsForConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `availableMoveToActionsForMessages`(`mailbox`: Mailbox, `ids`: List<Id>) : AvailableMoveToActionsForMessagesResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_available_move_to_actions_for_messages(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAvailableMoveToActionsForMessagesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `availableSnoozeActionsForConversation`(`session`: MailUserSession, `weekStart`: NonDefaultWeekStart, `ids`: List<Id>) : AvailableSnoozeActionsForConversationResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_available_snooze_actions_for_conversation(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeNonDefaultWeekStart.lower(`weekStart`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeAvailableSnoozeActionsForConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `avatarInformationFromMessageRecipient`(`address`: MessageRecipient): AvatarInformation {
            return FfiConverterTypeAvatarInformation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_recipient(
        FfiConverterTypeMessageRecipient.lower(`address`),_status)
}
    )
    }
    
 fun `avatarInformationFromMessageRecipients`(`addressList`: List<MessageRecipient>): AvatarInformation {
            return FfiConverterTypeAvatarInformation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_recipients(
        FfiConverterSequenceTypeMessageRecipient.lower(`addressList`),_status)
}
    )
    }
    
 fun `avatarInformationFromMessageSender`(`address`: MessageSender): AvatarInformation {
            return FfiConverterTypeAvatarInformation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_sender(
        FfiConverterTypeMessageSender.lower(`address`),_status)
}
    )
    }
    
 fun `avatarInformationFromMessageSenders`(`addressList`: List<MessageSender>): AvatarInformation {
            return FfiConverterTypeAvatarInformation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_avatar_information_from_message_senders(
        FfiConverterSequenceTypeMessageSender.lower(`addressList`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `blockAddress`(`session`: MailUserSession, `email`: kotlin.String) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_block_address(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterString.lower(`email`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Bulk check unread status for messages by remote IDs.
         *
         * Takes a list of remote message IDs and returns a list of booleans indicating
         * whether each message is unread. The result maintains the same order as the input.
         * For messages that don't exist in the local database, returns true (unread).
         *
         * This function is designed to work offline-only for iOS push notification clearing.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `bulkMessageUnreadStatus`(`session`: MailUserSession, `remoteIds`: List<RemoteId>) : BulkMessageUnreadStatusResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_bulk_message_unread_status(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeRemoteId.lower(`remoteIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeBulkMessageUnreadStatusResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `contactGroupById`(`session`: MailUserSession, `id`: Id) : ContactGroupByIdResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_contact_group_by_id(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`id`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeContactGroupByIdResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `contactList`(`session`: MailUserSession) : ContactListResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_contact_list(FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeContactListResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Returns a list of contact suggestions (used for example in Composer).
         *
         * If the `AppSettings::use_combine_contacts` is set, the function will include
         * all other available contacts from all logged in accounts.
         *
         * Contacts are sorted, deduplicated but not filtered by the query.
         * Contacts from other accounts have lower priority and will appear at the end of the list.

         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `contactSuggestions`(`deviceContacts`: List<DeviceContact>, `session`: MailUserSession) : ContactSuggestionsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_contact_suggestions(FfiConverterSequenceTypeDeviceContact.lower(`deviceContacts`),FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeContactSuggestionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `conversation`(`mailbox`: Mailbox, `id`: Id, `showAll`: kotlin.Boolean) : ConversationResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_conversation(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`id`),FfiConverterBoolean.lower(`showAll`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `createMailSession`(`params`: MailSessionParams, `keyChain`: OsKeyChain, `hvNotifier`: ChallengeNotifier?, `deviceInfoProvider`: DeviceInfoProvider?, `issueReporter`: IssueReporter): CreateMailSessionResult {
            return FfiConverterTypeCreateMailSessionResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_create_mail_session(
        FfiConverterTypeMailSessionParams.lower(`params`),FfiConverterTypeOSKeyChain.lower(`keyChain`),FfiConverterOptionalTypeChallengeNotifier.lower(`hvNotifier`),FfiConverterOptionalTypeDeviceInfoProvider.lower(`deviceInfoProvider`),FfiConverterTypeIssueReporter.lower(`issueReporter`),_status)
}
    )
    }
    
 fun `customSettings`(`ctx`: MailUserSession): CustomSettings {
            return FfiConverterTypeCustomSettings.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_custom_settings(
        FfiConverterTypeMailUserSession.lower(`ctx`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `decryptPushNotification`(`keyChain`: OsKeyChain, `encrypted`: EncryptedPushNotification) : DecryptPushNotificationResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_decrypt_push_notification(FfiConverterTypeOSKeyChain.lower(`keyChain`),FfiConverterTypeEncryptedPushNotification.lower(`encrypted`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDecryptPushNotificationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Delete all messages in a label
         *
         * Limited to:
         *
         * - drafts
         * - spam
         * - trash
         * - custom labels
         * - custom folders

         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `deleteAllMessagesInLabel`(`session`: MailUserSession, `labelId`: Id) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_delete_all_messages_in_label(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`labelId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `deleteContact`(`contactId`: Id, `session`: MailUserSession) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_delete_contact(FfiConverterTypeId.lower(`contactId`),FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `deleteConversations`(`mailbox`: Mailbox, `conversationIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_delete_conversations(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`conversationIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `deleteMessages`(`mailbox`: Mailbox, `messageIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_delete_messages(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftCancelScheduleSend`(`session`: MailUserSession, `messageId`: Id) : DraftCancelScheduleSendResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_cancel_schedule_send(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDraftCancelScheduleSendResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftDiscard`(`session`: MailUserSession, `messageId`: Id) : VoidDraftDiscardResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_discard(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftDiscardResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Delete the send results for the `message_ids`.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftSendResultDelete`(`session`: MailUserSession, `messageIds`: List<Id>) : VoidProtonResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_send_result_delete(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidProtonResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Mark the send results for the `message_ids` as seen.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftSendResultMarkSeen`(`session`: MailUserSession, `messageIds`: List<Id>) : VoidProtonResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_send_result_mark_seen(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidProtonResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Return all unseen send results for drafts.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftSendResultUnseen`(`session`: MailUserSession) : DraftSendResultUnseenResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_send_result_unseen(FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeDraftSendResultUnseenResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `draftUndoSend`(`session`: MailUserSession, `messageId`: Id) : VoidDraftUndoSendResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_draft_undo_send(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidDraftUndoSendResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `generateCspNonce`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_generate_csp_nonce(
        _status)
}
    )
    }
    
 fun `getAllMobileConversationActions`(): List<MobileAction> {
            return FfiConverterSequenceTypeMobileAction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_all_mobile_conversation_actions(
        _status)
}
    )
    }
    
 fun `getAllMobileListActions`(): List<MobileAction> {
            return FfiConverterSequenceTypeMobileAction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_all_mobile_list_actions(
        _status)
}
    )
    }
    
 fun `getAllMobileMessageActions`(): List<MobileAction> {
            return FfiConverterSequenceTypeMobileAction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_all_mobile_message_actions(
        _status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getAutoDeleteBanner`(`session`: MailUserSession, `labelId`: Id) : GetAutoDeleteBannerResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_auto_delete_banner(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`labelId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeGetAutoDeleteBannerResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getContactDetails`(`session`: MailUserSession, `contactId`: Id) : GetContactDetailsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_contact_details(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`contactId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeGetContactDetailsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getMessageBody`(`mbox`: Mailbox, `id`: Id) : GetMessageBodyResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_message_body(FfiConverterTypeMailbox.lower(`mbox`),FfiConverterTypeId.lower(`id`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeGetMessageBodyResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getMobileConversationToolbarActions`(`session`: MailUserSession) : MobileActionsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_mobile_conversation_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMobileActionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getMobileListToolbarActions`(`session`: MailUserSession) : MobileActionsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_mobile_list_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMobileActionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getMobileMessageToolbarActions`(`session`: MailUserSession) : MobileActionsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_mobile_message_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMobileActionsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `getPrivacyInfoForMessage`(`session`: MailUserSession, `messageId`: Id) : GetPrivacyInfoForMessageResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_get_privacy_info_for_message(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeGetPrivacyInfoForMessageResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `iosShareExtInitDraft`(`mailCacheDir`: kotlin.String): IosShareExtInitDraftResult {
            return FfiConverterTypeIosShareExtInitDraftResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_ios_share_ext_init_draft(
        FfiConverterString.lower(`mailCacheDir`),_status)
}
    )
    }
    
 fun `iosShareExtSaveDraft`(`mailCacheDir`: kotlin.String, `draft`: IosShareExtDraft): IosShareExtSaveDraftResult {
            return FfiConverterTypeIosShareExtSaveDraftResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_ios_share_ext_save_draft(
        FfiConverterString.lower(`mailCacheDir`),FfiConverterTypeIosShareExtDraft.lower(`draft`),_status)
}
    )
    }
    

        /**
         * Return the boolean value indicating if the message sender is blocked.
         *
         * When message is not present in database, it will return `None`.
         * Otherwise, it will return `Some(bool)` where `true` means the sender is blocked
         * and `false` means the sender is not blocked.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `isMessageSenderBlocked`(`mbox`: Mailbox, `messageId`: Id) : IsMessageSenderBlockedResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_is_message_sender_blocked(FfiConverterTypeMailbox.lower(`mbox`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeIsMessageSenderBlockedResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Check whether the given `address` is a valid email address.
         */ fun `isValidEmailAddress`(`address`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_is_valid_email_address(
        FfiConverterString.lower(`address`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `labelConversationsAs`(`mailbox`: Mailbox, `conversationIds`: List<Id>, `selectedLabelIds`: List<Id>, `partiallySelectedLabelIds`: List<Id>, `mustArchive`: kotlin.Boolean) : LabelConversationsAsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_label_conversations_as(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`conversationIds`),FfiConverterSequenceTypeId.lower(`selectedLabelIds`),FfiConverterSequenceTypeId.lower(`partiallySelectedLabelIds`),FfiConverterBoolean.lower(`mustArchive`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLabelConversationsAsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `labelMessagesAs`(`mailbox`: Mailbox, `messageIds`: List<Id>, `selectedLabelIds`: List<Id>, `partiallySelectedLabelIds`: List<Id>, `mustArchive`: kotlin.Boolean) : LabelMessagesAsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_label_messages_as(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`messageIds`),FfiConverterSequenceTypeId.lower(`selectedLabelIds`),FfiConverterSequenceTypeId.lower(`partiallySelectedLabelIds`),FfiConverterBoolean.lower(`mustArchive`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLabelMessagesAsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `mailSettings`(`ctx`: MailUserSession) : MailSettingsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mail_settings(FfiConverterTypeMailUserSession.lower(`ctx`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMailSettingsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `mailSettingsSync`(`ctx`: MailUserSession): MailSettingsSyncResult {
            return FfiConverterTypeMailSettingsSyncResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mail_settings_sync(
        FfiConverterTypeMailUserSession.lower(`ctx`),_status)
}
    )
    }
    
 fun `makeMeCrash`()
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_make_me_crash(
        _status)
}
    
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `markConversationsAsRead`(`mailbox`: Mailbox, `ids`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mark_conversations_as_read(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `markConversationsAsUnread`(`mailbox`: Mailbox, `ids`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mark_conversations_as_unread(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `markMessagesHam`(`mailbox`: Mailbox, `messageId`: Id) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mark_messages_ham(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `markMessagesRead`(`mailbox`: Mailbox, `messageIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mark_messages_read(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `markMessagesUnread`(`mailbox`: Mailbox, `messageIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_mark_messages_unread(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `message`(`session`: MailUserSession, `id`: Id) : MessageResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_message(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`id`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMessageResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `moveConversations`(`mailbox`: Mailbox, `labelId`: Id, `ids`: List<Id>) : MoveConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_move_conversations(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`labelId`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMoveConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `moveMessages`(`mailbox`: Mailbox, `destinationId`: Id, `messageIds`: List<Id>) : MoveMessagesResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_move_messages(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`destinationId`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeMoveMessagesResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `newAllMailMailbox`(`ctx`: MailUserSession): NewAllMailMailboxResult {
            return FfiConverterTypeNewAllMailMailboxResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_all_mail_mailbox(
        FfiConverterTypeMailUserSession.lower(`ctx`),_status)
}
    )
    }
    

        /**
         * Create a new `ChallengeLoader`.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `newChallengeLoader`(`cfg`: ApiConfig, `app`: AppDetails) : NewChallengeLoaderResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_challenge_loader(FfiConverterTypeApiConfig.lower(`cfg`),FfiConverterTypeAppDetails.lower(`app`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeNewChallengeLoaderResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `newDraft`(`session`: MailUserSession, `createMode`: DraftCreateMode) : NewDraftResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_draft(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeDraftCreateMode.lower(`createMode`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeNewDraftResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Create new instance of the watcher for the `session` with `callback`.
         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `newDraftSendWatcher`(`session`: MailUserSession, `callback`: DraftSendResultCallback) : NewDraftSendWatcherResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_draft_send_watcher(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeDraftSendResultCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeNewDraftSendWatcherResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `newInboxMailbox`(`ctx`: MailUserSession): NewInboxMailboxResult {
            return FfiConverterTypeNewInboxMailboxResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_inbox_mailbox(
        FfiConverterTypeMailUserSession.lower(`ctx`),_status)
}
    )
    }
    
 fun `newMailbox`(`ctx`: MailUserSession, `labelId`: Id): NewMailboxResult {
            return FfiConverterTypeNewMailboxResult.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_mailbox(
        FfiConverterTypeMailUserSession.lower(`ctx`),FfiConverterTypeId.lower(`labelId`),_status)
}
    )
    }
    
 fun `newRecipient`(`email`: kotlin.String): SingleRecipientEntry {
            return FfiConverterTypeSingleRecipientEntry.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_new_recipient(
        FfiConverterString.lower(`email`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `openDraft`(`session`: MailUserSession, `messageId`: Id) : OpenDraftResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_open_draft(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeOpenDraftResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `recordAccountRecoveryScreenView`(`screenId`: AccountRecoveryScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_account_recovery_screen_view(
        FfiConverterTypeAccountRecoveryScreenId.lower(`screenId`),_status)
}
    
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordDriveSpotlightCtaButtonTapped`(`userSession`: MailUserSession, `planBeforeUpgrade`: kotlin.String) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_drive_spotlight_cta_button_tapped(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterString.lower(`planBeforeUpgrade`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordDriveSpotlightMailboxButtonTapped`(`userSession`: MailUserSession, `planBeforeUpgrade`: kotlin.String) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_drive_spotlight_mailbox_button_tapped(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterString.lower(`planBeforeUpgrade`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `recordFidoLaunchResult`(`result`: FidoLaunchResultStatus)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_fido_launch_result(
        FfiConverterTypeFidoLaunchResultStatus.lower(`result`),_status)
}
    
    
 fun `recordFidoSignResult`(`result`: FidoSignResultStatus)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_fido_sign_result(
        FfiConverterTypeFidoSignResultStatus.lower(`result`),_status)
}
    
    
 fun `recordHumanVerificationResult`(`status`: HumanVerificationStatus)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_human_verification_result(
        FfiConverterTypeHumanVerificationStatus.lower(`status`),_status)
}
    
    
 fun `recordHumanVerificationScreenView`(`screenId`: HumanVerificationScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_human_verification_screen_view(
        FfiConverterTypeHumanVerificationScreenId.lower(`screenId`),_status)
}
    
    
 fun `recordHumanVerificationViewLoadingResult`(`status`: HumanVerificationViewLoadingStatus)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_human_verification_view_loading_result(
        FfiConverterTypeHumanVerificationViewLoadingStatus.lower(`status`),_status)
}
    
    
 fun `recordLoginScreenView`(`screenId`: LoginScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_login_screen_view(
        FfiConverterTypeLoginScreenId.lower(`screenId`),_status)
}
    
    
 fun `recordSignupScreenView`(`screenId`: SignupScreenId)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_signup_screen_view(
        FfiConverterTypeSignupScreenId.lower(`screenId`),_status)
}
    
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordUpgradeAttempt`(`userSession`: MailUserSession, `general`: GeneralDimensions, `planSpecific`: PlanSpecificDimensions) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_upgrade_attempt(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterTypeGeneralDimensions.lower(`general`),FfiConverterTypePlanSpecificDimensions.lower(`planSpecific`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordUpgradeCancelledByUser`(`userSession`: MailUserSession, `general`: GeneralDimensions, `planSpecific`: PlanSpecificDimensions) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_upgrade_cancelled_by_user(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterTypeGeneralDimensions.lower(`general`),FfiConverterTypePlanSpecificDimensions.lower(`planSpecific`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordUpgradeError`(`userSession`: MailUserSession, `general`: GeneralDimensions, `planSpecific`: PlanSpecificDimensions) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_upgrade_error(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterTypeGeneralDimensions.lower(`general`),FfiConverterTypePlanSpecificDimensions.lower(`planSpecific`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordUpgradeSuccess`(`userSession`: MailUserSession, `general`: GeneralDimensions, `planSpecific`: PlanSpecificDimensions) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_upgrade_success(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterTypeGeneralDimensions.lower(`general`),FfiConverterTypePlanSpecificDimensions.lower(`planSpecific`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `recordUpsellButtonTapped`(`userSession`: MailUserSession, `general`: GeneralDimensions) {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_record_upsell_button_tapped(FfiConverterTypeMailUserSession.lower(`userSession`),FfiConverterTypeGeneralDimensions.lower(`general`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `reportAnIssue`(`session`: MailUserSession, `issueReport`: IssueReport) : VoidSessionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_report_an_issue(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeIssueReport.lower(`issueReport`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidSessionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `reportPhishing`(`mailbox`: Mailbox, `messageId`: Id) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_report_phishing(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * [`RemoteId`] on its own is useless, because all our UniFFI endpoints operate on
         * local ids. This method translates remote id into local [`Id`].
         *
         * It may happen, that the [`RemoteId`] points to the message that does not exist in our
         * database yet. In that case, Rust SDK will fetch necessary information from API before returning the id.

         */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `resolveMessageId`(`session`: MailUserSession, `remoteId`: RemoteId) : ResolveMessageIdResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_resolve_message_id(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeRemoteId.lower(`remoteId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeResolveMessageIdResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `resolveSystemLabelById`(`ctx`: MailUserSession, `id`: Id) : ResolveSystemLabelByIdResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_resolve_system_label_by_id(FfiConverterTypeMailUserSession.lower(`ctx`),FfiConverterTypeId.lower(`id`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeResolveSystemLabelByIdResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `resolveSystemLabelId`(`ctx`: MailUserSession, `label`: SystemLabel) : ResolveSystemLabelIdResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_resolve_system_label_id(FfiConverterTypeMailUserSession.lower(`ctx`),FfiConverterTypeSystemLabel.lower(`label`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeResolveSystemLabelIdResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

        /**
         * Log `line` with debug level.
         */ fun `rustLogDebug`(`line`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_log_debug(
        FfiConverterString.lower(`line`),_status)
}
    
    

        /**
         * Log `line` with error level.
         */ fun `rustLogError`(`line`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_log_error(
        FfiConverterString.lower(`line`),_status)
}
    
    

        /**
         * Log `line` with info level.
         */ fun `rustLogInfo`(`line`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_log_info(
        FfiConverterString.lower(`line`),_status)
}
    
    

        /**
         * Log `line` with trace level.
         */ fun `rustLogTrace`(`line`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_log_trace(
        FfiConverterString.lower(`line`),_status)
}
    
    

        /**
         * Log `line` with warning level.
         */ fun `rustLogWarn`(`line`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_log_warn(
        FfiConverterString.lower(`line`),_status)
}
    
    

        /**
         * Return the version string of the rust sdk compiled in this artifact.
         */ fun `rustSdkVersion`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_sdk_version(
        _status)
}
    )
    }
    

        /**
         * Return major component of version string of the rust sdk compiled in this artifact.
         */ fun `rustSdkVersionMajor`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_major(
        _status)
}
    )
    }
    

        /**
         * Return minor component of version string of the rust sdk compiled in this artifact.
         */ fun `rustSdkVersionMinor`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_minor(
        _status)
}
    )
    }
    

        /**
         * Return patch component of version string of the rust sdk compiled in this artifact.
         */ fun `rustSdkVersionPatch`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_rust_sdk_version_patch(
        _status)
}
    )
    }
    
 fun `sanitizePastedContent`(`content`: kotlin.String, `mimeType`: MessageMimeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_sanitize_pasted_content(
        FfiConverterString.lower(`content`),FfiConverterTypeMessageMimeType.lower(`mimeType`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `scrollConversationsForLabel`(`mailbox`: Mailbox, `callback`: ConversationScrollerLiveQueryCallback) : ScrollConversationsForLabelResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_scroll_conversations_for_label(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeConversationScrollerLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeScrollConversationsForLabelResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `scrollMessagesForLabel`(`mailbox`: Mailbox, `callback`: MessageScrollerLiveQueryCallback) : ScrollMessagesForLabelResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_scroll_messages_for_label(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeMessageScrollerLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeScrollMessagesForLabelResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `scrollerSearch`(`mailbox`: Mailbox, `options`: PaginatorSearchOptions, `callback`: MessageScrollerLiveQueryCallback) : ScrollerSearchResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_scroller_search(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypePaginatorSearchOptions.lower(`options`),FfiConverterTypeMessageScrollerLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeScrollerSearchResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `sendPaymentObservabilityMetric`(`metric`: PaymentObservabilityMetric)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_send_payment_observability_metric(
        FfiConverterTypePaymentObservabilityMetric.lower(`metric`),_status)
}
    
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `snoozeConversations`(`session`: MailUserSession, `labelId`: Id, `ids`: List<Id>, `snoozeTime`: UnixTimestamp) : SnoozeConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_snooze_conversations(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`labelId`),FfiConverterSequenceTypeId.lower(`ids`),FfiConverterTypeUnixTimestamp.lower(`snoozeTime`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSnoozeConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `starConversations`(`session`: MailUserSession, `ids`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_star_conversations(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `starMessages`(`session`: MailUserSession, `messageIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_star_messages(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `unblockAddress`(`mailbox`: Mailbox, `email`: kotlin.String) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_unblock_address(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterString.lower(`email`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `unsnoozeConversations`(`session`: MailUserSession, `labelId`: Id, `ids`: List<Id>) : UnsnoozeConversationsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_unsnooze_conversations(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`labelId`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUnsnoozeConversationsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `unstarConversations`(`session`: MailUserSession, `ids`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_unstar_conversations(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`ids`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `unstarMessages`(`session`: MailUserSession, `messageIds`: List<Id>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_unstar_messages(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeId.lower(`messageIds`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `updateMobileConversationToolbarActions`(`session`: MailUserSession, `actions`: List<MobileAction>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_update_mobile_conversation_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeMobileAction.lower(`actions`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `updateMobileListToolbarActions`(`session`: MailUserSession, `actions`: List<MobileAction>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_update_mobile_list_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeMobileAction.lower(`actions`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `updateMobileMessageToolbarActions`(`session`: MailUserSession, `actions`: List<MobileAction>) : VoidActionResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_update_mobile_message_toolbar_actions(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterSequenceTypeMobileAction.lower(`actions`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeVoidActionResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `updateNextMessageOnMove`(`ctx`: MailUserSession, `enabled`: kotlin.Boolean) : UpdateNextMessageOnMoveResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_update_next_message_on_move(FfiConverterTypeMailUserSession.lower(`ctx`),FfiConverterBoolean.lower(`enabled`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUpdateNextMessageOnMoveResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `watchContactList`(`session`: MailUserSession, `callback`: ContactsLiveQueryCallback) : WatchContactListResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_watch_contact_list(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeContactsLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchContactListResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `watchConversation`(`mailbox`: Mailbox, `id`: Id, `origin`: OpenConversationOrigin, `showAll`: kotlin.Boolean, `callback`: LiveQueryCallback) : WatchConversationResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_watch_conversation(FfiConverterTypeMailbox.lower(`mailbox`),FfiConverterTypeId.lower(`id`),FfiConverterTypeOpenConversationOrigin.lower(`origin`),FfiConverterBoolean.lower(`showAll`),FfiConverterTypeLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchConversationResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `watchMailSettings`(`ctx`: MailUserSession, `callback`: LiveQueryCallback) : WatchMailSettingsResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_watch_mail_settings(FfiConverterTypeMailUserSession.lower(`ctx`),FfiConverterTypeLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchMailSettingsResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `watchMessage`(`session`: MailUserSession, `messageId`: Id, `callback`: LiveQueryCallback) : WatchMessageResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_watch_message(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),FfiConverterTypeLiveQueryCallback.lower(`callback`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchMessageResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `watchPrivacyInfoStream`(`session`: MailUserSession, `messageId`: Id) : WatchPrivacyInfoStreamResult {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_proton_mail_uniffi_fn_func_watch_privacy_info_stream(FfiConverterTypeMailUserSession.lower(`session`),FfiConverterTypeId.lower(`messageId`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_proton_mail_uniffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeWatchPrivacyInfoStreamResult.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }


